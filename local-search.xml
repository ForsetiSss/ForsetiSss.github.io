<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Supplementary2</title>
    <link href="/2023/11/30/Supplementary2/"/>
    <url>/2023/11/30/Supplementary2/</url>
    
    <content type="html"><![CDATA[<h2id="supplementary-of-online-monitoring-dynamic-characteristics-in-thin-walled-structures-milling-a-physics-constrained-bayesian-updating-approach">Supplementaryof 'Online monitoring dynamic characteristics in thin-walled structuresmilling: A physics-constrained Bayesian updating approach'</h2><h3id="a.-the-derivation-of-the-training-target-of-the-proposed-diffusion-model">A.The derivation of the training target of the proposed diffusionmodel</h3><p><strong>Training:</strong> To obtain the optimal parameters of theneural network, we need to minimize the cross entropy between <spanclass="math inline">\(q\left( {\bf{x}_0} \right)\)</span> and <spanclass="math inline">\({p_\theta }\left( {\bf{x}_0}\right)\)</span>. Theloss <span class="math inline">\(L\)</span> can be expressed a:</p>$$\begin{equation}\begin{array}{l}  L = {\mathbb{E}_{q\left( {{\mathbf{x}_0}} \right)}}\left[ { - \log {p_\theta }\left( {{{\bf{x}}_0}} \right)} \right]\\  \le {\mathbb{E}_{q\left( {{\mathbf{x}_0}} \right)}}\left[ { - \log {p_\theta }\left( {{{\bf{x}}_0}} \right) + {D_{{\rm{KL}}}}\left( {q\left( {{{\bf{x}}_{1:T}}\vert {{\bf{x}}_0}} \right)\| {p_\theta }\left( {{{\bf{x}}_{1:T}}\vert {{\bf{x}}_0}} \right)} \right)} \right]\\  = {\mathbb{E}_{q\left( {{\mathbf{x}_0}} \right)}} \! \left[ {\! -\! \log {p_\theta }\left( {{{\mathbf{x}}_0}} \right) \!+\! {\mathbb{E}_{q\left( {{{\mathbf{x}}_{1:T}}\vert {{\mathbf{x}}_0}} \right)}} \! \left[ {\log \frac{{q\left( {{{\mathbf{x}}_{1:T}}\vert {{\mathbf{x}}_0}} \right)}}{{{p_\theta }\! \left( {{{\mathbf{x}}_{0:T}}} \right)\!/\!{p_\theta }\left( {{{\mathbf{x}}_0}} \right)}}} \right]} \! \right]\\  = {\mathbb{E}_{q\left( {{x_{0:T}}} \right)}}\left[ {\log \frac{{q\left( {{{\bf{x}}_{1:T}}\vert {{\bf{x}}_0}} \right)}}{{{p_\theta }\left( {{{\bf{x}}_{0:T},\mathbf{y}}} \right)}}} \right]\end{array}\end{equation}$$<p>where <span class="math inline">\({D_{\rm{KL}}}\left( \cdot \| \cdot\right)\)</span> denotes the KL divergence which is alwaysnon-negative.</p><p>Further, the loss function can be derived as follows:</p><p>$$ <span class="math display">\[\begin{equation}\begin{array}{l}  L &amp;= \underbrace{D_{\mathrm{KL}}\left(q\left(\mathbf{x}_T \vert\mathbf{x}_0\right) \| p_\theta\left(\mathbf{x}_T\right)\right)}_{L_T}\\  &amp;+\sum_{t=1}^T \underbrace{\mathbb{E}_{q\left(\mathbf{x}_t \vert\mathbf{x}_0\right)}\left[D_{\mathrm{KL}}\left(q\left(\mathbf{x}_{t-1}\vert \mathbf{x}_t, \mathbf{x}_0\right) \|p_\theta\left(\mathbf{x}_{t-1} \vert\mathbf{x}_t,\mathbf{y}\right)\right)\right]}_{L_{t-1}}\\\end{array}\end{equation}\]</span> $$</p><p>The final optimization objective contains <spanclass="math inline">\(T+1\)</span> terms. Because the prior distribution<span class="math inline">\(p_\theta\left(\mathbf{x}_T\right)=\mathcal{N}(\mathbf{0}, \mathbf{I})\)</span>and the <span class="math inline">\(q\left(\mathbf{x}_T \vert\mathbf{x}_0\right)\)</span> can be also approximated as isotropicGaussian noise, the <span class="math inline">\(L_T\)</span> turns to bea constant which can be ignored in optimization.</p><p>According to Bayes' rule, the posterior distribution <spanclass="math inline">\(\mathrm{q}\left(\mathbf{x}_{\mathrm{t}-1} \vert\mathbf{x}_{\mathrm{t}}, \mathbf{x}_0\right)\)</span> can be written asEq. (<span class="math inline">\(\ref{eq7}\)</span>).</p><p>$$ <span class="math display">\[\begin{equation}\label{eq7}\begin{aligned}  q\left(\mathbf{x}_{t-1} \vert \mathbf{x}_t,\mathbf{x}_0\right)=\mathcal{N}\left(\mathbf{x}_{t-1} ;\tilde{\boldsymbol{\mu}}_t\left(\mathbf{x}_t, \mathbf{x}_0\right),\tilde{\beta}_t \mathbf{I}\right)\end{aligned}\end{equation}\]</span> $$</p><p>We can derive the mean and variance of <spanclass="math inline">\(\mathrm{q}\left(\mathbf{x}_{\mathrm{t}-1} \vert\mathbf{x}_{\mathrm{t}}, \mathbf{x}_0\right)\)</span> by the definitionof Gaussian distribution as <spanclass="math inline">\(\tilde{\boldsymbol{\mu}}_t\left(\mathbf{x}_t,\mathbf{x}_0\right) = \frac{\sqrt{\bar{\alpha}_{t-1}}\beta_t}{1-\bar{\alpha}_t}\mathbf{x}_0+\frac{\sqrt{\alpha_t}\left(1-\bar{\alpha}_{t-1}\right)}{1-\bar{\alpha}_t}\mathbf{x}_t\)</span> and <span class="math inline">\(\tilde{\beta}_t =\frac{1-\bar{\alpha}_{t-1}}{1-\bar{\alpha}_t} \beta_t\)</span>respectively, where <spanclass="math inline">\(\alpha_t=1-\beta_t\)</span> and <spanclass="math inline">\(\bar{\alpha}_t=\prod_{i=1}^t\alpha_i\)</span>.</p><p>For the transition probability <spanclass="math inline">\(p_\theta\left(\mathbf{x}_{t-1} \vert\mathbf{x}_t,\mathbf{y}\right)\)</span>, since <spanclass="math inline">\(\mathbf{x}_{t}\)</span> is known in the reverseprocess, we may choose the parameterization of <spanclass="math inline">\(\boldsymbol{\mu}_\theta\)</span> as</p><p>$$ <span class="math display">\[\begin{equation}\begin{aligned}\boldsymbol{\mu}_\theta\left(\mathbf{x}_t,\mathbf{y}, t\right)=\frac{1}{\sqrt{\alpha_t}}\left(\mathbf{x}_t-\frac{\beta_t}{\sqrt{1-\bar{\alpha}_t}}\boldsymbol{\epsilon}_\theta\left(\mathbf{x}_t, \mathbf{y},t\right)\right)\end{aligned}\end{equation}\]</span> $$ and <spanclass="math inline">\(\sigma_\theta\left(\mathbf{x}_t, t\right)\)</span>as a fixed constant <spanclass="math inline">\(\tilde{\beta}_t^{\frac{1}{2}}\)</span>.</p><p>Consequently, by considering the KL divergence between two Gaussiandistribution <span class="math inline">\(D_{KL}(p, q)=\log\frac{\sigma_2}{\sigma_1}+\frac{\sigma_1^2+\left(\mu_1-\mu_2\right)^2}{2\sigma_2^2}-\frac{1}{2}\)</span>, the optimization objective <spanclass="math inline">\(L_{t-1}\)</span> can be further simplified as</p><p>$$ <span class="math display">\[\begin{equation}\begin{array}{l}  L_{t-1} &amp;= \mathbb{E}_{q\left(\mathbf{x}_t \vert\mathbf{x}_0\right)} \left[ \frac{1}{2\sigma_t^2}\left\|\tilde{\mathbf{\mu}}_t\left(\mathbf{x}_t,\mathbf{x}_0\right)-\mathbf{\mu}_\theta\left(\mathbf{x}_t,\mathbf{y},t\right)\right\|_2^2 \right] + C\\  &amp;= \kappa_t \mathbb{E}_{\mathbf{x}_0, \epsilon} \left[\left\|\epsilon-\epsilon_\theta\left(\sqrt{\bar{\alpha}_t}\mathbf{x}_0+\sqrt{1-\bar{\alpha}_t} \epsilon,\mathbf{y},t\right)\right\|_2^2\right] + C\end{array}\end{equation}\]</span> $$ where <span class="math inline">\(C\)</span>and <span class="math inline">\(\kappa_t=\frac{\beta_t}{2\alpha_t\left(1-\bar{\alpha}_{t-1}\right)}\)</span> is a constant.</p><p>The point is to transform the intractable cross entropy between <spanclass="math inline">\(q\left( {\mathbf{x}_0} \right)\)</span> and <spanclass="math inline">\({p_\theta }\left({\mathbf{x}_0},\mathbf{y}\right)\)</span> into the closed form KLdivergences.</p><p>According to Ho et al. , a simplified loss function which discardsthe weighting of <span class="math inline">\(L_{t-1}\)</span> has beenproved more effective as follows.</p><p>$$ <span class="math display">\[\begin{equation}\begin{aligned}  L_{simple}= \mathbb{E}_{\mathbf{x}_0, \epsilon} \left[\left\|\epsilon-\epsilon_\theta\left(\sqrt{\bar{\alpha}_t}\mathbf{x}_0+\sqrt{1-\bar{\alpha}_t} \epsilon,\mathbf{y},t\right)\right\|_2^2\right] + C\end{aligned}\end{equation}\]</span> $$</p><p>It can be noticed that diffusion step <spanclass="math inline">\(t\)</span> is specifically added in <spanclass="math inline">\(\boldsymbol{\epsilon}_{\boldsymbol{\theta}}\left(\bar{\alpha}_t\boldsymbol{x}_0+\bar{\beta}_t \boldsymbol{\varepsilon},\mathbf{y},t\right)\)</span> using the sinusoidal position embedding for eachsample to share the same model parameters. That is because at everydiffusion step <span class="math inline">\(t\)</span>, a different modelneeds to be learned to represent the reverse process. The diffusion stepembedding structures within a neural network will be further discussedin next section.</p><p><strong>Accelerated sampling:</strong> Given the learned reverseprocess, the high-resolution cutting force signals can be generated byfirst sampling a Gaussian noise <span class="math inline">\(\mathbf{x}_T\sim \mathcal{N}(0, I)\)</span>, and then <spanclass="math inline">\(\mathbf{x}_{t-1} \simp_\theta\left(\mathbf{x}_{t-1} \vert \mathbf{x}_t,\mathbf{y}\right)\)</span> for step by step. The final output <spanclass="math inline">\(\mathbf{x}_0\)</span> will be the target forcesignal. However, for a general reverse process the calculation of thesampling can be time-consuming with large denoising step <spanclass="math inline">\(T\)</span> (e.g. 200). This encourages us toimprove the inference process and design a fast sampling algorithm withfewer denoising steps <spanclass="math inline">\(T_{\text{infer}}\)</span> (<spanclass="math inline">\(T_{\text{infer}}\ll T\)</span>). The key point isto rearrange the <span class="math inline">\(T\)</span> step in trainingprocess into <span class="math inline">\(T_{\text{infer}}\)</span> stepprocess with specially selected variance schedule <spanclass="math inline">\({\beta^ {\prime}_s}\)</span>. The design approachof the variance schedule and the calculation of corresponding constantscan reference the algorithm in .</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch 踩坑</title>
    <link href="/2023/05/29/Pytorch-%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/05/29/Pytorch-%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch踩坑">Pytorch踩坑</h2><ol type="1"><li><h4id="runtimeerror-function-weightnorminterfacebackward0-returned-nan-values-in-its-0th-output.">RuntimeError:Function 'weightnorminterfacebackward0' returned nan values in its 0thoutput.</h4></li></ol><p><img src="/images/2023-05-29-Pytorch-踩坑/returned nan values in its 0th output.png" /></p><p>该错误可能由过大的学习率和batchsize导致，尝试减小学习率后解决此问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Supplementary</title>
    <link href="/2023/01/17/Supplementary/"/>
    <url>/2023/01/17/Supplementary/</url>
    
    <content type="html"><![CDATA[<h2id="supplementary-of-online-monitoring-dynamic-characteristics-in-thin-walled-structures-milling-a-physics-constrained-bayesian-updating-approach">Supplementaryof 'Online monitoring dynamic characteristics in thin-walled structuresmilling: A physics-constrained Bayesian updating approach'</h2><h3 id="a.-the-practicability-on-complicated-thin-walled-structures">A.The practicability on complicated thin-walled structures</h3><p>The vibration model used in the paper are only applicable to theKirchhoff-Love plate with fixed-free boundary conditions. Nonetheless,the physical constraints can be revised to adapt to more complicatedstructures such as doubly-curved (e.g. turbine blades) or pocketstructures (e.g. airframe parts). A general equation of the mode shapefunctions can be expressed as: <span class="math display">\[\begin{equation}W(x, y)=\sum_{m=1}^{p} \sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\end{equation}\]</span> where <span class="math display">\[\begin{equation}\begin{array}{l}X_{n}=C_{1,x}\sin \alpha x + {C_{2,x}}\cos \alpha x + {C_{3,x}}\sinh\beta x + {C_{4,x}}\cosh \beta x\\{Y_m}=C_{1,y}\sin \alpha x + {C_{2,y}}\cos \alpha x + {C_{3,y}}\sinh\beta x + {C_{4,y}}\cosh \beta x\end{array}\end{equation}\]</span> The simplified boundary conditions used in the paper is basedon the Euler-Bernoulli beam, which is no longer applicable for thesestructures. A more precise form of boundary conditions of thin-walledplates are listed as follows:</p><p>For fixed boundary at <em>x</em>=0, <span class="math display">\[\begin{equation}{ {\left. W \right|}_{x = 0} = 0,\quad  {\left. {\frac{ {\partial W} }{{\partial x} } } \right|}_{x = 0} } = 0\end{equation}\]</span> For simply supported boundary at <em>x</em>=0, <spanclass="math display">\[\begin{equation}{ {\left. W \right|}_{x = 0} = 0,\quad {\left. {\frac{ { {\partial ^2}W}}{ {\partial {x^2} } } } \right|}_{x = 0}} = 0\end{equation}\]</span> For free boundary at <em>x</em>=<em>a</em>,</p>$${ { {\left. {\frac{ { {\partial ^2}W} } { {\partial {x^2} } } + \mu \frac{{{\partial ^2}W} } { {\partial {y^2}}}} \right|}_{x = a}} = 0,\quad { {\left. {\frac{ { {\partial ^3}W}}{{\partial {x^3} } } + (2 - \mu )\frac{ { {\partial ^3}W} } { {\partial x\partial {y^2} } } } \right|}_{x = a} } = 0}$$Besides, for the angular corner with two adjacent free boundaries, the shear stress equals zero,$${\left. {\frac{ { {\partial ^2}W}}{{\partial x\partial y}} } \right|_{\begin{array}{*{20}{c}}{x = a}\\{y = b}\end{array}}} = 0$$<p>The above mode shape functions and boundary conditions can beadequate for various thin-walled structures like doubly-curved or pocketstructures. Nevertheless, further researches is needed if the thicknessand geometry irregularity of the structure is non-negligible.</p><h3 id="b.-the-acquisition-of-experimental-frf">B. The acquisition ofexperimental FRF</h3><p>In the experimental work, the computation of experimental FRF usesWelch’s method and H1 estimator from the measured machining forces andaccelerometer response. The resolution of the resulting FRF is equal tothe spindle rotation frequency (i.e. 20 Hz in the experiment), thebandwidth of which is quite limited. Usually, spindle speed sweep orrandomized workpiece pattern is used to enrich the excitation range andresolution. However, constant spindle speed and tool path can make themethod more practical in practical machining. Furthermore, despite therelative low resolution in single measurement, the practical resolutioncan be improved by the proposed online monitoring method by continuousmultiple measurement and updating. Because there are more than 10thousand updating steps during machining process, and the practicalresolution and accuracy can be improved step by step. Thus, themonitoring accuracy of the frequency is sufficient in commonapplications.</p><p>Another problem is that the natural frequency of the plates is muchhigher than the spindle rotation frequency. It is true that the 50thharmonic of the spindle rotation frequency is far from the plates’ firstmode. However, the experimental results show that the concerning modesof the plates can be well excited as shown in the following figure.</p><p><img src="/images/2023-01-17-Supplementary/A sample of monitoring process.png" alt="Fig. 1 A sample of the monitoring process of modal parameters. (a) Measured acceleration signal in real time. (b) Acceleration spectrum with FFT. (c) Simulated force spectrum with FFT. (d) Corrected Force spectrum with FFT. (e) Derived FRF at the measurement point." style="auto;zoom:80%;" /></p><p>A randomly selected sample of- the monitored signals and thepreprocessing are presented in- Fig. 3. The spindle speed and the feedrate are pre-defined and kept unchanged in each tool path during themachining. Therefore, the real-time tool contact location can beobtained by integrating the feed speed as long as the moment of toolentrance is detected in each pass. The differential signal of theacceleration is utilized to detect these moments. The measured forcespectrum and corrected force spectrum are presented as in Fig. 1. Itshows a cut-off of 1 kHz in the measured force spectrum because of thelimits of dynamometer. The corrected cutting force is utilized for amore accurate calculation in high frequency in the monitoring process asthe cut-off frequency of the dynamometer is only 1 kHz. Thus, the FRFbetween the tool contact location and the response point (location ofaccelerometer) can be calculated with the cutting force and theacceleration signal. From the FRF, observation values of modalparameters including natural frequencies and modal shapes can bederived. The FRF is sampled at the harmonic frequencies of the spindleto avoid unexpected noise.</p><p>As shown in the Fig. 1, the spectrum of the (corrected) forcesbecomes almost zero after 2000Hz. There is a risk that the coherencebetween the cutting force and the acceleration response becomes poor inhigh frequency when the workpiece may not be fully excited due to thelow magnitude of the force spectrum. Here give two different samples ofthe magnitude-squared coherence estimated at the harmonic frequencies ofspindle speed via welch.</p><p><img src="/images/2023-01-17-Supplementary/coherence analysis.png" alt="Fig. 2. The comparison of magnitude-squared coherence between sample A (normal) and sample B (excessive noise)." style="auto;zoom:80%;" /></p><p>As shown in the above figure, the mean coherence from 2000 Hz to 4500Hz is 0.79 for sample A, while the mean coherence from 2000 Hz to 4500Hz is as low as 0.46 for sample B. The coherence of the FRF depends onthe noise level of the input signals. The actual processing conditionsat different cutting positions and cutting parameters would have variousdegrees of influence on the noise level of the measured signals.</p><p>For sample A, the coherence is acceptable and the measured FRF canprovide useful information for the modal parameter update. A highlyvariant FRF estimation will undoubtedly affect the accuracy of thepredictions of the mode shapes. For sample B, the estimated FRF is shownto be distorted by the noise and the true mode information cannot beextracted.</p><p>In practice, we reject the information from FRF when the meancoherence is lower than 0.5 by setting the relative coefficients in<span class="math inline">\(h\left( {\bf{x}}_t \right)\)</span> to zerowhen executing the measurement update</p><p>The installation locations may affect the signal-to-noise ratio (SNR)of the acceleration signals and FRF for different modes of thethin-walled structures. For comparison, two accelerometers are installedon the plate as shown in Fig. 2.</p><p><img src="/images/2023-01-17-Supplementary/Installation of sensors.png" alt="Fig. 3. The installation location of the two accelerometers during the machining experiment." style="auto;zoom:60%;" /></p><p>The Acc1 is the accelerometer used in the experiments. The Acc2 worksas a reference accelerometer located at (0,0.8) in normalizedcoordinate. The acceleration spectrums of two accelerometers arepresented as follows.</p><p><img src="/images/2023-01-17-Supplementary/Installation of sensors signal comparison.png" alt="Fig. 4. The acceleration signals and spectrums of two accelerometers at the same moment of the machining" style="auto;zoom:80%;" /></p><p>As shown in the figure, the spectrums of two accelerometers havedifferent peak amplitude for each mode. Assuming the signal noises keepthe same, the greater the amplitude, the higher the SNR is. For thesamples presented in Fig. 6, the SNR of the acceleration signal for Acc2installed at (0, 0.8) is lower than the other one, which can lead to arelatively lower accuracy for the modal parameters monitoring of theproposed method.</p><p>Furthermore, the installation location of the accelerometer shouldavoid the nodes of modal shapes of all concerned modes because at theselocations the response is always zero for the corresponding mode. So thefinite element analysis and pre-experiment need to be conducted toprovide proper location for the sensor installation.</p><h3 id="c.-more-experimental-data">C. More experimental data</h3><p>The experiments show the machining processes of two kinds ofthin-walled structures from the 4 mm to 3 mm thickness. Due to the pagelimit, part of the results of the experiments are not presented in thepaper. The following figure shows the result of predicted mode shapes ofW2 with the proposed physics-constrained method.</p><p><img src="/images/2023-01-17-Supplementary/modal shape of W2.png" alt="Fig. 5. The final predicted mode shapes of W2 with the proposed physics-constrained method, where (a) (c) (e) represent the normalized predicted mode shapes of the first three orders and (b) (d) (f) represent the relative errors of the proposed method compared with the results of impact hammer test." style="auto;zoom:80%;" /></p><p>Besides, part of the results of tracking of mode shapes are presentedhere as a supplementary. Some samples of the monitored mode shapes of W1with the proposed method before the final stage are presented. The modeshapes keep stable in the machining process because of the physicalconstraints.</p><p><img src="/images/2023-01-17-Supplementary/modal shape of W2.png" alt="Fig. 6. modal shape tracking" style="auto;zoom:80%;" /></p><p>Despite of the deficiency of global modal information and signalnoise, the proposed method can help to reduce the average relativeerrors of mode shapes steadily as presented in Fig. 6.</p><p><img src="/images/2023-01-17-Supplementary/modal shape tracking errors.png" alt="Fig. 7. The average relative errors of tracking of mode shapes of W1 with the proposed physics-constrained method compared with the impact hammer test." style="auto;zoom:40%;" /></p><p>The paper mainly focuses on the principles and framework of theupdating approach. The validation experiments are only based on twotypical kinds of workpiece to present the practicability and theperformance of the proposed method. In further studies, the generalityof the proposed method will be discussed with improved theoreticalanalysis and more sufficient experimental data on more complicatedthin-walled structures like turbine blades and pocket structures. Thegenerality of the proposed method can be extended by selecting propermode shape functions <span class="math inline">\(W (x, y)\)</span> andboundary conditions for various structures.</p><h3 id="d.-modal-damping-update">D. Modal damping update</h3><p>As illustrated in the paper, the damping ratios are directly obtainedby impact hammer modal analysis considering the significant disturbanceof process damping and the high noise introduced by the machiningprocess. As there is no prior information on the damping ratios given bythe FEM, the varying damping ratios during the machining can only beapproximated by the interpolation of the tested values. Consequently,the variance of the predicted results can be very large, and the finalresults of damping ratios are not reliable in practical application.</p><p>Nevertheless, we try to present the monitoring results of the dampingratios.</p><p><img src="/images/2023-01-17-Supplementary/modal damping update.png" alt="Fig. 8. The updating process of the damping ratios of the first 3 orders of W1 from the thickness of 4 mm to 3 mm. The observation value and the prediction value with the proposed Bayesian filter method are indicated by the dotted lines and solid lines respectively. The shadow areas denote the 95% confidence interval. The circles represent the measured damping ratios with impact hammer test. The predicted values and relative errors are labeled by red arrows at the initial, middle and final states respectively." style="auto;zoom:40%;" /></p><p>The true values of the damping ratios are measured by impact hammermodal test and indicated as circles on each line. The relative errors ofthe predicted results to the true values are presented in the brackets.The true values of the final state after machining process are 2.0 %,0.16 %, and 0.09 % respectively, and the corresponding relative errorsare -96 %，195 %， and -100 % of the first 3 modes. The relative errorsare equal to zero at the beginning because the initialization is basedon the values of the modal test. The results indicate a significantvariance even with an artificial pre-processing of abnormal values,suggesting that the predicted value may not be reliable. Consequently,the update of damping ratios is not implemented in the paper. Improvedmodal parameters identification method for damping ratios under suchnoisy conditions can be studied in future research to enhance theaccuracy and stability.</p>]]></content>
    
    
    
    <tags>
      
      <tag>paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows相关问题</title>
    <link href="/2022/09/26/Windows%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/26/Windows%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="mklink实现两个文件夹同步更新">mklink实现两个文件夹同步更新</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">MKLINK [[<span class="hljs-string">/D</span>] | [<span class="hljs-string">/H</span>] | [<span class="hljs-string">/J</span>]] <span class="hljs-string">&quot;Link&quot;</span> <span class="hljs-string">&quot;Target&quot;</span><br><br>        <span class="hljs-string">/D</span>      创建目录符号链接。默认为文件<br>                符号链接。<br>        <span class="hljs-string">/H</span>      创建硬链接，而不是符号链接。<br>        <span class="hljs-string">/J</span>      创建目录联接。<br>        Link    指定新的符号链接名称。<br>        Target  指定新链接引用的路径<br>                <span class="hljs-params">(相对或绝对)</span>。<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mklink <span class="hljs-string">/D</span> <span class="hljs-string">&quot;D:\xxxxxx&quot;</span> <span class="hljs-string">&quot;D:\yyyyyyy&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab滤波器设计</title>
    <link href="/2022/03/29/Matlab%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/29/Matlab%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="butterworth滤波器">Butterworth滤波器</h3><p>设计滤波器就是设计滤波器系数[B,A]。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[B,A] = BUTTER(n,Wn,ftype)<br></code></pre></td></tr></table></figure><p>返回归一化截止频率Wn的n阶巴特沃斯滤波器的传递函数系数</p><p>fytpe —— 滤波器类型 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">‘low’|<span class="hljs-string">&#x27;bandpass&#x27;</span>|<span class="hljs-string">&#x27;high&#x27;</span>|<span class="hljs-string">&#x27;stop&#x27;</span><br></code></pre></td></tr></table></figure></p><p>滤波器可视化工具 <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">fvtool(B,A)<br></code></pre></td></tr></table></figure></p><p><img src="/source/images/2022-03-29-Matlab滤波器设计/fvtool.png" alt="图1 滤波器响应" style="auto;zoom:80%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">signal_env=filter(b,a,signal_r);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客环境配置</title>
    <link href="/2022/02/11/hexo%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/11/hexo%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3id="git-clone出现-fatal-unable-to-access-httpsgithub.com...的解决办法">gitclone出现 fatal: unable to access<code>https://github.com/</code>...的解决办法</h3><p>发生这种情况是因为代理是在git中配置的。既然它是https代理（而不是http）gitconfig http.proxy和git config --global http.proxy也无济于事。</p><p>在开启shadowsocks的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//127.0.0.1:1080</span><br>git config <span class="hljs-attr">--global</span> https<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//127.0.0.1:1080</span><br></code></pre></td></tr></table></figure><p><code>http://</code>也可以改成<code>sockets5://</code>，但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。</p><p>取消代理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure><h3 id="hexo博客mathjax公式渲染问题">hexo博客MathJax公式渲染问题</h3><p>用<strong>MathJax语法</strong>写的一些公式，在本地<strong>Markdown编译器</strong>上渲染是没问题的，可是部署到hexo博客中就出现问题了</p><p>hexo默认使用<strong>hexo-renderer-marked</strong>引擎去渲染网页，它会把利用<strong>Markdown语法</strong>写的文本去转换为相应的<strong>html标签</strong>。在利用Markdown写<strong>MathJax公式</strong>的时候，经常会用到下划线<code>_</code>表示<strong>下标</strong>，但是下划线<code>_</code>会被hexo的默认引擎<strong>hexo-renderer-marked</strong>渲染成html中的<code>&lt;em&gt;</code>标签，表示<strong>斜体</strong>，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</p><p>问题或许出在hexo的<strong>渲染引擎</strong>上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的<strong>hexo-renderer-kramed</strong>引擎，这里是它的<ahref="https://github.com/sun11/hexo-renderer-kramed">Github页面</a>，所以我们只需要<strong>卸载</strong>默认引擎，并<strong>安装</strong>这个新的渲染引擎即可。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm install hexo-renderer-kramed <span class="hljs-comment">--save 或者</span><br>npm install hexo-renderer-pandoc <span class="hljs-comment">--save（需要本地安装pandoc）</span><br></code></pre></td></tr></table></figure><p>渲染引擎更换之后，发现大部分公式都正确渲染了，但可能仍然存在错误，即是<strong>行间公式</strong>都没有问题，但是个别<strong>行内公式</strong>还会出现渲染出错。</p><p>定位到你的<strong>博客根目录</strong>，找到<strong>../node_modules/kramed/lib/rules/inline.js</strong>文件，进行部分修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      第11行，将其修改为</span><br><span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,<br><span class="hljs-comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    第20行，将其修改为</span><br><span class="hljs-attr">em</span>: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<br></code></pre></td></tr></table></figure><p>它取消了该渲染引擎对<code>\,&#123;,&#125;</code>的转义，然后再<code>hexo clean、hexo g</code>重新部署，即可解决问题。</p><p><strong>另外</strong>，可以使用 <code>\brace</code>代替花括号避免公式中多个括号连用时渲染出现如下报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">parseAggregate: expected <span class="hljs-literal">colon</span> <span class="hljs-keyword">after</span> dict key <br></code></pre></td></tr></table></figure><h4 id="ravis-ci报错的问题-收费">ravis CI报错的问题 （收费）</h4><p>由于ravisCI上node.js版本或者pandoc版本问题，可能出现部署时渲染错误，需要将根目录下.travis.yml文件内容改为如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">sudo</span>: <span class="hljs-literal">true</span><br><span class="hljs-attr">language</span>: node_js<br><span class="hljs-attr">node_js</span>:<br>  - <span class="hljs-number">16</span> # use nodejs v12 <span class="hljs-variable constant_">LTS</span><br><span class="hljs-attr">cache</span>: <br>  - npm <br>  - pandoc<br>  - hexo-cli<br>  - hexo-renderer-pandoc<br><span class="hljs-attr">install</span>:<br>  - wget <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/jgm/pandoc/releases/download/2.7/pandoc-2.7-1-amd64.deb</span><br>  - sudo dpkg -i ./pandoc-<span class="hljs-number">2.7</span>-<span class="hljs-number">1</span>-amd64.<span class="hljs-property">deb</span><br>  - npm install -g hexo-cli<br>  - npm uninstall hexo-renderer-marked --save<br>  - npm install hexo-renderer-pandoc --save<br><span class="hljs-attr">branches</span>:<br>  <span class="hljs-attr">only</span>:<br>    - main # build master branch only<br><span class="hljs-attr">script</span>:<br>  - hexo clean<br>  - hexo generate # generate <span class="hljs-keyword">static</span> files<br><span class="hljs-attr">deploy</span>:<br>  <span class="hljs-attr">provider</span>: pages<br>  skip-<span class="hljs-attr">cleanup</span>: <span class="hljs-literal">true</span><br>  github-<span class="hljs-attr">token</span>: $GH_TOKEN<br>  keep-<span class="hljs-attr">history</span>: <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on</span>:<br>    <span class="hljs-attr">branch</span>: main<br>  local-<span class="hljs-attr">dir</span>: public<br></code></pre></td></tr></table></figure><h4id="由于自动部署服务ravis-ci开始收费改用本地一键部署功能">由于自动部署服务ravisCI开始收费，改用本地一键部署功能</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>通过Hexo提供快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上，当然部署之前需要先生成静态文件，详见[2]。</p><h3 id="reference">reference</h3><p>[1] <ahref="https://blog.csdn.net/Dashi_Lu/article/details/89641778?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant">gitclone出现 fatal: unable to access'https://github.com/...'的解决办法(亲测有效)_Dashi_Lu的博客-CSDN博客</a></p><p>[2] <a href="https://hexo.io/zh-cn/docs/one-command-deployment">部署| Hexo</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>薄板结构的模态分析</title>
    <link href="/2021/11/29/%E8%96%84%E6%9D%BF%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E6%80%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/29/%E8%96%84%E6%9D%BF%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E6%80%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="薄板结构的模态分析">薄板结构的模态分析</h2><h3 id="薄板的小挠度弯曲">1. 薄板的小挠度弯曲</h3><h4 id="薄板的基本概念和基本假设">1.1 薄板的基本概念和基本假设</h4><p>薄板是工程结构中的一种常用构件，它是由两个平行面和垂直于它们的柱面所围成的物体，几何特征是其高度远小于底面尺寸，简称板。薄板的弯曲变形属于弹性力学空间问题，由于数学求解的复杂性，因此，需要首先建立应力和变形分布的基本假设。</p><p><img src="/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp" alt="图1 薄板的基本概念" style="auto;zoom:80%;" /></p><p>薄板的上下两个平行面称为板面，垂直于平行面的柱面称为板边，如图所示。两个平行面之间的距离称为板厚，用<spanclass="math inline">\(\delta\)</span>表示。平分板厚的平面称为板的中面。假设板的厚度为<spanclass="math inline">\(\delta\)</span>，平分厚度<spanclass="math inline">\(\delta\)</span>的平面成为板的中间平面，简称为中面。如果板的厚度<spanclass="math inline">\(\delta\)</span>远小于中面的最小特征尺寸<spanclass="math inline">\(b\)</span>，例如<spanclass="math inline">\(1/5≤\delta/b≤1/80\)</span>，则称为薄板。如果外载荷为垂直于板的中面作用的横向载荷，则板主要变形为弯曲变形。中面在薄板弯曲时变形成为曲面，中面沿垂直方向，即横向位移称为挠度。对于薄板，仍然有相当的弯曲刚度，如果挠度小于厚度的五分之一，属于小挠度问题。</p><p>根据薄板的外载荷和几何特征，外力为横向载荷，厚度远小于薄板的平面宽度，可以忽略一些次要因素。薄板的小挠度弯曲理论是由三个基本假设作为基础，因为这些基本假设是由基尔霍夫首先提出的，因此又称为<strong>基尔霍夫假设</strong>。</p><ol type="1"><li><p>变形前垂直于中面的直线变形后仍然保持直线，而且长度不变。这相当于梁的弯曲变形平面假设。根据这一假设，<spanclass="math inline">\(ε_z＝γ_{zx}＝γ_{zy}＝0\)</span>。因此，在板内所有的点，位移分量<spanclass="math inline">\(w\)</span>只是<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>的函数而与<spanclass="math inline">\(z\)</span>无关。也就是说，在中面的任意一根法线上，薄板沿厚度方向的所有点都具有挠度<spanclass="math inline">\(w\)</span>。</p></li><li><p>垂直于中面方向的应力分量<spanclass="math inline">\(σ_z，τ_{zx}，τ_{zy}\)</span>远小于其他应力分量，其引起的变形可以不计，但是对于维持平衡是必要的，这相当于梁的弯曲无挤压应力假设。</p></li><li><p>薄板弯曲时，中面各点只有垂直中面的位移w，没有平行中面的位移，即</p></li></ol><p><span class="math display">\[\begin{equation}u_{z=0}=0, \quad v_{z=0}=0\end{equation}\]</span></p><p>根据这一假设，板的中面将没有变形发生。板的中面位移函数<spanclass="math inline">\(w(x, y)\)</span>称为挠度函数。</p><h4 id="板的小挠度弯曲的基本方程">1.2 板的小挠度弯曲的基本方程</h4><p>根据基尔霍夫假设和几何方程可以得到挠度函数表达的应变分量</p><p><span class="math display">\[\begin{equation}\begin{array}{l}\varepsilon_{x}=\frac{\partial u}{\partial x}=-\frac{\partial^{2}w}{\partial x^{2}} z \\\varepsilon_{y}=\frac{\partial v}{\partial y}=-\frac{\partial^{2}w}{\partial y^{2}} z \\y_{x y}=\frac{\partial u}{\partial y}+\frac{\partial v}{\partial x}=-2\frac{\partial^{2} w}{\partial x \partial y} z\end{array}\end{equation}\]</span></p><p>和应力分量</p><p><span class="math display">\[\begin{equation}\begin{array}{l}\sigma_{x}=\frac{-E z}{1-v^{2}}\left(\frac{\partial^{2} w}{\partialx^{2}}+v \frac{\partial^{2} w}{\partial y^{2}}\right) \\\sigma_{y}=\frac{-E z}{1-v^{2}}\left(\frac{\partial^{2} w}{\partialy^{2}}+v \frac{\partial^{2} w}{\partial x^{2}}\right) \\\tau_{x y}=\frac{-E z}{1-v^{2}} \frac{\partial^{2} w}{\partial x\partial y}\end{array}\end{equation}\]</span></p><p>薄板的小挠度弯曲问题，将挠度<spanclass="math inline">\(w(x,y)\)</span>取为基本未知函数，所谓的弹性曲面微分方程可由内力与载荷平衡条件或微元的应力平衡条件得到，如下所示</p><p><span class="math display">\[\begin{equation}D\nabla^{2} \nabla^{2} w=q\end{equation}\]</span></p><p>其中<span class="math inline">\(D\)</span>称为薄板的弯曲刚度</p><p><span class="math display">\[\begin{equation}D=\frac{E \delta^{3}}{12\left(1-\mu^{2}\right)}\end{equation}\]</span></p><p>该方程已经考虑并完全满足了弹性力学空间问题的平衡微分方程、集合方程和物理方程，以及薄板上、下板面的应力边界条件，得到了求解挠度<spanclass="math inline">\(w\)</span>的基本微分方程。这样，在求解时，只需按照薄板侧面上的边界条件，求出挠度<spanclass="math inline">\(w\)</span>，从而求出应力分量。</p><h4 id="边界条件和挠度函数形式">1.3 边界条件和挠度函数形式</h4><p>进行薄板结构的模态分析时，关键在于薄板的边界条件。以下给出几种常见的边界条件</p><h5 id="固定边oax0">1.3.1 固定边OA(<spanclass="math inline">\(x=0\)</span>)</h5><p>显然有边界挠度和转角均为零的几何条件。因此，在<spanclass="math inline">\(x=0\)</span>边界，有</p><p><span class="math display">\[\begin{equation}\begin{array}{l}\left.w\right|_{x=0}=0 , \quad\left.\frac{\partial w}{\partial x}\right|_{x=0}=0\end{array}\end{equation}\]</span></p><h5 id="简支边oax0">1.3.2 简支边OA(<spanclass="math inline">\(x=0\)</span>)</h5><p>薄板在简支边界，不能有挠度，但是可以有微小的转动。因此边界条件为挠度为零和弯矩为零，属于混合边界条件。在<spanclass="math inline">\(x=0\)</span> 边界，有</p><p><span class="math display">\[\begin{equation}\begin{array}{l}\left.w\right|_{x=0}=0 , \quad\left.\frac{\partial^{2} w}{\partial x^{2}}\right|_{x=0}=0\end{array}\end{equation}\]</span></p><h5 id="自由边oaxa">1.3.3 自由边OA(<spanclass="math inline">\(x=a\)</span>)</h5><p>沿自由边OA，薄板的弯矩和扭矩以及横向剪力都等于零，因而有三个边界条件</p><p><span class="math display">\[\begin{equation}\begin{array}{l}\left.M_{x}\right|_{x=a}=0, \quad\left.M_{x y}\right|_{x=a}=0, \quad\left.F_{S x}\right|_{x=a}=0\end{array}\end{equation}\]</span></p><p>但是，薄板的挠曲微分方程式四阶的椭圆形偏微分方程，根据偏微分方程理论，在每个边界上，只需要两个边界条件。为此，基尔霍夫指出，薄板任一边界上的扭矩都可以变换为等效的横向剪力，和原来的剪力合并，因而后两个边界条件并不独立。自由边的边界条件用<spanclass="math inline">\(w\)</span>表示为</p><p><span class="math display">\[\begin{equation}\begin{array}{l}{\left[\frac{\partial^{2} w}{\partial x^{2}}+v \frac{\partial^{2}w}{\partial y^{2}}\right]_{x=a}=0}, \quad{\left[\frac{\partial^{3} w}{\partial x^{3}}+(2-v) \frac{\partial^{3}w}{\partial x \partial y^{2}}\right]_{x=a}=0}\end{array}\end{equation}\]</span></p><p>应该指出，如果相邻的两个边界都是自由边界，则扭矩用上述剪力等效替代时，在两个边界的角点将会出现没有抵消的集中剪力<spanclass="math inline">\(F_{SR}\)</span>，如果边界角点没有受到支承，则应该还有角点条件</p><p><span class="math display">\[\begin{equation}\left.\frac{\partial^{2} w}{\partial x \partial y}\right|_{x=a \atopy=b}=0\end{equation}\]</span></p><h5 id="振型函数的近似表示">1.3.4 振型函数的近似表示</h5><p>对于四边简支的矩形薄板，能够通过理论推导求出其精确解，然而实际中往往边界条件复杂。因此实际中利用近似法对薄板结构物体进行模态分析是较为方便的。能量法能够近似分析出薄板在不同边界条件下的模态。任意边界条件下的薄板的振型函数$w(x,y)$都可以利用分离变量法写成下式所示的形式[1]</p><p><span class="math display">\[\begin{equation}W(x, y)=\sum_{m=1}^{p} \sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\end{equation}\]</span></p><p>式中$ w(x,y)$表示薄板中Q点处的挠度， <span class="math inline">\(x ,y\)</span> 是归一化的坐标，<span class="math inline">\(p, q\)</span>分别代表了 <span class="math inline">\(x, y\)</span>方向上的多项式总数。 <span class="math inline">\(X_{m}(x),Y_{n}(y)\)</span>为满足不同边界条件的多项式。<spanclass="math inline">\(A_{mn}\)</span>表示这些多项式的权重参数。对于不同的边界条件<span class="math inline">\(X_{m}(x),Y_{n}(y)\)</span>的选择也不同。选取适当的多项式后，就可以求取该边界条件下薄板振动时的能量分布，从而求得各种边界条件下的振动模态。</p><h3 id="梁的弯曲振动">2. 梁的弯曲振动</h3><p>如图1所示是一弯曲振动的梁，假设梁的长度和截面高度之比大于10，因而满足材料力学中的欧拉伯努利梁的假设，即（1）变形前垂直梁中心线的平剖面，变形后仍然为平面（刚性横截面假定）；（2）变形后横截面的平面仍与变形后的轴线相垂直。其中忽略了梁的转动动能和剪切变形势能。</p><h4 id="梁的边界条件">2.1 梁的边界条件</h4><p><img src="/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png" alt="图2 梁的典型边界条件" style="auto;zoom:80%;" /></p><p>梁的典型边界条件有如下几种：</p><ol type="1"><li>固支端的边界条件是位移与转角为零 ，即</li></ol><p><span class="math display">\[\begin{equation}y(0, t)=0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.\frac{\partial y(x, t)}{\partial x}\right|_{x=0}=0\end{equation}\]</span></p><ol start="2" type="1"><li>简支端的边界条件是位移与弯矩为零，即</li></ol><p><span class="math display">\[\begin{equation}y(0, t)=0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}\right|_{x=0}=0\end{equation}\]</span></p><ol start="3" type="1"><li>自由端的边界条件是弯矩与剪力为零，即</li></ol><p><span class="math display">\[\begin{equation}\left.E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}\right|_{x=L}=0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\frac{\partial}{\partial x}\left[E I(x) \frac{\partial^{2} y(x,t)}{\partial x^{2}}\right]_{x=L}=0\end{equation}\]</span></p><ol start="4" type="1"><li>自由端带有弹簧<spanclass="math inline">\(k\)</span>的边界条件是位移与剪力存在如下关系，且弯矩为零，即</li></ol><p><span class="math display">\[\begin{equation}\frac{\partial}{\partial x}\left[E I(x) \frac{\partial^{2} y(x,t)}{\partial x^{2}}\right]_{x=L}=k y(L, t)\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}\right|_{x=L}=0\end{equation}\]</span></p><ol start="5" type="1"><li>简支端带有卷簧<spanclass="math inline">\(k\)</span>的边界条件是转角与弯矩之间存在如下关系，且位移为零，即</li></ol><p><span class="math display">\[\begin{equation}\left.E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}\right|_{x=L}=-k\frac{\partial y(x, t)}{\partial x}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}y(L)=0\end{equation}\]</span></p><ol start="6" type="1"><li>自由端带有集中质量<spanclass="math inline">\(M\)</span>的边界条件是剪力与加速度之间存在如下关系，且弯矩为零，即</li></ol><p><span class="math display">\[\begin{equation}\left.\frac{\partial}{\partial x}\left[E I(x) \frac{\partial^{2} y(x,t)}{\partial x^{2}}\right]\right|_{x=L}=M \frac{\partial^{2} y(x,t)}{\partial x^{2}}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}\right|_{x=L}=0\end{equation}\]</span></p><h4 id="梁的自由振动与模态">2.2 梁的自由振动与模态</h4><p>自由振动情况下<spanclass="math inline">\(f(x,t)=0\)</span>，考虑到梁的弯矩和弯矩变形之间的关系式</p><p><span class="math display">\[\begin{equation}E I(x) \frac{\partial^{2} y(x, t)}{\partial x^{2}}=M(x, t)\end{equation}\]</span></p><p>通过对梁微元分析并略去高阶小量，梁的自由振动的运动方程可以表示为：</p><p><span class="math display">\[\begin{equation}\frac{\partial^{2}}{\partial x^{2}}\left[E I(x) \frac{\partial^{2} y(x,t)}{\partial x^{2}}\right]+m(x) \frac{\partial^{2} y(x, t)}{\partialt^{2}}=0\end{equation}\]</span></p><p>设同步运动为</p><p><span class="math display">\[\begin{equation}y(x, t)=Y(x) \eta(t)\end{equation}\]</span></p><p>x带入上式并假定为均匀梁，可得</p><p><span class="math display">\[\begin{equation}\frac{\mathrm{d}^{4} Y(x)}{\mathrm{d} x^{4}}-\beta^{4} Y(x)=0\end{equation}\]</span></p><p>式中<span class="math inline">\(\beta^{4}=\frac{\omega^{2}m}{EI}\)</span>，方程的通解为</p><p><span class="math display">\[\begin{equation}Y(x)=C_{1} \sin \beta x+C_{2} \cos \beta x+C_{3} \operatorname{sh} \betax+C_{4} \operatorname{ch} \beta x\end{equation}\]</span></p><p>其中<spanclass="math inline">\(C_{i}\)</span>的值需要通过边界条件进一步确定。</p><h5 id="一端固支一端自由的梁悬臂梁的自然模态">2.2.1一端固支，一端自由的梁（悬臂梁）的自然模态</h5><p><img src="/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png" alt="图3 悬臂梁自然模态" style="zoom:80%;" /></p><p>悬臂梁的边界条件可以表示为</p><p><span class="math display">\[\begin{equation}Y(0)=0,\left.\quad \frac{\mathrm{d} Y(x)}{\mathrm{d} x}\right|_{=-0}=0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.\frac{\mathrm{d}^{2} Y(x)}{\mathrm{d} x^{2}}\right|_{x=L}=0,\left.\quad \frac{\mathrm{d}^{3} Y(x)}{\mathrm{d} x^{3}}\right|_{x=L}=0\end{equation}\]</span></p><p>可知式28中的系数满足如下关系</p><p><span class="math display">\[\begin{equation}\left\{{\begin{array}{l}C_{1}+C_{3}=0 \\C_{2}+C_{4}=0\end{array}}\right.\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{aligned}(\sin \beta L+\operatorname{sh} \beta L) C_{1}+(\cos \betaL+\operatorname{ch} \beta L) C_{2} &amp;=0 \\(\cos \beta L+\operatorname{ch} \beta L) C_{1}+(-\sin \betaL+\operatorname{sh} \beta L) C_{2} &amp;=0\end{aligned}\end{equation}\]</span></p><p>为得到上式的非零解，系数行列式必为零，即</p><p><span class="math display">\[\begin{equation}\left|\begin{array}{rr}\sin \beta L+\operatorname{sh} \beta L &amp; \cos \betaL+\operatorname{ch} \beta L \\\cos \beta L+\operatorname{ch} \beta L &amp; -\sin \betaL+\operatorname{sh} \beta L\end{array}\right|=0\end{equation}\]</span></p><p>展开上式化简得特征方程为</p><p><span class="math display">\[\begin{equation}\cos \beta L \operatorname{ch} \beta L=-1\end{equation}\]</span></p><p>可由数值方法求得一系列的<span class="math inline">\(\beta_rL\)</span>的值。</p><p>则特征函数<span class="math inline">\(Y(x)\)</span>可表示为</p><p><span class="math display">\[\begin{equation}Y_{r}(x)=C_{1}\left[\left(\sin \beta_{r} x-\operatorname{sh} \beta_{r}x\right)+\xi_{r}\left(\cos \beta_{r} x-\operatorname{ch} \beta_{r}x\right)\right],\quad r=1,2 ...\end{equation}\]</span></p><p>其中</p><p><span class="math display">\[\begin{equation}\xi_{r}=\left(\frac{C_{2}}{C_{1}}\right)_{r}=-\frac{\sin \beta_{r}L+\operatorname{sh} \beta_{r} L}{\cos \beta_{r} L+\operatorname{ch}\beta_{r} L}=\frac{\cos \beta_{r} L+\operatorname{ch} \beta_{r} L}{\sin\beta_{r} L-\operatorname{sh} \beta_{r} L}\end{equation}\]</span></p><p><spanclass="math inline">\(\beta_{r}\)</span>可由边界条件以数值方法得出，<spanclass="math inline">\(C_{1}\)</span>为待定常数，前三阶振型及相应的自然频率在图2中给出，在图中可以看到，<spanclass="math inline">\(Y_{r}(x)\)</span>有<spanclass="math inline">\(r-1\)</span>个节点。</p><h5 id="两端自由的梁的自然模态">2.2.2 两端自由的梁的自然模态</h5><p>此处需要注意的是，由于两端自由梁的约束不足，因此前两阶为刚体模态，分别为平动和转动。刚体模态跟刚体运动定义相似，结构内部不发生变形的模态振型即为刚体模态，即刚体运动对应刚体模态。该边界条件下前两节模态如下。</p><p><span class="math display">\[\begin{equation}{\begin{array}{l}Y_1(x) = C_{1,1}\\Y_2(x) = C_{1,2}(2x-L)\end{array}}\end{equation}\]</span></p><p>自由梁的边界条件可以表示为</p><p><span class="math display">\[\begin{equation}\left.\frac{\mathrm{d}^{2} Y(x)}{\mathrm{d} x^{2}}\right|_{x=0}=0,\left.\quad \frac{\mathrm{d}^{3} Y(x)}{\mathrm{d} x^{3}}\right|_{x=0}=0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\left.\frac{\mathrm{d}^{2} Y(x)}{\mathrm{d} x^{2}}\right|_{x=L}=0,\left.\quad \frac{\mathrm{d}^{3} Y(x)}{\mathrm{d} x^{3}}\right|_{x=L}=0\end{equation}\]</span></p><p>可知式28中的系数满足如下关系</p><p><span class="math display">\[\begin{equation}\left\{{\begin{array}{l}-C_{1}+C_{3}=0 \\-C_{2}+C_{4}=0\end{array}}\right.\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{aligned}(-\sin \beta L+\operatorname{sh} \beta L) C_{1}+(-\cos \betaL+\operatorname{ch} \beta L) C_{2} &amp;=0 \\(-\cos \beta L+\operatorname{ch} \beta L) C_{1}+(\sin \betaL+\operatorname{sh} \beta L) C_{2} &amp;=0\end{aligned}\end{equation}\]</span></p><p>为得到上式的非零解，系数行列式必为零，即</p><p><span class="math display">\[\begin{equation}\left|\begin{array}{rr}-\sin \beta L+\operatorname{sh} \beta L &amp; -\cos \betaL+\operatorname{ch} \beta L \\-\cos \beta L+\operatorname{ch} \beta L &amp; \sin \betaL+\operatorname{sh} \beta L\end{array}\right|=0\end{equation}\]</span></p><p>展开上式化简得特征方程为</p><p><span class="math display">\[\begin{equation}\cos \beta L \operatorname{ch} \beta L=1\end{equation}\]</span></p><p>可由数值方法求得一系列的<span class="math inline">\(\beta_rL\)</span>的值。</p><p>同上一小节一样，特征函数<spanclass="math inline">\(Y(x)\)</span>可表示为</p><p><span class="math display">\[\begin{equation}Y_{r}(x)=C_{1}\left[\left(\sin \beta_{r} x+\operatorname{sh} \beta_{r}x\right)+\xi_{r}\left(\cos \beta_{r} x+\operatorname{ch} \beta_{r}x\right)\right],\quad r=3,4 ...\end{equation}\]</span></p><p>其中</p><p><span class="math display">\[\begin{equation}\xi_{r}=\left(\frac{C_{2}}{C_{1}}\right)_{r}=\frac{\sin \beta_{r}L-\operatorname{sh} \beta_{r} L}{-\cos \beta_{r} L+\operatorname{ch}\beta_{r} L}=\frac{\cos \beta_{r} L-\operatorname{ch} \beta_{r} L}{\sin\beta_{r} L+\operatorname{sh} \beta_{r} L}\end{equation}\]</span></p><p><span class="math inline">\(C_{1}\)</span>为待定常数。</p><h5 id="gram-schmidt正交多项式方法">2.2.3Gram-Schmidt正交多项式方法</h5><p>另一种简单的方法是利用Gram-Schmidt正交多项式方法进行表征。在区间<spanclass="math inline">\([a,b]\)</span>上的正交多项式可以通过如下过程</p><p><span class="math display">\[\begin{equation}\phi_{1}(x)=\left(x-B_{1}\right) \phi_{0}(x), \quad\phi_{k}(x)=\left(x-B_{k}\right) \phi_{k-1}(x)-C_{k} \phi_{k-2}(x)\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{array}{c}B_{k}=\frac{(xg_{k},g_{k})}{(g_{k},g_{k})}\\C_{k}=\frac{(g_{k},g_{k})}{(g_{k-1},g_{k-1})}\end{array}\end{equation}\]</span></p><p>其中<span class="math inline">\(w(x)\)</span>是权重系数。</p><p>在本例中，权重选为1，区间为<spanclass="math inline">\([0,1]\)</span>，同时使之成为标准正交多项式，系数满足以下关系</p><p><span class="math display">\[\begin{equation}\int_{0}^{1} w(x) \phi_{j}(x) \phi_{k}(x) \mathrm{d}x=\left\{\begin{array}{ll}0 &amp; \text { if } j \neq k \\1 &amp; \text { if } j=k\end{array}\right\}\end{equation}\]</span></p><p>该正多项式序列的首项的选取需要满足伴随板问题的梁问题的边界条件。即使首项<spanclass="math inline">\(\phi_{0}(x)\)</span>满足所有的几何和力边界条件，其他的多项式一般也只满足几何边界条件，这一点可以通过构造过程得出。</p><p>满足边界条件的多项式首项<spanclass="math inline">\(\phi_{0}(x)\)</span>的构造方式如</p><h6 id="一边固定一边自由的梁"><strong>一边固定一边自由的梁</strong></h6><p>挠度函数假设如下</p><p><span class="math display">\[\begin{equation}Y(x)=a_{0}+a_{1} x+a_{2} x^{2}+a_{3} x^{3}+a_{4} x^{4}\end{equation}\]</span></p><p>且满足边界条件</p><p><span class="math display">\[\begin{equation}Y(0)=Y^{\prime \prime}(0)=Y^{\prime \prime}(1)=Y^{\prime \prime\prime}(1)=0\end{equation}\]</span></p><p>则挠曲形状为（略去任意常数）</p><p><span class="math display">\[\begin{equation}Y(x)=6 x^{2}-4 x^{3}+x^{4}\end{equation}\]</span></p><p>将该多项式标准化得</p><p><span class="math display">\[\begin{equation}\phi_{0}(x)=\left(6 x^{2}-4 x^{3}+x^{4}\right) /\left(\int_{0}^{1}Y^{2}(x) \mathrm{d} x\right)^{1 / 2}\end{equation}\]</span></p><h6 id="两端自由的梁"><strong>两端自由的梁</strong></h6><p>满足边界条件</p><p><span class="math display">\[\begin{equation}Y^{\prime \prime}(0)=Y^{\prime \prime \prime}(0)=Y^{\prime\prime}(1)=Y^{\prime \prime \prime}(1)=0\end{equation}\]</span></p><p>标准化后的前两项为</p><p><span class="math display">\[\begin{equation}\phi_{0}(x)=1\\\phi_{1}(x)=2 \sqrt{3}\left(x-\frac{1}{2}\right)\end{equation}\]</span></p><h6 id="reference">Reference</h6><p>[1] Bhat R B. Natural frequencies of rectangular plates usingcharacteristic orthogonal polynomials in Rayleigh-Ritz method[J].Journal of Sound and Vibration, 1985, 102(4): 493-499.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据融合</title>
    <link href="/2021/11/08/%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/"/>
    <url>/2021/11/08/%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回归模型</title>
    <link href="/2021/11/05/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/11/05/%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="回归模型">回归模型</h3><p>广义线性模型、混合效应模型、高斯过程回归</p><p>三种模型中，相对最有名的应是<strong>广义线性模型(GLM)。</strong>包括吴恩达的机器学习课程中也包含GLM。简单来说，广义线性模型是采用线性方法来解决非线性的相关，实际上是一种特殊的非线性模型。<strong>混合效应模型（MEM）</strong>在固定效应（如线性模型）的基础上加了一项“随机效应”。固定效应通常是传统的线性回归或者其它函数关系。随机效应则与所抽取的样本分布有关。因此随机效应具有先验分布，而固定效应没有。MEM拟合能力较强，相对模型也更容易解释，缺点是需要有大量的项，模型建立时需要自己指定每一项，故而相当繁琐。下面重点介绍一下<strong>高斯过程回归（GPR）</strong>。</p><h4 id="reference">Reference</h4><p>[1] <ahref="https://mp.weixin.qq.com/s?__biz=Mzg3NTAzOTYzOA==&amp;mid=2247483762&amp;idx=1&amp;sn=23d193866ce6ee128ce9485e90e952f3&amp;chksm=cec6df8bf9b1569d117c4042c81199310d6e652f1fcb0675aa367af7f3ddbdf946c1a7949900&amp;scene=21#wechat_redirect">功能强大的回归模型——高斯过程回归</a></p><p>[2] <ahref="https://zhuanlan.zhihu.com/p/101160180">高斯过程的最强实现工具--GPflowOR GPyTorch - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代理模型</title>
    <link href="/2021/11/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/11/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="代理模型简介">代理模型简介</h3><p>代理模型是复杂工程优化设计问题的关键技术之一。许多复杂问题的优化方法，如遗传算法、模拟退火算法、粒子群算法和蚁群算法等等。与传统的基于梯度的优化方法比，上述这些算法具有很好的鲁棒性、全局性和高度并行性等特点，在多峰值的非线性函数优化问题中得到了成功的应用。但是这些算法的最大缺点是收敛速度慢，需要对目标函数进行大量的评估，如果目标函数评估方法比较耗时(如工程优化中的CFD和FEM分析)，则计算量很大，严重制约了其在工程中的应用。为了克服全局优化算法的这个缺点，人们采用了一种称为代理模型(surrogatemodel)的方法来代替耗时的精确模型评估。代理模型的计算量比精确模型小得多，同时精度也可以得到保证，采用代理模型可以大大减少优化过程的计算量，提高工程优化设计的效率。常用的代理模型主要包括<strong>插值法</strong>、<strong>响应面模型</strong>、<strong>人工神经元网络模型</strong>、<strong>径向基函数模型</strong>及<strong>Kriging模型</strong>等。其中Kriging模型具有训练样本点处无偏估计、良好的高度非线性近似能力，非常适合作为代理模型使用。目前Kriging模型在工程优化设计领域得到了广泛应用。[1]</p><p>这其中，多项式响应面、多项式插值接近于回归拟合领域，比较简单。相对于分类支持向量机，支持向量机回归其应用较少，在此不做讨论。神经网络作为一套独立的体系，应该说其对原模型的近似程度最高，随着节点和隐含层的增多，实现模型的完美逼近。不过其运算速度也不会很快，且可解释性差，很多网络本身就是一个黑箱。克里金插值和径向基函数插值是目前应用较多的两种方法。</p><h4 id="插值法">1. 插值法</h4><p>利用函数f(x)在某区间中插入若干点的函数值，作出适当的特定函数，在这些点上取已知值，在区间的其他点上用这特定函数的值作为函数f(x)的近似值。</p><h4 id="响应面模型">2. 响应面模型</h4><p>也称作响应曲面设计方法(Response SurfaceMethodology，RSM)，是通过一系列多变量试验，通过多项式回归方程来模拟真实状态曲面的方法。一般情况下，二次回归方程可以给出较为满意的答案，即<span class="math display">\[\begin{equation}y=\beta_{0}+\sum_{i=1}^{m} \beta_{i} x_{i}+\sum_{i=1}^{m} \beta_{i i}x_{i} x_{i}+\sum \sum_{i&lt;j} \beta_{i j} x_{i} x_{j}+\varepsilon\end{equation}\]</span> 写成更紧凑的形式： <span class="math display">\[\begin{equation}y_{i}=\beta_{0}+\sum_{j=1}^{k} \beta_{j} x_{i j}+\varepsilon_{i} \quadi=1,2, \ldots, n\end{equation}\]</span> 多次观测后写成矩阵形式为： <span class="math display">\[\begin{equation}\mathbf{y}=\mathbf{X} \boldsymbol{\beta}+\boldsymbol{\varepsilon}\end{equation}\]</span> 其中 <span class="math display">\[\begin{equation}\begin{split}&amp; \mathbf{y}=\left[\begin{array}{c}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right], \mathbf{X}=\left[\begin{array}{ccccc}1 &amp; x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1 k} \\1 &amp; x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2 k} \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\1 &amp; x_{n 1} &amp; x_{n 2} &amp; \ldots &amp; x_{n k}\end{array}\right], \\&amp; \boldsymbol{\beta}=\left[\begin{array}{c}\beta_{0} \\\beta_{1} \\\vdots \\\beta_{k}\end{array}\right],\boldsymbol{\varepsilon}=\left[\begin{array}{c}\varepsilon_{0} \\\varepsilon_{1} \\\vdots \\\varepsilon_{k}\end{array}\right]\end{split}\end{equation}\]</span></p><p>观测误差方差为 <span class="math display">\[\mathbf{L}=\sum_{i=1}^{n}\varepsilon_{i}^{2}=\boldsymbol{\varepsilon}^{\prime}\boldsymbol{\varepsilon}=(\mathbf{y}-\mathbf{X}\boldsymbol{\beta})^{\prime}(\mathbf{y}-\mathbf{X} \boldsymbol{\beta})\]</span> 当方差最小时，显然拟合曲面和实际值最接近，此时 <spanclass="math display">\[\left.\frac{\partial \mathbf{L}}{\partial\boldsymbol{\beta}}\right|_{\hat{\beta}}=-2 \mathbf{X}^{\prime}\mathbf{y}+2 \mathbf{X}^{\prime} \mathbf{X} \hat{\boldsymbol{\beta}}=0\]</span></p><p>则</p><p><span class="math display">\[\hat{\boldsymbol{\beta}}=\left(\mathbf{X}^{\prime}\mathbf{X}\right)^{-1} \mathbf{X}^{\prime} \mathbf{y}\]</span></p><p>可得响应面为</p><p><span class="math display">\[\hat{\mathbf{y}}=\mathbf{X} \hat{\boldsymbol{\beta}}\]</span></p><h4 id="神经网络模型">3. 神经网络模型</h4><p>一种万能逼近模型。当代人工智能、深度学习的核心。</p><h4 id="径向基函数模型">4. 径向基函数模型</h4><p>1985年，Powell提出了多变量插值的径向基函数（RBF）方法。1988年Moody和Darken提出了一种神经网络结构，即RBF神经网络，属于前向神经网络类型，它能够以任意精度逼近任意连续函数，特别适合于解决分类问题。</p><p>RBF网络的结构与多层前向网络类似，它是一种三层前向网络。输入层由信号源结点组成，第二层为隐含层，隐单元数视所描述问题的需要而定，隐单元的变换函数是RBF，它是对中心点径向对称且衰减的非负非线性函数，第三层为输出层，它对输入模式的作用作出相应。从输入空间到隐含层空间的变换是非线性的，而从隐含层空间到输出层空间变换是线性的。</p><p>RBF网络的基本思想是：用RBF作为隐单元的“基”构成隐含层空间，这样就可以将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和，此处的权即为网络可调参数。从总体上看，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p><p><img src="/images/2021-11-03-代理模型/RBF.jpg" alt="RBF网络结构" style="zoom:70%;" /></p><h4 id="克里金模型">5. 克里金模型</h4><p>克里金（Kriging）模型实际上就是<strong>高斯随机过程模型</strong>，只是实现上稍有不同。</p><p>代理模型在<strong>优化过程</strong>中的使用方式非常重要，最常用的也是最简单的方式是以代理模型的预测值为目标函数对其寻优得到校正点，然后把校正点用精确模型评估并把结果用以更新代理模型，依此往复迭代直至收敛。这种选择校正点的方法极易使优化过程陷入局部极值点。Kriging模型与多项式响应面模型及人工神经网络模型最大的不同之处在于，Kriging模型不仅提供了1)未知点处的<strong>预测值</strong>，还提供了2)未知点处的<strong>预测标准差</strong>，可以方便地衡量预测的精度。针对简单地对代理模型预测值寻优确定校正点的方法所带来的局部收敛问题。Schonlau提出了以Kriging 模型为代理模型的 EGO(efficient global optimization)算法，该算法在 选取校正点时综合考虑了 Kriging 模型的预测值和 预测精度，避免了优化过程局部收敛的风险。</p><h5 id="克里金模型的基本理论">5.1 克里金模型的基本理论</h5><h6 id="形式一-6">形式一 [6]</h6><p><span class="math display">\[\left\{\begin{array}{l}\hat{y}_{1}(x)=\hat{\mu}+r^{T} C^{-1}(y-\mathbf{1} \hat{\mu}) \\s_{1}^{2}(x)=\hat{\sigma}\left[1-r^{T} C^{-1}r+\frac{\left(1-\mathbf{1}^{T} C^{-1} r\right)^{2}}{\mathbf{1}^{T}C^{-1} \mathbf{1}}\right]\end{array}\right.\]</span></p><p>其中 <span class="math display">\[\left\{\begin{array}{l}\hat{\mu}=\frac{\mathbf{1}^{T} C^{-1} y}{\mathbf{1}^{T} C^{-1}\mathbf{1}} \\\hat{\sigma}^{2}=\frac{(y-\mathbf{1} \hat{\mu})^{T} C^{-1}(y-\mathbf{1}\hat{\mu})}{n}\end{array}\right.\]</span>假设有n个数据点，1个预测点。r是数据点X和预测点x之间的协方差矩阵。C是数据点X之间的协方差矩阵。y是数据点的目标值。<strong>1</strong>是n*1的矩阵。</p><h6 id="形式二-7">形式二 [7]</h6><p><span class="math display">\[\left\{\begin{array}{l}\hat{y}_{2}(x)=f(x)^{T} \beta^{*}+r^{T}(x) \gamma^{*} \\s_{2}^{2}(x)=\sigma^{2}\left(1+u^{T}\left(F^{T} C^{-1} F\right)^{-1}u-r^{T} R^{-1} r\right)\end{array}\right.\]</span></p><p>其中 <span class="math display">\[\left\{\begin{array}{l}\beta^{*}=\left(F^{T} R^{-1} F\right)^{-1} F^{T} C^{-1} Y \\C \gamma^{*}=Y-F \beta^{*} \\u=F^{T} C^{-1} r-f(x) \\\sigma^{2}=\frac{1}{m}\left(Y-F \beta^{*}\right)^{T} C^{-1}\left(Y-F\beta^{*}\right)\end{array}\right.\]</span><strong>形式一是形式二在基函数为0次函数(即f(x)=1)时的特例</strong>。</p><p>对于形式一，给定数据集为<spanclass="math inline">\(\boldsymbol{X}=\{\boldsymbol{x}^{1},\boldsymbol{x}^{2}, \ldots,\boldsymbol{x}^{n}\}^{T}\)</span>​​​​​，对应的目标函数为<spanclass="math inline">\(\boldsymbol{y}=\{y^{1}, y^{2}, \ldots,y^{n}\}^{T}\)</span>​​​​​克里金法假设所有数据之间都服从n维的正态分布。所以目标函数<spanclass="math inline">\(\boldsymbol{y}\)</span>​​​​​​是一个随机过程，里面的每一个变量<spanclass="math inline">\(y_i\)</span>​​​都是一个随机变量。我们把这个随机过程记做：<span class="math display">\[\left(\begin{array}{c}Y\left(\boldsymbol{x}^{\mathbf{1}}\right) \\Y\left(\boldsymbol{x}^{\mathbf{1}}\right) \\\vdots \\Y\left(\boldsymbol{x}^{n}\right)\end{array}\right) \sim N(\boldsymbol{\mu}, C)\]</span> 我们把均值取为常数<spanclass="math inline">\(\boldsymbol{1}\)</span>​ 是n*1的矩阵。协方差取为<span class="math display">\[\begin{equation}\begin{aligned}&amp;\operatorname{cor}\left[Y\left(\boldsymbol{x}^{i}\right),Y\left(\boldsymbol{x}^{l}\right)\right]=\exp \left(-\sum_{j=1}^{k}\theta_{j}\left|x_{j}^{i}-x_{j}^{l}\right|^{2}\right) \\&amp;C=\left(\begin{array}{ccc}\operatorname{cor}\left(Y\left(\boldsymbol{x}^{\mathbf{1}}\right),Y\left(\boldsymbol{x}^{\mathbf{1}}\right)\right), &amp; \ldots, &amp;\operatorname{cor}\left(Y\left(\boldsymbol{x}^{\mathbf{1}}\right),Y\left(\boldsymbol{x}^{\mathbf{n}}\right)\right) \\\vdots &amp; \ddots, &amp; \vdots \\\operatorname{cor}\left(Y\left(\boldsymbol{x}^{n}\right),Y\left(\boldsymbol{x}^{\mathbf{1}}\right)\right), &amp; \ldots, &amp;\operatorname{cor}\left(Y\left(\boldsymbol{x}^{n}\right),Y\left(\boldsymbol{x}^{\mathbf{n}}\right)\right)\end{array}\right)\end{aligned}\end{equation}\]</span> 则Y的条件概率为 <span class="math display">\[\begin{equation}L\left(\boldsymbol{Y}^{1}, \boldsymbol{Y}^{2}, \ldots,\boldsymbol{Y}^{n} \mid \mu, \sigma\right)=\frac{1}{\left(2 \pi\sigma^{2}\right)^{n / 2}} \exp\left(-\frac{\Sigma\left(\boldsymbol{Y}^{i}-\boldsymbol{\mu}\right)^{2}}{2\sigma^{2}}\right)\end{equation}\]</span> 这个条件概率可以表示为 <span class="math display">\[\begin{equation}L=\frac{1}{\left(2 \pi \sigma^{2}\right)^{n / 2}|C|^{1 / 2}} \exp\left[-\frac{(\boldsymbol{y}-\mathbf{1} \mu)^{T}C^{-1}(\boldsymbol{y}-\mathbf{1} \mu)}{2 \sigma^{2}}\right]\end{equation}\]</span> 利用最大似然概率的方法可以得到先验参数<spanclass="math inline">\(\hat{\mu}，\hat{\sigma}，\theta_{i}\)</span>​​​​的值，最后通过代入已知和未知点，最大​化对数似然概率函数可得式(9.1)。证明过程详见参考文献[8]。</p><h5 id="改进的ego算法">5.2 改进的EGO算法</h5><p>选择代理模型预测值的最优点作为校正点的方法称为响应最优策略。如图所示，当最初的样本点分布不均匀时，Kriging模型的预测值在样本点稀疏的地方与真实函数值相差很大，如果以预测值的最优点作为校正点只是使校正后的Kriging模型在样本点集中的区域预测精度不断提高，在样本点稀疏区域预测精度却没有太多变化，如果真实函数的最优值在样本点稀疏区域，则采用最优策略选择校正点就使得优化过程陷入了局部极值点，可见为了避免采用响应最优策略确定校正点所带来的局部收敛问题，有必要在选择校正点时综合考虑Kriging模型的预测值与预测标准差。</p><p><img src="/images/2021-11-03-代理模型/Kriging模型.png" alt="Kriging模型拟合函数示意图" style="zoom: 20%;" /></p><p>Jones 和Schonlau提出的EGO算法是一种贝叶斯全局优化算法，针对式(10)表示的一般形式的优化问题，其基本流程为:</p><ol type="1"><li>在设计空间中，利用试验设计方法(DOE)生成初始样本库。</li><li>采用Kriging模型分别构建设计变量与目标函数、约束函数间的近似映射关系。</li><li>EI (expectedimprovement)函数的值为目标函数，选择使其最大的点作为校正点。</li><li>对校正点采用高精度初始模型评估得到校正点的响应值，把校正点及其响应值加入样本库中。</li><li>重复步骤(2),(3),(4)直至收敛。</li></ol><p>其中EI函数(加点准则)定义为: <span class="math display">\[\begin{equation}EI(\boldsymbol{x})=\left(y_{\min }-\mu_{\hat{y}}(\boldsymbol{x})\right)\Phi\left(\frac{y_{\min}-\mu_{\hat{y}}(\boldsymbol{x})}{s_{\hat{y}}(\boldsymbol{x})}\right)+s_{\hat{y}}(\boldsymbol{x})\phi\left(\frac{y_{\min}-\mu_{\hat{y}}(\boldsymbol{x})}{s_{\hat{y}}(\boldsymbol{x})}\right)\end{equation}\]</span> 其中$y_{} <spanclass="math inline">\(​​为当前试验点上的目标函数的最小值，\)</span><em>{}()<spanclass="math inline">\(​​和\)</span>s</em>{}<spanclass="math inline">\(​​分别是\)</span><spanclass="math inline">\(​​处的Kriging模型的预测值和标准差，\)</span>( )<spanclass="math inline">\(​​和\)</span>()$​​分别是标准正态分布的密度函数和分布函数。</p><p>EGO算法将EI准则的最大值点作为新增试验点，故EGO算法倾向于在Kriging模型预测值优（小）和预测不确定性大（预测标准差大）的地方添加新试验点，兼具了开发局部最优区域和探索潜在最优区域的功能。</p><p>EI加点准则巧妙利用了Kriging模型的预测不确定性度量能力，倾向于在Kriging模型预测值优和不确定性大的地方添加新试验点，保证了EGO算法的收敛效率和全局收敛性。此后的代理优化算法，大多沿袭了EGO算法的自适应优化思想，并致力于设计出合理的兼具局部开发和全局探索功能的加点准则。</p><h4 id="多精度代理模型">6. 多精度代理模型</h4><p>代理模型的预测精度取决于其训练集的精度，可以想象训练集的精度越高、数量越多，训练得到的代理模型精度也会越高。但是在实际应用过程中，如果要获取大量高精度训练集需要耗费过多的时间和计算资源，因此为了解决这一问题，我们可以考虑使用多精度代理模型（multi-fidelitysurrogatemodel）。多精度代理模型的出发点是希望能够用<strong>大量低精度</strong>的数据和<strong>少量高精度</strong>的数据构建高精度代理模型，这样就可以大大江都获取高精度代理模型的难度。</p><h4 id="reference">Reference</h4><p>[1]王红涛,竺晓程,杜朝辉.基于Kriging代理模型的改进EGO算法研究[J].工程设计学报,2009,16(04):266-270+302.</p><p>[2]张建侠.基于Kriging模型的全局代理优化算法研究[D].南京理工大学,2018.</p><p>[3]乐春宇,马义中,张建侠.结合Kriging和物理规划的多目标代理优化算法[J].计算机工程与应用,2019,55(21):240-246.</p><p>[4]乐春宇.基于Kriging模型的代理优化理论研究和应用[D].南京理工大学,2020.</p><p>[5] 偷天换日，斗转星移——代理优化算法https://zhuanlan.zhihu.com/p/99609634</p><p>[6] Zhan, D., et al. (2017). "Expected Improvement Matrix-BasedInfill Criteria for Expensive Multiobjective Optimization." IEEETransactions on Evolutionary Computation 21(6): 956-975.</p><p>[7] Sacks, Jerome, et al. "Design and analysis of computerexperiments."<em>Statistical science</em>(1989): 409-423.</p><p>[8] <ahref="https://zhuanlan.zhihu.com/p/377620800">克里金(Kriging)模型详细推导- 知乎 (zhihu.com)</a></p><p>[9] <ahref="https://link.jianshu.com?t=http%3A%2F%2Fwww.southampton.ac.uk%2F~aijf197%2F07PA0124.pdf">Multi-fidelityoptimization via surrogate modelling</a> by Alexander I. J. Forrester,Andras Sobester and Andy J. Keane</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微分方程</title>
    <link href="/2021/09/07/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <url>/2021/09/07/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="微分方程边界条件">微分方程边界条件</h3><p>以二阶常微分方程为例 <span class="math display">\[y^{\prime \prime}(s)=f\left(y(s), y^{\prime}(s), s\right)\]</span> 柯西边界条件（起始值条件） <span class="math display">\[y(a)=\alpha，y^{\prime}(a)=\beta\]</span> 狄利克雷边界条件（第一类边界条件） <spanclass="math display">\[y(a)=\alpha_{1}，y(b)=\alpha_{2}\]</span> 诺依曼边界条件（第二类边界条件） <span class="math display">\[y^{\prime}(a)=\alpha_{1},y^{\prime}(b)=\alpha_{2}\]</span></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小波散射网络</title>
    <link href="/2021/07/23/%E5%B0%8F%E6%B3%A2%E6%95%A3%E5%B0%84%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/07/23/%E5%B0%8F%E6%B3%A2%E6%95%A3%E5%B0%84%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="小波散射网络和小波神经网络">小波散射网络和小波神经网络</h3><h4 id="小波网络">1. 小波网络</h4><p>小波神经网络是一种改进的BP网络，区别是将原来隐藏层的激活函数替换为小波函数，该网络属于小波分析和神经网络“紧致型”结合的一种方式，按照文献[1]中的说法，由于小波变换的时频局部特性，使得该网络在信号处理方面具有自适应性、容错能力和较强的网络逼近能力。小波神经网络的结构</p><figure><img src="/images/2021-07-23-小波散射网络/小波神经网络的结构.png"alt="图1 小波神经网络的结构" /><figcaption aria-hidden="true">图1 小波神经网络的结构</figcaption></figure><p>小波网络模型可以表示为 <span class="math display">\[y_{i}(t)=\sum_{i=0}^{n} w_{i j} \psi_{a, b}\left(\sum_{k=0}^{m} w_{j k}x_{k}(t)\right)\]</span>本质上该网络的表示能力和BP网络并无区别，虽然在某些情况下可以获得更为优良的收敛速度和容错能力，但随着数据量提高，其预设的小波基会限制泛化性能。</p><p>讨论：</p><p>传统方法里，平移不变表示可以用配准算法或傅立叶变换模量来构造。为了避免傅立叶变换的不稳定性，建议用局部波形(如小波)代替正弦波。然而，小波变换对变化会有些敏感。从小波系数建立不变表示需要引入非线性算子，而卷积网络结构正好可以与之互补，有能力建立对变形反应稳定的大规模不变量。（PS:卷积网络的平移不变性仍然存疑[3]）。</p><h4 id="小波散射网络">2. 小波散射网络</h4><p>小波散射网络是由Mallat[2]等人提出的具有平移不变性的小波散射卷积神经网络，且对形变稳定，能保留高频信息进行分类。它将具有非线性模量和平均算子的小波反式卷积级联。第一网络层起到SIFT方法的效果，而下一层提供互补的不变信息，改进分类。小波散射网络的数学分析解释了深度卷积网络分类的重要性质。平稳过程的散射表示包含了高阶矩，因此可以区分具有相同傅立叶功率谱的纹理。</p><p>设旋转变量$ rG= { angles=2k/K|0≤k&lt;K }<spanclass="math inline">\(​，\)</span>j$​表示尺度且<spanclass="math inline">\(0≤j≤J\)</span>​，则二维方向小波函数为 <spanclass="math display">\[\psi_{\lambda}(u)=2^{-2 j} \psi\left(2^{-j} r^{-1}u\right),   \lambda=2^{-j} r\]</span> 其中如果小波基的傅里叶变换<spanclass="math inline">\(\hat{\psi}(\omega)\)</span>​的中心频率为<spanclass="math inline">\(\eta\)</span>​，则<spanclass="math inline">\(\hat{\psi}_{2^{-j}r}(\omega)=\hat{\psi}\left(2^{j} r^{-1}\omega\right)\)</span>​的中心为<spanclass="math inline">\(2^{-j}r\eta\)</span>​，带宽正比于<spanclass="math inline">\(2^{-j}\)</span>​。</p><p>设<span class="math inline">\(x\)</span>的小波系数为 <spanclass="math display">\[U[\lambda] x=\left|x * \psi_{\lambda}\right|\]</span> 则序列<spanclass="math inline">\(p=(\lambda_{1}，\lambda_{2}...\lambda_{m})\)</span>​​​定义了一个路径，沿此路径频率降低，传播算子为<span class="math display">\[\begin{aligned} U[p] x &amp;=U\left[\lambda_{m}\right] \cdotsU\left[\lambda_{2}\right] U\left[\lambda_{1}\right] x \\ &amp;=\left|\|x * \psi_{\lambda_{1}}\right| * \psi_{\lambda_{2}}|\cdots| *\psi_{\lambda_{m}} \end{aligned}\]</span> 由此可得加窗的小波散射系数的表达式： <spanclass="math display">\[S[p] x(u)=U[p] x * \phi_{2^{J}}(u)=\int U[p] x(v) \phi_{2^{J}}(u-v) d v\]</span> 对于每个路径<span class="math inline">\(p\)</span>，<spanclass="math inline">\(S[p] x(u)\)</span>取决于窗的位置<spanclass="math inline">\(u\)</span>。平均滤波器<spanclass="math inline">\(\phi_{2^{J}}(u)\)</span>使得当<spanclass="math inline">\(|c| \ll 2^{J}\)</span>时，<spanclass="math inline">\(x_{c}(u)=x(u-c)\)</span>​​​，因此加窗的小波散射系数是近似具有平移不变性的。</p><p>小波散射网络的迭代过程可以表示为如下所示</p><figure><imgsrc="/images/2021-07-23-小波散射网络/A%20scattering%20propagator.png"alt="图2 A scattering propagator" /><figcaption aria-hidden="true">图2 A scattering propagator</figcaption></figure><p>图3为两幅图像的傅里叶变换及其散射系数的幅值。平均尺度系数<spanclass="math inline">\(2^J\)</span>等于图像尺寸。上面和下面的图像是非常不同的，但它们有相同的一阶散射系数。二阶系数可以清楚地分辨出这些图像。由于图像小波系数更稀疏，顶部图像的二阶散射系数振幅较大。高阶系数没有显示出来，因为它们的能量可以忽略不计。</p><figure><img src="/images/2021-07-23-小波散射网络/Scattering%20coefficients.PNG"alt="图3 Scattering coefficients" /><figcaption aria-hidden="true">图3 Scattering coefficients</figcaption></figure><p><strong>参考文献</strong></p><p>[1] 左东广, 周帅, 张欣豫. 小波神经网络[J]. 四川兵工学报,2012(05):90-92+104.</p><p>[2] Bruna J, Mallat S. Invariant scattering convolution networks[J].IEEE transactions on pattern analysis and machine intelligence, 2013,35(8): 1872-1886.</p><p>[3] Azulay A, Weiss Y. Why do deep convolutional networks generalizeso poorly to small image transformations?[J]. arXiv preprintarXiv:1805.12177, 2018.</p>]]></content>
    
    
    <categories>
      
      <category>signal processing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信号处理|傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换、经验小波变换、变分模态分解</title>
    <link href="/2021/06/20/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E3%80%81%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E3%80%81%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E3%80%81%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E5%8F%98%E6%8D%A2%E3%80%81%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E9%BB%84%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/06/20/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E3%80%81%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E3%80%81%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E3%80%81%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E5%8F%98%E6%8D%A2%E3%80%81%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E9%BB%84%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>对于非平稳信号，其频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频域分析，包括短时傅里叶变换、小波变换、希尔伯特变换和希尔伯特黄变换，一下注意进行分析。</p><h3 id="傅里叶变换fourier-transform-ft">傅里叶变换(Fourier Transform,FT)</h3><p>简单介绍一下一个连续信号<spanclass="math inline">\(f(t)\)</span>的傅里叶变换和其逆变换 <spanclass="math display">\[\begin{array}{l}F(\omega)=F[f(t)]=\int_{-\infty}^{+\infty} f(t) e^{-j \omega t} d t \\f(t)=F^{-1}[F(\omega)]=\frac{1}{2 \pi} \int_{-\infty}^{+\infty}F(\omega) e^{j \omega t} d \omega\end{array}\]</span></p><p>当然在实际应用中，一般使用离散傅里叶变换 <spanclass="math display">\[X(k)=\sum_{n=0}^{N-1} x(n) e^{-j2\pi kn/N}\\x(n)=\frac{1}{N}\sum_{n=0}^{N-1} X(n) e^{j2\pi kn/N}\]</span>如果信号的频率特性在任何时间都不发生改变(即该信号是平稳信号)的话，使用傅里叶变换是没有问题的，然而如果该信号是非平稳信号，这时候时域信息就相当重要了。</p><h3id="短时傅里叶变换short-time-fourier-transform-stft">短时傅里叶变换(Short-TimeFourier Transform, STFT)</h3><p><span class="math display">\[X(n, \omega)=\sum_{m=-\infty}^{\infty} x(m) w(n-m) e^{-j \omega m}\]</span></p><p>其中<spanclass="math inline">\(w(n-m)\)</span>是窗函数，我们可以据此对信号进行时频分析。</p><h3 id="小波变换wavelet-transform-wt">小波变换(Wavelet Transform,WT)</h3><p>对于任意能量有限信号<spanclass="math inline">\(f(t)\)</span>，其连续小波变换(CWT)定义为 <spanclass="math display">\[W_{f}(a, b)=\frac{1}{\sqrt{a}} \int_{-\infty}^{+\infty} f(t)\psi^{*}\left(\frac{t-b}{a}\right) d t\]</span>在低频区域的变换结果具有较高的频率分辨率(频率轴是对数轴，在低频区域跨度较小)，在高频区域具有较高的时间分辨率。</p><h3 id="小结">小结</h3><ul><li>对于时域信号，它可以有很高的时间分辨率，然而其频率分辨率为零。</li><li>经过傅里叶变换得到的频域信号可以实现很高的频率分辨率，然而其时间分辨率为零。</li><li>对于短时傅里叶变换(STFT)，它在时域和频域都有一定的分辨率，并且在全局范围内STFT的时频分辨率都是一样的。但是由于Heisenberg不确定原理(也就是量子力学中的测不准原理)的制约，每一个时频窗的面积都是固定的，即时间分辨率和频率分辨率成反比，所以这两个分辨率不能同时很高。</li><li>小波变换在不同时间和频率上具有不同尺寸的时频窗，可以在低频区域实现较高的频率分辨率，然而其仍然受到Heisenberg不确定原理的限制，时间分辨率和频率分辨率不能两全其美。同时小波变换的时频窗并非完全是自适应的，它还需要人为地选择基函数。</li></ul><p>上述的方法都会受到Heisenberg不确定原理的限制，而且并不是完全自适应的方法。接下来介绍一种不受Heisenberg不确定原理限制、同时还有更好的自适应性的时频分析方法——希尔伯特黄变换</p><h3 id="希尔伯特变换hilbert-transform-ht">希尔伯特变换(HilbertTransform, HT)</h3><p>希尔伯特变换也是傅里叶变换的一种扩展，它常常用于通信系统中的调制解调，当然它也可以用于信号的时频分析。</p><p>单频率成分信号，即同一时刻只有一个频率分量的信号，我们可以由Hilbert谱很好地观察出信号的时频特征，且有很高的的时间分辨率，但是信号边界处的误差往往较大。</p><p>对多频率成分信号不能直接进行Hilbert变换，我们还需要对其进行进一步处理，将原始信号分解成单频率信号的叠加，这就要用到希尔伯特黄变换中的EMD分解。</p><h3id="希尔伯特黄变换hilbert-huang-transform-hht">希尔伯特黄变换(Hilbert-HuangTransform, HHT)</h3><p>相比于HT，HHT就多了一个经验模态分解(Empirical Mode Decomposition,EMD)，EMD就是把复杂信号分解成从高频到低频的若干个固有模态函数(IntrinsicMode Function, IMF)，IMF需要满足两个条件：</p><ol type="1"><li>信号极值点的数量与零点数相等或相差为1</li><li>信号的由极大值定义的上包络和由极小值定义的下包络的局部均值为0(即包络上下对称)</li></ol><p>简单的理解就是，EMD是依次提取信号在每个局部的最高频分量的过程，所以每个IMF实际上是一个单频率分量信号，这样我们就可以对每个IMF分量进行Hilbert变换，从而得到每个分量的Hilbert谱。</p><p>当然HHT并不是完美的，目前对于它的关键步骤EMD分解的研究尚不完善，缺乏一些理论基础。HHT在低频区域可能会出现一些不存在的频率分量。</p><h3 id="经验小波变换ewt">经验小波变换(EWT)</h3><p>经验小波变换（EWT）是一种新的自适应信号分解方法,该方法继承了EMD和小波分析方法的各自优点,通过提取频域极大值点自适应地分割傅里叶频谱以分离不同的模态,然后在频域自适应地构造带通滤波器组从而构造正交小波函数,以提取具有紧支撑傅立叶频谱的调幅-调频（AM-FM）成分。</p><p>推荐论文：<ahref="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2015&amp;filename=YQXB201411003&amp;v=BAME6dADRg3hOUnynmQVUKsxm%25mmd2FjYPYGBRfazqTaU5nsKX1iiwwW3TcNUdsL%25mmd2F2hgO">基于经验小波变换的机械故障诊断方法研究</a></p><h3 id="变分模态分解vmd">变分模态分解(VMD)</h3><p>VMD（Variational modedecomposition）是一种自适应、完全非递归的模态变分和信号处理的方法。该技术具有可以确定模态分解个数的优点，其自适应性表现在根据实际情况确定所给序列的模态分解个数，随后的搜索和求解过程中可以自适应地匹配每种模态的最佳中心频率和有限带宽，并且可以实现固有模态分量（IMF）的有效分离、信号的频域划分、进而得到给定信号的有效分解成分，最终获得变分问题的最优解。它克服了EMD方法存在端点效应和模态分量混叠的问题。</p><p>VMD的核心思想是构建和求解变分问题实现IMF的有效分离。</p><p>推荐论文：<ahref="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2019&amp;filename=JGHW201811024&amp;v=UsZgNaRI7%25mmd2BXIcXhf68qkQ0zRFSa2mGSVb5rb%25mmd2FL48hZ9plvZdpsKV6H3NsWeyu3YT">基于VMD的激光雷达回波信号去噪方法研究</a></p><h3 id="二维傅里叶变换2d-ft">二维傅里叶变换(2D-FT)</h3><p><strong>定义</strong></p><p>一维信号是一个序列，FT将其分解成若干个一维的简单函数之和。而二维FT将一个图像分解成若干个复平面波<spanclass="math inline">\(e^{j 2 \pi(u x+vy)}\)</span>之和。<strong>二维FT的公式</strong>如下： <spanclass="math display">\[F(u, v)=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} f(x, y) e^{-j2 \pi(u x+v y)} d x d y\]</span>通过公式，我们可以计算出，每个平面波在图像中成分是多少。从公式也可以看到，二维傅里叶变换就是将图像与每个不同频率的不同方向的复平面波做内积（先点乘在求和），也就是一个求在<strong>基</strong><spanclass="math inline">\(e^{-j 2 \pi(u x+vy)}\)</span>上的<strong>投影</strong>的过程。</p><figure><img src="/images/QQ截图20210722190017.png" alt="通过傅里叶变换分解" /><figcaption aria-hidden="true">通过傅里叶变换分解</figcaption></figure><p><strong>二维频率域K-SPACE</strong></p><p>对于正弦平面波，可以这样理解，在一个方向上存在一个正弦函数，在法线方向上将其拉伸。前面说过三个参数可以确定一个一维的正弦波。哪几个参数可以确定一个二维的正弦平面波呢？答案是四个，其中三个和一维的情况一样（频率<spanclass="math inline">\(\omega\)</span> ,幅度<spanclass="math inline">\(A\)</span>，相位<spanclass="math inline">\(\varphi\)</span>），但是具有相同这些参数的平面波却可以有不同的方向<spanclass="math inline">\(\vec{n}\)</span> 。</p><p>类比一维中，幅度和相位可以用一个复数表示，它可以作为我们存储的内容。但是还有两个：一个频率一个方向。这时想到向量是有方向的，也是有长度的。所以我们用一个二维的矩阵的来保存分解之后得到的信息。这个矩阵就是K空间。（一般用k来表示空间频率，单位是1/m）</p><p>就是说一个二维矩阵点 <spanclass="math inline">\((u,v)\)</span>代表这个平面波的法向量<spanclass="math inline">\(\vec{n}\)</span>，这个向量的模<spanclass="math inline">\(\sqrt{u^{2}+v^{2}}\)</span>代表这个平面波的频率<spanclass="math inline">\(\omega\)</span>，这个点里面保存的内容复数就是此平面波的幅度和相位。下面这个图很好的体现了这一点：</p><figure><img src="/images/2d-fft.jpg" alt="二维傅里叶变换的K空间" /><figcaption aria-hidden="true">二维傅里叶变换的K空间</figcaption></figure><p>也因此K空间的中心对于低频，周围对于高频。再如下面这个图片，<strong>中心低频贡献了图像的主体，周围高频提供图像的细节和边缘。</strong></p><figure><img src="/images/QQ截图20210722185927.png" alt="低通滤波和高通滤波" /><figcaption aria-hidden="true">低通滤波和高通滤波</figcaption></figure><p>因此，k空间的每一个位置存储的数代表了所在位置复平面波在图像中占多少成分，我们就可以用每个系数所代表的平面波相加得到原来的图像。所以<strong>k空间和对应图像储存的信息含量是一样的</strong>，只不过表现形式不同，或者说基不同。</p><p><strong>K空间的一些性质</strong></p><p>频率混叠。在数字图像中，数据都是离散的。也就涉及到采样的问题，和一维一样，如果采样率过低，k空间就会混叠。同时在k空间中采样过低，图像也会混叠。<strong>FOV和分辨率在k空间和图像中是相反的关系</strong><span class="math display">\[\Delta x=\frac{1}{2 * k_{x m a x}}, \Delta k=\frac{1}{2 * x_{x m ax}}=\frac{1}{F O V}\]</span>旋转不变性。从平面波的角度很容易理解，旋转没有改变平面波的幅度相位，只是将所有的平面波都旋转了一个角度。下面这个图像显示了二维傅里叶变换中，实空间旋转多少，频率空间也会相应旋转多少。这其实是<strong>高维傅里叶变换缩放定理的一种特殊情况。</strong></p><p><strong>PS</strong></p><ul><li><p>1.因为matlab中的fft算法都是将0放在第一个的，所有写matlab时一定要将k空间fftshift一下使得零频回到k空间中心。</p></li><li><p>2.简单的应用k空间进行去噪例子。通过去掉明显的k空间的异常峰，可以去除图像中有规律变化的噪声或者伪影。</p></li></ul><p><img src="/images/QQ截图20210722185958.png" alt="应用k空间进行降噪" style="zoom:80%;" /></p><p><strong>Reference</strong></p><p>https://zhuanlan.zhihu.com/p/150705777</p><p>https://www.zhihu.com/question/22611929</p><p>https://zhuanlan.zhihu.com/p/110026009</p><p>https://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf</p>]]></content>
    
    
    <categories>
      
      <category>signal processing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FFT</tag>
      
      <tag>STFT</tag>
      
      <tag>WT</tag>
      
      <tag>HT</tag>
      
      <tag>HHT</tag>
      
      <tag>signal processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keras中LN层的使用</title>
    <link href="/2021/06/09/keras%E4%B8%ADLN%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/06/09/keras%E4%B8%ADLN%E5%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="bn的问题">1、BN的问题</h3><p>BN是按照样本数计算归一化统计量的，当样本数很少时，比如说只有4个。这四个样本的均值和方差便不能反映全局的统计分布息，所以基于少量样本的BN的效果会变得很差。</p><h3 id="ln层的使用">2、LN层的使用</h3><p><img src="/images/BN_and_LN.png" style="zoom:80%;" /></p><p>这张图与我们平常看到的featuremaps有些不同，立方体的3个维度为别为batch/ channel/HW，而我们常见的feature maps中，3个维度分别为channel/ H/W，没有batch。分析上图可知：BN计算均值和标准差时，固定channel(在一个channel内)，对HW和batch作平均；LN计算均值和标准差时，固定batch(在一个batch内)，对HW和channel作平均，更详细的推导过程可以查阅参考文献。</p><p>可以看到与BN不同，LN没有对batch作平均，所以当batch变化时，网络的错误率不会有明显变化。论文的实验显示：LN和IN在时间序列模型(RNN/LSTM)和生成模型(GAN)上有很好的效果，而GN在视觉模型(CNN)上表现更好。</p><p>LN与BN层非常相似，特点主要体现在两个方面：</p><ol type="1"><li>LN得到的模型更稳定；</li><li>LN有正则化的作用，得到的模型更不容易过拟合。</li></ol><p>关于Layer normalization， Keras官方API连接如下</p><p>https://keras.io/api/layers/normalization_layers/layer_normalization/</p><p>但是请注意，这个函数在Keras中可能无法正常使用，但可以通过pip正确安装</p><p><strong>Install</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install keras-layer-normalization<br></code></pre></td></tr></table></figure><p><strong>Usage</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">from</span> keras_layer_normalization <span class="hljs-keyword">import</span> LayerNormalization<br><br><br>input_layer = keras.layers.Input(shape=(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>norm_layer = LayerNormalization()(input_layer)<br>model = keras.models.Model(inputs=input_layer, outputs=norm_layer)<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;mse&#x27;</span>, metrics=&#123;&#125;,)<br>model.summary()<br></code></pre></td></tr></table></figure><p><strong>Reference</strong></p><ul><li><a href="https://arxiv.org/pdf/1607.06450.pdf">Lei Ba et al.,2016</a>.</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Keras</tag>
      
      <tag>LN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python中的lambda和map函数</title>
    <link href="/2021/05/14/python%E4%B8%AD%E7%9A%84lambda%E5%92%8Cmap%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/14/python%E4%B8%AD%E7%9A%84lambda%E5%92%8Cmap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="lambda函数">1、lambda函数</h3><p>他就是个没有名字的函数，比如匿名信这种。我们能在某一函数参数条件中直接调用他、或者借用其返回的实体构成新的函数名如下。</p><p>比如说 lambda x,y: x+y 就是说我的函数输入x,y，返回x+y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y=<span class="hljs-keyword">lambda</span> a,b,c:a+b+c<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>,y(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>结果为6</p><p>仔细看看，是不是y成为了新的函数名？！</p><h3 id="map函数">2、map函数</h3><p>map就是映射的意思，他肯定是将两种东西结合映射为某一个结果。他就是接收一个函数function和一个list列表，并通过把函数f依次作用在list的每一个元素，从而得到一个新的list返回（py3中返回一个map对象，用list函数转换一下即可）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recur</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib_recur(n-<span class="hljs-number">1</span>)+fib_recur(n-<span class="hljs-number">2</span>)<br><br><br>X=<span class="hljs-built_in">input</span>().strip().split()<br>N=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, X))[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>    <span class="hljs-built_in">print</span>(fib_recur(i),end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意哈这个X必须是列表，int则表示函数了，当然也可以其他函数命名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recur</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib_recur(n-<span class="hljs-number">1</span>)+fib_recur(n-<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ex</span>(<span class="hljs-params">c</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(c)<br>        <br>X=<span class="hljs-built_in">input</span>().strip().split()<br>N=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(ex, X))[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>    <span class="hljs-built_in">print</span>(fib_recur(i),end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意他是自动迭代地对X列表的每一个元素操作，也就是说map自带迭代器！</p><h3 id="map函数和lambda函数结合">3、map函数和lambda函数结合</h3><p>显然只用改变map函数中的函数体就可以，无非就是函数体没有了实名，将lambda放于map的参数条件之中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recur</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib_recur(n-<span class="hljs-number">1</span>)+fib_recur(n-<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ex</span>(<span class="hljs-params">c</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(c)<br>        <br><span class="hljs-comment">##X=input().strip().split()</span><br><span class="hljs-comment">##N=list(map(ex, X))[0]</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##for i in range(1, N):</span><br><span class="hljs-comment">##print(fib_recur(i),end=&#x27; &#x27;)</span><br><br>X=<span class="hljs-built_in">input</span>().strip().split()<br>N=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> a:<span class="hljs-built_in">int</span>(a), X))[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>    <span class="hljs-built_in">print</span>(fib_recur(i),end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p>在本代码list(map(lambda a:int(a), X)) 这一句只用注意两个点：</p><p>1）lambda参数只能是一个参数标量，因为map是自动对列表X的元素迭代的</p><p>2）X为一维情况，所以他的每一个元素是标量</p><p>针对X为二维情况，博主暂时没想到好的解决办法，只能是X[2]来选择其中的一个向量列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recur</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;=<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib_recur(n-<span class="hljs-number">1</span>)+fib_recur(n-<span class="hljs-number">2</span>)<br><br><br>X=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]]<br>N=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> a:<span class="hljs-built_in">int</span>(a), X[<span class="hljs-number">2</span>]))[<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>    <span class="hljs-built_in">print</span>(fib_recur(i),end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p>————————————————版权声明：本文为CSDN博主「lamusique」的原创文章，遵循CC 4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/lamusique/article/details/89162363</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>lambda</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab作图：设置曲面颜色及范围函数 caxis</title>
    <link href="/2021/04/06/Matlab%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2%E5%9B%BE%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/04/06/Matlab%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2%E5%9B%BE%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="语法">语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">caxis</span><span class="hljs-params">(limits)</span></span><br><span class="hljs-function"><span class="hljs-title">caxis</span><span class="hljs-params">(<span class="hljs-string">&#x27;auto&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">caxis</span><span class="hljs-params">(<span class="hljs-string">&#x27;manual&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">caxis</span><span class="hljs-params">(target,___)</span></span><br>cl = caxis<br></code></pre></td></tr></table></figure><h3 id="说明">说明</h3><p><code>caxis(limits)</code>设置当前坐标区的颜色图范围。<code>limits</code> 是<code>[cmin cmax]</code> 形式的二元素向量。<ahref="https://ww2.mathworks.cn/help/matlab/ref/caxis.html#mw_262386a0-0173-40a5-b123-7b5834c1d396">颜色图索引数组</a>中小于或等于<code>cmin</code> 的所有值映射到颜色图的第一行。大于或等于<code>cmax</code> 的所有值映射到颜色图的最后一行。介于 <code>cmin</code>和 <code>cmax</code> 之间的所有值以线性方式映射到颜色图的中间各行。</p><p><strong>注意</strong></p><p><code>caxis</code> 函数只影响 <code>CDataMapping</code> 属性设置为<code>'scaled'</code> 的图形对象，不影响使用真彩色或<code>CDataMapping</code> 设置为 <code>'direct'</code> 的图形对象。</p><p><code>caxis('auto')</code>在颜色图索引数组中的值更改时启用自动范围更新。这是默认行为。<code>caxis auto</code>命令是此语法的另一种形式。</p><p><code>caxis('manual')</code>禁用自动范围更新。<code>caxis manual</code>命令是此语法的另一种形式。</p><p><code>caxis(target,___)</code> 为特定坐标区或图设置颜色图范围。指定<code>target</code> 作为上述任何语法中的第一个输入参数。</p><p><code>cl = caxis</code> 返回当前坐标区或图的当前颜色图范围。</p><h3 id="示例">示例</h3><h4 id="提高下限">提高下限</h4><p>绘制带有颜色栏的抛物面。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp">[<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>] = meshgrid(<span class="hljs-number">-5</span>:<span class="hljs-number">.5</span>:<span class="hljs-number">5</span>);<br><span class="hljs-keyword">Z</span> = <span class="hljs-keyword">X</span>.^<span class="hljs-number">2</span> + <span class="hljs-keyword">Y</span>.^<span class="hljs-number">2</span>;<br>surf(<span class="hljs-keyword">Z</span>);<br>colorbar<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>获取当前颜色范围。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">lim</span> <span class="hljs-operator">=</span> caxis<br><span class="hljs-attribute">lim</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>×<span class="hljs-number">2</span><br><br>     <span class="hljs-number">0</span>    <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>将下限提高到 <code>20</code>。请注意，小于或等于 <code>20</code>的所有 <code>Z</code> 值映射到第一种颜色。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">caxis</span><span class="hljs-params">([<span class="hljs-number">20</span> <span class="hljs-number">50</span>])</span></span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_02_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="保持多个曲面图的颜色范围不变">保持多个曲面图的颜色范围不变</h4><p>创建两个垂直偏移的抛物面。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">[<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>] = meshgrid(<span class="hljs-number">-5</span>:<span class="hljs-number">.5</span>:<span class="hljs-number">5</span>);<br><span class="hljs-keyword">Z</span><span class="hljs-number">1</span> = <span class="hljs-keyword">X</span>.^<span class="hljs-number">2</span> + <span class="hljs-keyword">Y</span>.^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">Z</span><span class="hljs-number">2</span> = <span class="hljs-keyword">Z</span><span class="hljs-number">1</span> + <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>绘制第一个抛物面。添加颜色栏，然后保持第二个抛物面的坐标区不变。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">surf(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span><span class="hljs-number">1</span>);<br>colorbar<br>hold on<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>使用 <code>'manual'</code>选项保持当前颜色范围不变。然后绘制第二个抛物面。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">caxis</span>(&#x27;manual&#x27;);<br><span class="hljs-built_in">surf</span>(X,Y,Z2);<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_02_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="指定曲面图的颜色图颜色">指定曲面图的颜色图颜色</h4><p>通过包含第四个矩阵输入 <code>C</code> 来指定曲面图的颜色。曲面图使用<code>Z</code> 表示高度，<code>C</code>表示颜色。使用<em>颜色图</em>指定颜色，该颜色图使用单个数字表示色谱上的颜色。使用颜色图时，<code>C</code>与 <code>Z</code> 大小相同。向图中添加颜色栏以显示 <code>C</code>中的数据值如何对应于颜色图中的颜色。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">[<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>] = meshgrid(<span class="hljs-number">1</span>:<span class="hljs-number">0</span><span class="hljs-number">.5</span>:<span class="hljs-number">10</span>,<span class="hljs-number">1</span>:<span class="hljs-number">20</span>);<br><span class="hljs-keyword">Z</span> = sin(<span class="hljs-keyword">X</span>) + cos(<span class="hljs-keyword">Y</span>);<br>C = <span class="hljs-keyword">X</span>.*<span class="hljs-keyword">Y</span>;<br>surf(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span>,C)<br>colorbar<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/specifycolorsforsurfaceplotexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="为曲面图指定真彩色">为曲面图指定真彩色</h4><p>通过包含第四个矩阵输入 <code>CO</code> 来指定曲面图的颜色。曲面图使用<code>Z</code> 表示高度，<code>CO</code>表示颜色。使用<em>真彩色</em>指定颜色，真彩色使用三个数字（即三元组）表示所有可能的颜色。使用真彩色时，如果<code>Z</code> 为 <code>m</code>×<code>n</code>，则 <code>CO</code> 为<code>m</code>×<code>n</code>×3。数组的第一页指示每种颜色的红色分量；第二页指示绿色分量；第三页指示蓝色分量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[X,Y,Z] = peaks(<span class="hljs-number">25</span>);<br>CO(:,:,<span class="hljs-number">1</span>) = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">25</span>); <span class="hljs-comment">% red</span><br>CO(:,:,<span class="hljs-number">2</span>) = <span class="hljs-built_in">ones</span>(<span class="hljs-number">25</span>).*<span class="hljs-built_in">linspace</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">25</span>); <span class="hljs-comment">% green</span><br>CO(:,:,<span class="hljs-number">3</span>) = <span class="hljs-built_in">ones</span>(<span class="hljs-number">25</span>).*<span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>); <span class="hljs-comment">% blue</span><br>surf(X,Y,Z,CO)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/surfaceplotwithtruecolorsexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="修改曲面图的外观">修改曲面图的外观</h4><p>通过指定以 <code>0.5</code> 为值的 <code>FaceAlpha</code>名称-值对组，来创建半透明曲面。要允许进一步修改，请将曲面对象赋给变量<code>s</code>。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">[<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>] = meshgrid(<span class="hljs-number">-5</span>:<span class="hljs-number">.5</span>:<span class="hljs-number">5</span>);<br><span class="hljs-keyword">Z</span> = <span class="hljs-keyword">Y</span>.*sin(<span class="hljs-keyword">X</span>) - <span class="hljs-keyword">X</span>.*cos(<span class="hljs-keyword">Y</span>);<br>s = surf(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span>,<span class="hljs-string">&#x27;FaceAlpha&#x27;</span>,<span class="hljs-number">0</span><span class="hljs-number">.5</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">s = </span><br><span class="hljs-attribute">  Surface with properties</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>       <span class="hljs-attribute">EdgeColor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[0 0 0]</span><br>       <span class="hljs-attribute">LineStyle</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;-&#x27;</span><br>       <span class="hljs-attribute">FaceColor</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;flat&#x27;</span><br>    <span class="hljs-attribute">FaceLighting</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;flat&#x27;</span><br>       <span class="hljs-attribute">FaceAlpha</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0.5000</span><br>           <span class="hljs-attribute">XData</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[21x21 double]</span><br>           <span class="hljs-attribute">YData</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[21x21 double]</span><br>           <span class="hljs-attribute">ZData</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[21x21 double]</span><br>           <span class="hljs-attribute">CData</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[21x21 double]</span><br><br>  Show all properties<br></code></pre></td></tr></table></figure><p>在创建曲面对象之后可使用 <code>s</code>访问并修改其属性。例如，通过设置 <code>EdgeColor</code>属性来隐藏边。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s.EdgeColor</span> = <span class="hljs-string">&#x27;none&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_02_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>surf</tag>
      
      <tag>color</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab作图：更改图像、填充或曲面的透明度</title>
    <link href="/2021/04/06/Matlab%E9%A2%9C%E8%89%B2%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/04/06/Matlab%E9%A2%9C%E8%89%B2%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="坐标区框中所有对象的透明度">1、坐标区框中所有对象的透明度</h3><p>透明度值称为 alpha 值。使用 <code>alpha</code>函数设置当前坐标区范围内所有图像、填充或曲面对象的透明度。指定一个介于0（完全透明）和 1（完全不透明）之间的透明度值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t = <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>;<br>x = <span class="hljs-built_in">sin</span>(t);<br>y = <span class="hljs-built_in">cos</span>(t);<br><br><span class="hljs-built_in">figure</span><br>patch(x,y,<span class="hljs-string">&#x27;r&#x27;</span>)            <span class="hljs-comment">% make a red circular patch</span><br>patch(x+<span class="hljs-number">0.8</span>,y,<span class="hljs-string">&#x27;g&#x27;</span>)        <span class="hljs-comment">% make a green circular path</span><br>patch(x+<span class="hljs-number">0.4</span>,y+<span class="hljs-number">0.8</span>,<span class="hljs-string">&#x27;b&#x27;</span>)    <span class="hljs-comment">% make a blue circular path</span><br>axis square tight         <span class="hljs-comment">% set axis to square</span><br><br>alpha(<span class="hljs-number">0.3</span>)                <span class="hljs-comment">% set all patches transparency to 0.3</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_01_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="个别曲面的透明度">2、个别曲面的透明度</h3><p>曲面的透明度由其 <code>AlphaData</code> 属性定义。将 alpha数据设置为用于指定曲面的每个顶点透明度的标量值或值矩阵。<code>FaceAlpha</code>属性指示如何从顶点透明度确定曲面透明度。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">[<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span>] = peaks(<span class="hljs-number">20</span>);<br>s<span class="hljs-number">2</span> = surf(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span>);<br><br>s<span class="hljs-number">2</span>.AlphaData = gradient(<span class="hljs-keyword">Z</span>);    % set vertex transparencies<br>s<span class="hljs-number">2</span>.FaceAlpha = <span class="hljs-string">&#x27;flat&#x27;</span>;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_02_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="个别图像的透明度">3、个别图像的透明度</h3><p>与曲面一样，图像的透明度也由其 <code>AlphaData</code>属性定义。对于图像，将 alpha数据设置为用于指定图像数据的每个元素透明度的标量值或值矩阵。</p><p>例如，使用透明度覆盖两个图像。首先，显示地球的图像。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">earth = imread(&#x27;landOcean.jpg&#x27;);<br><span class="hljs-built_in">image</span>(earth)    <span class="hljs-symbol">%</span> <span class="hljs-built_in">display</span> Earth <span class="hljs-built_in">image</span><br>axis <span class="hljs-built_in">image</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_03_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后，使用透明度将云图层添加到地球图像。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">clouds = imread(<span class="hljs-string">&#x27;cloudCombined.jpg&#x27;</span>);<br><span class="hljs-built_in">image</span>(earth)<br>axis <span class="hljs-built_in">image</span><br>hold on<br><br>im = <span class="hljs-built_in">image</span>(clouds);<br>im.AlphaData = <span class="hljs-built_in">max</span>(clouds,[],<span class="hljs-number">3</span>);    % <span class="hljs-built_in">set</span> transparency <span class="hljs-keyword">to</span> maximum cloud value<br>hold off<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_04_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="个别填充的透明度">4、个别填充的透明度</h3><p>填充的透明度由其 <code>FaceAlpha</code> 和<code>FaceVertexAlphaData</code>属性定义。若要在整个填充上实现单一的透明度，请将<code>FaceVertexAlphaData</code> 设置为一个介于 0（完全透明）和1（完全不透明）之间的常量，并将 <code>FaceAlpha</code> 属性设置为<code>'flat'</code>。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">cla<br>p1 = patch(x,y,<span class="hljs-string">&#x27;r&#x27;</span>);             <span class="hljs-comment">% make a red circular patch</span><br>axis square tight                <span class="hljs-comment">% set axis to square</span><br><br>p1.FaceVertexAlphaData = <span class="hljs-number">0.2</span>;    <span class="hljs-comment">% Set constant transparency </span><br>p1.FaceAlpha = <span class="hljs-string">&#x27;flat&#x27;</span> ;          <span class="hljs-comment">% Interpolate to find face transparency</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_05_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>若要在整个填充上实现可变的透明度，请将<code>FaceVertexAlphaData</code>设置为用于指定填充的每个顶点或每个面的透明度的值矩阵。然后，通过<code>FaceAlpha</code> 属性指示如何使用 <code>FaceVertexAlphaData</code>确定面的透明度。如果为顶点指定了 alpha 数据，则必须将<code>FaceAlpha</code> 设置为 <code>'interp'</code>。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">p1.FaceVertexAlphaData = x&#x27;;   <span class="hljs-comment">% Set vertex transparency to x values</span><br>p1.FaceAlpha = <span class="hljs-string">&#x27;interp&#x27;</span> ;      <span class="hljs-comment">% Interpolate to find face transparency</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_06_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="包含纹理映射的透明度">5、包含纹理映射的透明度</h3><p>纹理映射将二维图像映射到三维曲面上。通过将 <code>CData</code>属性设置为图像数据并将 <code>FaceColor</code> 属性设置为<code>'texturemap'</code>，可将图像映射到曲面上。</p><p>此示例创建地球和云的三维视图。它创建球形表面，并使用纹理映射将地球和云的图像映射到曲面上。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[px,py,pz] = sphere(50);                % generate coordinates <span class="hljs-keyword">for</span> a 50 x 50 sphere<br><br>cla<br>sEarth = surface(py, px ,flip(pz));   <br>sEarth.FaceColor = <span class="hljs-string">&#x27;texturemap&#x27;</span>;        % <span class="hljs-built_in">set</span> color <span class="hljs-keyword">to</span> texture mapping<br>sEarth.EdgeColor = <span class="hljs-string">&#x27;none&#x27;</span>;              % <span class="hljs-built_in">remove</span> surface edge color<br>sEarth.CData = earth;                   % <span class="hljs-built_in">set</span> color data <br><br>hold on<br>sCloud = surface(px<span class="hljs-number">*1</span>.02,py<span class="hljs-number">*1</span>.02,flip(pz)<span class="hljs-number">*1</span>.02); <br><br>sCloud.FaceColor = <span class="hljs-string">&#x27;texturemap&#x27;</span>;        % <span class="hljs-built_in">set</span> color <span class="hljs-keyword">to</span> texture mapping<br>sCloud.EdgeColor = <span class="hljs-string">&#x27;none&#x27;</span>;              % <span class="hljs-built_in">remove</span> surface edge color<br>sCloud.CData = clouds;                  % <span class="hljs-built_in">set</span> color data <br> <br>sCloud.FaceAlpha = <span class="hljs-string">&#x27;texturemap&#x27;</span>;        % <span class="hljs-built_in">set</span> transparency <span class="hljs-keyword">to</span> texture mapping<br>sCloud.AlphaData = max(clouds,[],3);    % <span class="hljs-built_in">set</span> transparency data <br>hold off<br><br>view([80 2])                            % specify viewpoint <br>daspect([1 1 1])                        % <span class="hljs-built_in">set</span> aspect ratio<br>axis off tight                          % <span class="hljs-built_in">remove</span> axis <span class="hljs-keyword">and</span> <span class="hljs-built_in">set</span> limits <span class="hljs-keyword">to</span> data range<br></code></pre></td></tr></table></figure><figure><imgsrc="https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_07_zh_CN.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>transparency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Getting Started：使用Jekyll创建GitHub Pages站点搭建博客（Windows）</title>
    <link href="/2021/03/01/Getting-Started/"/>
    <url>/2021/03/01/Getting-Started/</url>
    
    <content type="html"><![CDATA[<h3 id="一必要组件的安装">一、必要组件的安装</h3><p>需要首先安装以下内容</p><ul><li><p><strong>Ruby</strong> - <ahref="">是一种面向对象</a>、命令式、函数式、动态的通用编程语言。Windows下直接下载安装即可<ahref="https://rubyinstaller.org/">Rubyinstaller</a>。注意，如遇报错，可能需要将安装目录（xxx-x64）加入系统环境变量PATH。</p></li><li><p><strong>Bundler</strong> - 是一个官方推荐的Rubygem包管理软件，可以减少Jekyll的编译错误，和环境依赖相关的bug，相关链接<ahref="https://bundler.io/">Bundler</a>。只需在终端中运行以下两步：</p><p>1.安装bundler</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gem <span class="hljs-keyword">install</span> bundler<br></code></pre></td></tr></table></figure><p>2.指定源</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gem</span> sources <span class="hljs-string">&#x27;https://rubygems.org&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Jekyll</strong>-相当于一个编译工具，安装好jekyll后，你可以通过jekyll创建一个网站模板从而在本地进行预览，而不用上传至Github后再进行查看，此软件包将在之后的步骤中自动安装。</p></li></ul><h3id="二网站托管在github上创建自己的repo">二、网站托管（在Github上创建自己的repo）</h3><p>github.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：</p><ul><li><p>创建repo</p><p>登陆你的账户后，创建一个新的repo。请务必注意该repo的名字，必须保持格式<code>&lt;username&gt;.github.io</code>，其中`&lt;username） 替换成你的github账户名。</p></li><li><p>把repo clone到本地</p><p>在目录下新建一个index.html的文件,在里面输入任意内容，然后再把代码push送到github上。</p></li><li><p>测试地址</p><p>浏览器里访问<u>https://(username).github.io/</u>,可以发现这个url可以被访问了。</p></li></ul><p>到这里，一个免费且无限流量的Github代码托管仓库就创建完成了。</p><h3 id="三基于jekyll模板建立网站">三、基于Jekyll模板建立网站</h3><p>为了在发布前预览自己的网站，我们需要使用Jekyll，同时它也能为我们提供很多模板。</p><ol type="1"><li><p>首先点击前往<a href="http://jekyllthemes.org/">jekyll主题官网</a>。</p></li><li><p>然后选择一个自己喜欢的主题模板，比如<ahref="http://jekyllthemes.org/themes/jekyll-theme-chirpy/">Chirpy</a>。</p></li><li><p>点击Download下载该模板至repo的本地目录，注意确保根目录下含有Gemfile这个文件。</p><p><img src="/images/QQ截图20210308194033.png"/></p><p>注意插入图片时需要将图片文件放入assets文件夹，在md文件中由于路径不一致会无法正常显示，在网页中是正常的，无须担心。</p></li><li><p>在本地repo目录下打开命令窗口并运行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">bundle <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>自动安装所有依赖的环境</p></li><li><p>最后一步，开启测试</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bundle </span>exec <span class="hljs-keyword">jekyll </span>serve<br></code></pre></td></tr></table></figure><p>成功运行之后，我们就可以通过http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。</p></li></ol><h3 id="四jekyll目录结构">四、Jekyll目录结构</h3><p>​Jekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入<ahref="https://shopify.github.io/liquid/">Liquid</a>脚本的HTML格式存放。内容为markdown或者html。为了撰写自己的博客，需要对模板内容进行修改。</p><p>Jekyll模板通常包含的目录结构：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">_posts</span> 博客内容<br><span class="hljs-variable">_pages</span> 其他需要生成的网页，如About页<br><span class="hljs-variable">_layouts</span> 网页排版模板<br><span class="hljs-variable">_includes</span> 被模板包含的HTML片段，可在<span class="hljs-variable">_config</span>.yml中修改位置<br>assets 辅助资源 css布局 js脚本 图片等<br><span class="hljs-variable">_data</span> 动态数据<br><span class="hljs-variable">_sites</span> 最终生成的静态网页<br><span class="hljs-variable">_config</span>.yml 网站的一些配置信息<br>index.html 网站的入口<br></code></pre></td></tr></table></figure><ol type="1"><li><p>我们打开根目录下的index.html可以看到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">---<br>layout: home<br># Index page<br>---<br></code></pre></td></tr></table></figure></li><li><p>上面的home我们到_layouts目录下可以找到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html">---<br>layout: page<br># The Home page layout<br>---<br><br>&#123;% raw %&#125;<br>&#123;% assign pinned = site.posts | where_exp: &quot;item&quot;, &quot;item.pin == true&quot;  %&#125;<br>&#123;% assign default = site.posts | where_exp: &quot;item&quot;, &quot;item.pin != true&quot;  %&#125;<br>&#123;% assign posts = &quot;&quot; | split: &quot;&quot; %&#125;<br>...<br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta text-muted d-flex justify-content-between&quot;</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- posted date --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;far fa-calendar fa-fw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        &#123;% include timeago.html date=post.date tooltip=true %&#125;<br><br>        <span class="hljs-comment">&lt;!-- time to read --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;far fa-clock fa-fw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        &#123;% include read-time.html content=post.content %&#125;<br><br>        <span class="hljs-comment">&lt;!-- page views --&gt;</span><br>        &#123;% if site.google_analytics.pv.enabled %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;far fa-eye fa-fw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pv_&#123;&#123;-post.title-&#125;&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pageviews&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fas fa-spinner fa-spin fa-fw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        &#123;% endif %&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>      &#123;% if post.pin %&#125;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pin&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fas fa-thumbtack fa-fw&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; site.data.label.pin_prompt | default: &#x27;Pinned&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      &#123;% endif %&#125;<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- .post-meta --&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- .post-review --&gt;</span><br><br>&#123;% endfor %&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- #post-list --&gt;</span><br><br>&#123;% if paginator.total_pages &gt; 0 %&#125;<br>  &#123;% include post-paginator.html %&#125;<br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure><p>实际上根目录下index.html运行后是home里面的代码内容，1中<strong>html代码段</strong>会填充的上图中的<strong>content</strong>位置。jekyll是将分散在各个目录下的html文件拼接起来运行。</p></li><li><p>上图的page布局也可以在_layouts目录下找到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html">---<br>layout: default<br># The page layout<br>---<br>&#123;% raw %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post pb-5 pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4 mb-md-4&quot;</span>&gt;</span><br>    &#123;% if page.dynamic_title %&#125;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dynamic-title&quot;</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-content&quot;</span>&gt;</span><br>        &#123;&#123; content &#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    &#123;% else %&#125;<br>      &#123;&#123; content &#125;&#125;<br>    &#123;% endif %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- #page --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- .col-12 --&gt;</span><br><br>  &#123;% include panel.html %&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>&#123;% if site.disqus.comments and page.comments %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4&quot;</span>&gt;</span><br><br>    &#123;% include disqus.html %&#125;<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- .pl-1 pr-1 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- .col-12 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- .row --&gt;</span><br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure><p>关于Jekyll的更详细用法可以参考<ahref="http://jekyllcn.com/docs/home/">官方网站</a></p><p>ps:</p><ul><li>GitHub Page 的（一种）输入是 markdown 文件，输出是 HTML/CSS/JS文件。</li></ul></li></ol><ul><li><p>如果 markdown 文件包含代码块，且代码块中包含花括号 { 或}，尤其是包含 { % 或 { { 符号组合时，GitHub Page 会报错。</p><ul><li>在代码前后添加{ % raw % }和{ % endraw % }（去掉大括号内的空格）</li></ul></li><li><p>新版本Google Analytics的TrackingID在管理→媒体资源→数据流中，也可以直接搜索。</p><p>pps:</p></li><li><p>本站已使用<strong>Hexo</strong>重新部署，以上仅供参考。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>jekyll</category>
      
    </categories>
    
    
    <tags>
      
      <tag>getting started</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/18180428_1361087742584.jpg","path":"img/18180428_1361087742584.jpg","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1},{"_id":"source/Reference/基于Kriging代理模型的改进EGO算法研究_王红涛.pdf","path":"Reference/基于Kriging代理模型的改进EGO算法研究_王红涛.pdf","modified":1,"renderable":0},{"_id":"source/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.caj","path":"Reference/基于Kriging模型的全局代理优化算法研究_张建侠.caj","modified":1,"renderable":0},{"_id":"source/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.xml","path":"Reference/基于Kriging模型的全局代理优化算法研究_张建侠.xml","modified":1,"renderable":0},{"_id":"source/images/2d-fft.jpg","path":"images/2d-fft.jpg","modified":1,"renderable":0},{"_id":"source/images/2d-fft_2.jpg","path":"images/2d-fft_2.jpg","modified":1,"renderable":0},{"_id":"source/images/A scattering propagator.png","path":"images/A scattering propagator.png","modified":1,"renderable":0},{"_id":"source/images/BN_and_LN.png","path":"images/BN_and_LN.png","modified":1,"renderable":0},{"_id":"source/images/QQ截图20210308194033.png","path":"images/QQ截图20210308194033.png","modified":1,"renderable":0},{"_id":"source/images/QQ截图20210722185927.png","path":"images/QQ截图20210722185927.png","modified":1,"renderable":0},{"_id":"source/images/QQ截图20210722190017.png","path":"images/QQ截图20210722190017.png","modified":1,"renderable":0},{"_id":"source/images/QQ截图20210722185958.png","path":"images/QQ截图20210722185958.png","modified":1,"renderable":0},{"_id":"source/images/2021-07-23-小波散射网络/A scattering propagator.png","path":"images/2021-07-23-小波散射网络/A scattering propagator.png","modified":1,"renderable":0},{"_id":"source/images/2021-07-23-小波散射网络/Scattering coefficients.PNG","path":"images/2021-07-23-小波散射网络/Scattering coefficients.PNG","modified":1,"renderable":0},{"_id":"source/images/2021-07-23-小波散射网络/小波神经网络的结构.png","path":"images/2021-07-23-小波散射网络/小波神经网络的结构.png","modified":1,"renderable":0},{"_id":"source/images/2021-11-03-代理模型/Kriging模型.png","path":"images/2021-11-03-代理模型/Kriging模型.png","modified":1,"renderable":0},{"_id":"source/images/2021-11-03-代理模型/RBF.jpg","path":"images/2021-11-03-代理模型/RBF.jpg","modified":1,"renderable":0},{"_id":"source/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png","path":"images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png","modified":1,"renderable":0},{"_id":"source/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png","path":"images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png","modified":1,"renderable":0},{"_id":"source/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp","path":"images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp","modified":1,"renderable":0},{"_id":"source/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg","path":"images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.xml","hash":"010938d8f90a30aa72d138f32c3e1d25cdeac234","modified":1635933354754},{"_id":"source/_posts/2021-03-01-Getting-Started.md","hash":"4c976b1679837e17bc5b602aabfc54d658b7988b","modified":1628992068233},{"_id":"source/_posts/2021-04-06-Matlab设置颜色图范围.md","hash":"0b0d2a36735667a5d4cd50c731f6d857da435e0a","modified":1628992068233},{"_id":"source/_posts/2021-05-14-python中的lambda和map函数.md","hash":"97e8c14b24ccc1ac489a8749e6afd9c5dc5cd205","modified":1628992068237},{"_id":"source/_posts/2021-04-06-Matlab颜色进阶.md","hash":"c02c790bc8e19e450752571043e9b72046dfb6f0","modified":1628992068236},{"_id":"source/_posts/2021-06-09-keras中LN层的使用.md","hash":"3af06e54377ff703a649078b727372dd6847b21e","modified":1628992068238},{"_id":"source/_posts/2021-07-23-小波散射网络.md","hash":"767dcfa907dc0458b0a7bc5a7adb28f09ba57faf","modified":1636103497391},{"_id":"source/_posts/2021-06-20-信号处理傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换.md","hash":"5014f0da55b8aab36ad251bc921eb5ff26e290f3","modified":1636103503535},{"_id":"source/_posts/2021-09-07-微分方程.md","hash":"3fb4a57682b83fc754b2364f062a15915872393c","modified":1636103492614},{"_id":"source/_posts/2021-11-05-回归模型.md","hash":"b8d8054f79ead8d90b80d007e259e24308274043","modified":1636423207915},{"_id":"source/_posts/2021-11-03-代理模型.md","hash":"1f2eb7228fe6a84c0c180d9f8130bad85f459d48","modified":1640782387258},{"_id":"source/_posts/2021-11-08-数据融合.md","hash":"9efde25d21b57ab5343bfb320a255904641e624e","modified":1636421412860},{"_id":"source/_posts/2021-11-29-薄板结构的模态分析.md","hash":"14b8b7e0f86967f2295ff3955febb637bfe71135","modified":1645621312997},{"_id":"source/_posts/2021总结.md","hash":"6d45452a755c2464e5c04a8ee8642e01f41b4096","modified":1630983171888},{"_id":"source/_posts/2022-02-11-环境配置.md","hash":"81c4f8d73cfddc509ecb959bfda9abc1c77794c4","modified":1645934731814},{"_id":"source/about/index.md","hash":"5078229046d59acb97d99ed9f820eb4db673805c","modified":1628992068242},{"_id":"source/_posts/_生成目录及插入图片公式的方法.txt","hash":"e214b14841dbe0bd9dc3a07fb1c7c3a80bd712eb","modified":1629104004714},{"_id":"source/images/A scattering propagator.png","hash":"9c660da080b52b0368489aaae7cebd9c4611697f","modified":1629081231782},{"_id":"source/images/QQ截图20210308194033.png","hash":"8bf630053a7137ecc6d4b6540d55f9f33f7c6694","modified":1628992068257},{"_id":"source/images/2021-07-23-小波散射网络/A scattering propagator.png","hash":"9c660da080b52b0368489aaae7cebd9c4611697f","modified":1629081231782},{"_id":"source/images/2021-07-23-小波散射网络/小波神经网络的结构.png","hash":"3eca5854afa2bd3f406e7faf2b5d14f4c1998d3f","modified":1629081231788},{"_id":"source/images/2021-11-03-代理模型/RBF.jpg","hash":"ff073e62900221c7ef0795f09c3145966e5bd4eb","modified":1636081751506},{"_id":"source/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png","hash":"2641ab18f905dbe112e095b33251472fd31f6f59","modified":1640782387260},{"_id":"source/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png","hash":"5bb43c5ed2fa500e480973110a3da6e6bab296a7","modified":1640782387261},{"_id":"source/images/2d-fft.jpg","hash":"6bade03e5fe4ae3b8d9f969f01ccaf1447ef9bf8","modified":1628992068252},{"_id":"source/images/2d-fft_2.jpg","hash":"f32b95806e9e0811c4a68819b3c8871d74311e97","modified":1628992068255},{"_id":"source/images/QQ截图20210722190017.png","hash":"f6e351c0acd0818990cda3013058e3c5b34c2a69","modified":1628992068272},{"_id":"source/images/BN_and_LN.png","hash":"054b02e0a8f311d93a13596fe3f4873793d44924","modified":1628992068256},{"_id":"source/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg","hash":"88213b040374472497f3509f5adf33147ed78543","modified":1630983171890},{"_id":"source/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp","hash":"9543723da8de8145c63ed5319deaf7a5cfd003a9","modified":1640782387261},{"_id":"source/Reference/基于Kriging代理模型的改进EGO算法研究_王红涛.pdf","hash":"3ea014a517125a39f8b3bd1a0e145923f8e47ae8","modified":1635907892938},{"_id":"source/images/QQ截图20210722185927.png","hash":"782b9d71f16655408b2ab53a493d53894de15f12","modified":1628992068263},{"_id":"source/images/2021-11-03-代理模型/Kriging模型.png","hash":"06cd2df7db5ee10f67e3cd9c2baf1636adb3da9f","modified":1636361260191},{"_id":"source/images/QQ截图20210722185958.png","hash":"c2bf784ba1f9b103c305e953f002c76cf1101daa","modified":1628992068270},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628992068498},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1628992068510},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1628992068274},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1628992068273},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1628992068273},{"_id":"themes/fluid/README.md","hash":"bc8ed55dc5514cd790274bd41440d816e77d1d01","modified":1628992068285},{"_id":"themes/fluid/LICENSE","hash":"694fb3659a4331dd752bd92e4248623bff8617cd","modified":1628992068284},{"_id":"themes/fluid/README_en.md","hash":"2b47ed68ec888dcc34fa6aad9ce95aeba6744fec","modified":1628992068286},{"_id":"themes/fluid/gulpfile.js","hash":"93e2bd4a4f1902e7a4c99ae3ebfa6420fd906c1b","modified":1628992068287},{"_id":"themes/fluid/_config.yml","hash":"d49ba28584ca14270057ccc94dd5bd15b142b901","modified":1645932287712},{"_id":"themes/fluid/languages/de.yml","hash":"288f649c2c2314eb610693b18853ee74f0541e87","modified":1628992068291},{"_id":"themes/fluid/package.json","hash":"5b8a8be1ab4be8c799eb0e5e141c9314c7fbe886","modified":1628992068324},{"_id":"themes/fluid/languages/en.yml","hash":"31f2867619a768606166778d4ee51f3d00ac33a0","modified":1628992068291},{"_id":"themes/fluid/languages/eo.yml","hash":"2c1c481d9af116e79fe55a0aa0bdbb143a97f559","modified":1628992068292},{"_id":"themes/fluid/languages/ja.yml","hash":"dc43be11a300893ebef47283c22f2f946ca21260","modified":1628992068292},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"3b92f4428d66c31610f6cde13b82ee723aff00d2","modified":1628992068293},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"de9b7e729d72eee9327671c3d5df0a607c4c3257","modified":1628992068293},{"_id":"themes/fluid/layout/404.ejs","hash":"79a598e43c40d48b23076361720f1e77df466e41","modified":1628992068294},{"_id":"themes/fluid/layout/archive.ejs","hash":"7a1e19dec37804927f0d331d7e6c80ed03becd61","modified":1628992068318},{"_id":"themes/fluid/layout/categories.ejs","hash":"4255c27c8f31fbcc12ec3a973fe73b7a3a35782f","modified":1628992068319},{"_id":"themes/fluid/layout/index.ejs","hash":"32a6c84b4690ecf8505ca786bc80aa90530b1534","modified":1628992068320},{"_id":"themes/fluid/layout/category.ejs","hash":"dd2bd15cbd811d6ea973b6e6a17d99e36151e274","modified":1628992068319},{"_id":"themes/fluid/layout/about.ejs","hash":"5b6de01c82b14834ab1e67f0a803612f5855f064","modified":1628992068317},{"_id":"themes/fluid/layout/layout.ejs","hash":"a8342733553ce3368a8520e6f430666070f7d8dc","modified":1628992068321},{"_id":"themes/fluid/layout/links.ejs","hash":"b282e8888cd844bb24b31677a32feb444ecc4144","modified":1628992068321},{"_id":"themes/fluid/layout/page.ejs","hash":"f867e69e563b8ad83054714f73d9173ea050d93b","modified":1628992068322},{"_id":"themes/fluid/layout/tag.ejs","hash":"3a9296eb7181e8b3fb0cdc60cbafc815b98d6f51","modified":1628992068323},{"_id":"themes/fluid/layout/post.ejs","hash":"edfeb655895027d15334d009324d27a29926cc94","modified":1628992068322},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1628992068324},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"beb3474d6f65c1e56700ba872c6a0d0836d4168e","modified":1628992068275},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"78ce211415d502c5a4398d786d5c697d34d868b9","modified":1628992068277},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1628992068279},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1628992068280},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1628992068281},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"18381d03518526d7cefd024a0bdd8d9e7c6440f5","modified":1628992068282},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1628992068283},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"4c04caa5ca20bbcbf0934bb7adba4d2cd8a26da2","modified":1628992068283},{"_id":"themes/fluid/layout/_partial/archive-list.ejs","hash":"7d780309e12c437c2f8a246dd2fd0c272b8636ce","modified":1628992068295},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"53d9f79b4a3b71d2e89872fa138bc09611862ee4","modified":1628992068295},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"04957fcd5c9025da54d593652b51939e54056827","modified":1628992068303},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"585bb98a23ced3cfbbff6d73d48fdbcd4a87577a","modified":1628992068304},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"8e29e7ddbda1555c0f9d0d4b5d4550975fec7537","modified":1628992068304},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1628992068305},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"3f16de8c40d87c7d23eba121dd8061757c3f9a58","modified":1628992068314},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"48944e12d95dc46137f9f270629296cfd2a8dd22","modified":1628992068305},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"1d8349b7d26271e08cee592aa66f9c79ec41c3c0","modified":1628992068314},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"bea21f1b5de61badd6c068080315c201fc80bc36","modified":1628992068316},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"a70c26e415a27f07f38b9384e7eb48d1f2b30328","modified":1628992068316},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"76e6bc368cf46d4103ea9514699e10ec0b9a4b56","modified":1628992068317},{"_id":"themes/fluid/scripts/events/index.js","hash":"91defe82d50a317903411f0b260da0f140f43dc4","modified":1628992068326},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"c72a7373c19b730e926b476eb528f651617ac4f2","modified":1628992068445},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1628992068448},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"1664f8faa028898bd6f91d6db61c7dbf7463ee01","modified":1628992068449},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"4acb213f90f1e7ba3696ef08d894a2a84807b669","modified":1628992068452},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"da6144ee040fed0a9b9f45da3478bc33087b5ac9","modified":1628992068453},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1628992068429},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"cb72e5acfba882a6eacd6cae8db3238bb078737a","modified":1628992068430},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1628992068455},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"dac0e08eaa3614a6fd9ddbdfb4584094b1bdb30a","modified":1628992068456},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1628992068459},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1628992068459},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1628992068461},{"_id":"themes/fluid/scripts/tags/note.js","hash":"8020acc2c4bb3a2054e3cb349fac7cd10b79a0be","modified":1628992068462},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"ec068c699155565aea4aa4ab55d8a10b2947a114","modified":1628992068463},{"_id":"themes/fluid/scripts/utils/object.js","hash":"d798779ec79a53ce04b8ac79efd5d064981d95bd","modified":1628992068463},{"_id":"themes/fluid/source/css/custom.styl","hash":"ecc33ba09ef1eb3e4ca5501fad80222de131bda7","modified":1628992068514},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1628992068514},{"_id":"themes/fluid/source/css/main.styl","hash":"bf536db598434c36cc0c752196bfde46e584a92e","modified":1628992068515},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1628992068433},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1628992068440},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1628992068522},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1628992068524},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1628992068524},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1628992068529},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1628992068524},{"_id":"themes/fluid/source/js/boot.js","hash":"5264c0d2eb73b4948ee6bcb1bd847a924d906088","modified":1628992068530},{"_id":"themes/fluid/source/js/color-schema.js","hash":"2840108a36b1e9a02cd2ed25adcffde08c42e1cc","modified":1628992068531},{"_id":"themes/fluid/source/js/events.js","hash":"2c40be98f3471427626b9130fd231bc7e9a66d03","modified":1628992068533},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1628992068533},{"_id":"themes/fluid/source/js/leancloud.js","hash":"ca82e71e31d3d5ef7fe9487756af06d4e27d9b53","modified":1628992068534},{"_id":"themes/fluid/source/js/local-search.js","hash":"3b9322b6b669c870360db468446b00f53bd1b44c","modified":1628992068535},{"_id":"themes/fluid/source/js/plugins.js","hash":"1afcd1ca415edc994ae813d6f5d54dd3d1888bc4","modified":1628992068536},{"_id":"themes/fluid/source/js/utils.js","hash":"f20aa828122fce9a76c03b07c7da142704edc8c0","modified":1628992068537},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"b13e69e555ddec2a71710e07178793e7e13319e7","modified":1628992068296},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1628992068540},{"_id":"themes/fluid/layout/_partial/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1628992068297},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1628992068299},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"7a35381478328b65c9d81827504c4e031bc76a86","modified":1628992068299},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1628992068300},{"_id":"themes/fluid/layout/_partial/comments/twikoo.ejs","hash":"c3297931cf5d3d1bc53d988b74cbc54dd06ebbd7","modified":1628992068301},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"caae3f692523275b8ca1c56c009a6aeb9c7fdc03","modified":1628992068302},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1628992068300},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"d1e86754c9560f7346200b2aa9a7f715a3fac82b","modified":1628992068302},{"_id":"themes/fluid/layout/_partial/comments/waline.ejs","hash":"d6f6620fbc6cf3df5a52322378c0d703b7e1fcf9","modified":1628992068303},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"d20f54bf2fd5cd274b4b9c5542eafbfec5120838","modified":1628992068310},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"a49a0064b55cf6d8f2a61abfecd41f0083757e04","modified":1628992068311},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"fd1f78287c868ccab78b6244b66e3f9b0968c4a8","modified":1628992068312},{"_id":"themes/fluid/layout/_partial/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1628992068312},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"c57817ceaee868d416558e56d2a8d0d418c64a2d","modified":1628992068313},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"c0da20f9adca2761d370cc6dda013ec1ecbb7710","modified":1628992068404},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"13d8466cd4c98367131b5f3d6a30b3d4ce8de26f","modified":1628992068410},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"1a262c15896663dba773a1796f637f6484f3e524","modified":1628992068413},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"3f2dba4959b27466521de97eff692815650c02b7","modified":1628992068426},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"00a4876e9c37b77fed619138b8bd9ad88ea1e9f3","modified":1628992068425},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1628992068465},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"5eec946182fd537a4d75f15bdf7a09453cc00d83","modified":1628992068424},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1628992068466},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1628992068511},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"d555a4c9df7b49250c1747c2fbd8353f2d822775","modified":1628992068513},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"64fa8c328dc93432ec822de2818aef21a4f63b29","modified":1628992068539},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"47235d222812e2f829e9bde039fa719bbced9325","modified":1628992068467},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"86926a80bf6f39a7f47789b1a8f44b5984b4683f","modified":1628992068472},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"33d237014f22324a034ae463857ce2af72a0d65e","modified":1628992068495},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"2dd6f1a8470f5bd10ed53cfcba6811197c79d487","modified":1628992068495},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"6f2a3b8af2793dd831f661c6db0ccbe0a62ccc48","modified":1628992068496},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"c628894ec5afab5b3e6f4633390f2b403bf6678f","modified":1628992068497},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1628992068496},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"0924e35eff2ec84e2d9e4772abccda452d9463ef","modified":1628992068498},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1628992068510},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"c189a52dbc6eb554d1da3f2636920813b3b7e4fb","modified":1628992068508},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"88939a09d1ab73a2b96a6b8b08c96ad03d402728","modified":1628992068509},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"83694b28209c548ef38bee78e473b02e90cbcf9f","modified":1628992068507},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"5775fd234c62a2f3520b34b2a66fe181cc2d4ea3","modified":1628992068499},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"bb9cdde191b9b1287ba19414bab862f30be6a8a0","modified":1628992068474},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"da823846f0896f16b21c7430f047f7222a89cd10","modified":1628992068473},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"c398892fba1494dd6fd417415076458ed321d34d","modified":1628992068474},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"dbd0a3518e5bfca92851490b34654f46bb5cfc76","modified":1628992068475},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1628992068475},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"d29064ed8bdf62d5cf4eac32ebdb5d0c7075ebbd","modified":1628992068492},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"f770c5c3ee89421e9e3f1313ca5bd07a2448f400","modified":1628992068476},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e568f308df26465e0432197e8b57384707470f54","modified":1628992068494},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1628992068494},{"_id":"source/images/2021-07-23-小波散射网络/Scattering coefficients.PNG","hash":"557514c65b1d8870d44d4fc677551c0d600d222e","modified":1629171106297},{"_id":"themes/fluid/source/img/18180428_1361087742584.jpg","hash":"1e03128e1150ddd48b3a2ecef1638b2a24b52d24","modified":1628992068522},{"_id":"source/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.caj","hash":"8231e1579013a4856cf91f085e1e8b435880801b","modified":1635933352180},{"_id":"public/local-search.xml","hash":"3a3b404cfb1d7022115c7f54e823d03bec58ee31","modified":1645935103364},{"_id":"public/about/index.html","hash":"36c3dac4927db38000e05513edf231ad9ea12b10","modified":1645935103364},{"_id":"public/2021/11/08/数据融合/index.html","hash":"d7ae86b29089eadaaf675691450329d2556b1fc3","modified":1645935103364},{"_id":"public/2021/11/05/回归模型/index.html","hash":"fa90e850c1650a2294828e9b8e79273ef077fa7a","modified":1645935103364},{"_id":"public/2021/09/07/微分方程/index.html","hash":"3a5e95025185cd2d6627f980e7a837fa62070c4e","modified":1645935103364},{"_id":"public/archives/index.html","hash":"b9e9b6fb0ed55a0cdefe766fb2e74a3d258d94df","modified":1645935103364},{"_id":"public/archives/page/2/index.html","hash":"cbcbb0151d02b07d6f4ea938eabdbc587c706dba","modified":1645935103364},{"_id":"public/archives/2021/index.html","hash":"2d02bc3e5bef4644ab8261252d9f03b6f5c07fd1","modified":1645935103364},{"_id":"public/archives/2021/page/2/index.html","hash":"9911aaf7080b710ee3f8faee29f88dcf9ebd2236","modified":1645935103364},{"_id":"public/archives/2021/03/index.html","hash":"e1f58b6194a2ef19fd502f3b4f135c5b04bf891e","modified":1645935103364},{"_id":"public/archives/2021/04/index.html","hash":"ac75c288175fc6f4897a4aab63828fcaa1592be8","modified":1645935103364},{"_id":"public/archives/2021/05/index.html","hash":"5748df4e9cae727e22a7477341a4e57a383296e8","modified":1645935103364},{"_id":"public/archives/2021/06/index.html","hash":"ab556a71ba65dbe7478c1d4d1ea7c5d617d4900a","modified":1645935103364},{"_id":"public/archives/2021/07/index.html","hash":"4567f1545ab2ae4130b3d63df3222541dd6e79d6","modified":1645935103364},{"_id":"public/archives/2021/09/index.html","hash":"ab5ec72729d6fda90a12ec092bf014046b87a612","modified":1645935103364},{"_id":"public/archives/2021/11/index.html","hash":"1c790e1eb3d9c66e0ef21528b0ad4069a78b51ad","modified":1645935103364},{"_id":"public/archives/2021/12/index.html","hash":"6ef61ce484a64cb0b9d9ac8960a8371aa8a22cc4","modified":1645935103364},{"_id":"public/archives/2022/index.html","hash":"113ce10c1def2e1589ff434ed80f1c6157cd5a8a","modified":1645935103364},{"_id":"public/archives/2022/02/index.html","hash":"113ce10c1def2e1589ff434ed80f1c6157cd5a8a","modified":1645935103364},{"_id":"public/categories/jekyll/index.html","hash":"f26a600590f8d572410f9ce16433d63e1e6c12c2","modified":1645935103364},{"_id":"public/categories/python/index.html","hash":"0a0ab6e95e1794bf7141e7589fdf9922ce275cfb","modified":1645935103364},{"_id":"public/categories/Matlab/index.html","hash":"962eda7a665d21f9fe55026e423ed7281f31b863","modified":1645935103364},{"_id":"public/categories/signal-processing/index.html","hash":"5f2de44bb90f871c71d31159993ac2267492ebda","modified":1645935103364},{"_id":"public/page/2/index.html","hash":"5230530397ef432b2440f0c9ebd858abfcb04850","modified":1645935103364},{"_id":"public/tags/getting-started/index.html","hash":"a8e2111534ec2532651d0892cae3cb0e09e542c5","modified":1645935103364},{"_id":"public/tags/python/index.html","hash":"68b7ddcba56fbd0868938be290b6bf148f549bd9","modified":1645935103364},{"_id":"public/tags/lambda/index.html","hash":"03dd1ba0d255a6d40661ea6a112847cbe577d863","modified":1645935103364},{"_id":"public/tags/map/index.html","hash":"80445bcbca7f8d95e4b82fa9ae2b2f31a1876780","modified":1645935103364},{"_id":"public/tags/Matlab/index.html","hash":"0a1044a3818bb0d3e37b7de4a5e16619e8b6e1d1","modified":1645935103364},{"_id":"public/tags/surf/index.html","hash":"47919b7ea3f20431a2145cb9964f79c7173206da","modified":1645935103364},{"_id":"public/tags/color/index.html","hash":"d5d42def6ed4f584f1c1f2c98d98bd77d858d7bc","modified":1645935103364},{"_id":"public/tags/transparency/index.html","hash":"4c7fd70324ba1a62e24c454e809cf6d09aa25fce","modified":1645935103364},{"_id":"public/tags/LN/index.html","hash":"2c303344fc11fe03a59106c9abc3d6e14b20ef7e","modified":1645935103364},{"_id":"public/tags/Keras/index.html","hash":"8f9b00241c696c59f20105ae6b1d6773deb0f766","modified":1645935103364},{"_id":"public/tags/FFT/index.html","hash":"5f64e3bf4f533ecbf554f88ab38c9f9b3d200e56","modified":1645935103364},{"_id":"public/tags/STFT/index.html","hash":"f0b82296feb1fd2035573a9578afae3f0f08f8cc","modified":1645935103364},{"_id":"public/tags/WT/index.html","hash":"eede466a902bbf4485a84024bccbb23b9cac05df","modified":1645935103364},{"_id":"public/tags/HT/index.html","hash":"0bbd194518381a69085728614097c4f28de44ce7","modified":1645935103364},{"_id":"public/tags/HHT/index.html","hash":"5eade2c2ca88ed2b967e1ac7f3b26f6a75103223","modified":1645935103364},{"_id":"public/tags/signal-processing/index.html","hash":"13f61a950466798229cf43b8f7705b2709028775","modified":1645935103364},{"_id":"public/404.html","hash":"7f6928278d7fac78ac44361cfccea63a150deb43","modified":1645935103364},{"_id":"public/tags/index.html","hash":"39865336f59c3f6246253b3c4487ec2739afc685","modified":1645935103364},{"_id":"public/links/index.html","hash":"c1cbb76b9a93667c7a4e1c54de1b1f0b197aec39","modified":1645935103364},{"_id":"public/2022/02/11/环境配置/index.html","hash":"e472ec55d21b5e4cbb7d5d2303b72fd8eec3d9a7","modified":1645935103364},{"_id":"public/2021/12/29/代理模型/index.html","hash":"da8a375708e1c40375711ac64cd214b912f3ca32","modified":1645935103364},{"_id":"public/2021/11/29/薄板结构的模态分析/index.html","hash":"ef52c0f41781d7f585a1115512fe7224a368e96a","modified":1645935103364},{"_id":"public/2021/07/23/小波散射网络/index.html","hash":"559d9efa198b8ca6745ae5860ca552b061a0c516","modified":1645935103364},{"_id":"public/2021/07/01/2021总结/index.html","hash":"bbff888f280e0e800661b6572face0b8ca52ab8c","modified":1645935103364},{"_id":"public/2021/06/20/信号处理傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换/index.html","hash":"0e46e3dd4093630d77bc3c46ac1116a621d60655","modified":1645935103364},{"_id":"public/2021/06/09/keras中LN层的使用/index.html","hash":"8062dbf72b168e6ae485f8c79405762da834d0af","modified":1645935103364},{"_id":"public/2021/05/14/python中的lambda和map函数/index.html","hash":"e0fa78ff9cc3e45eb2836a1c5ad43e118a25a063","modified":1645935103364},{"_id":"public/2021/04/06/Matlab设置颜色图范围/index.html","hash":"cf8c41d19cdfc61dfe18bcbe0c3c9debc11aeff6","modified":1645935103364},{"_id":"public/2021/04/06/Matlab颜色进阶/index.html","hash":"a3f93138bb969d8bdb4837f1435b3d9aa139ee8b","modified":1645935103364},{"_id":"public/2021/03/01/Getting-Started/index.html","hash":"cf6e172a60a1166c4a2b8d86ea47b81c0be09773","modified":1645935103364},{"_id":"public/index.html","hash":"a8ea49beb6eee01782a2dd82f19fb5150d7f507a","modified":1645935103364},{"_id":"public/categories/index.html","hash":"dcb7491934df95bdc3996197a2a72e3b08b1068d","modified":1645935103364},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1645935103364},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1645935103364},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1645935103364},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1645935103364},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1645935103364},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1645935103364},{"_id":"public/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.xml","hash":"010938d8f90a30aa72d138f32c3e1d25cdeac234","modified":1645935103364},{"_id":"public/images/A scattering propagator.png","hash":"9c660da080b52b0368489aaae7cebd9c4611697f","modified":1645935103364},{"_id":"public/images/QQ截图20210308194033.png","hash":"8bf630053a7137ecc6d4b6540d55f9f33f7c6694","modified":1645935103364},{"_id":"public/images/2021-07-23-小波散射网络/A scattering propagator.png","hash":"9c660da080b52b0368489aaae7cebd9c4611697f","modified":1645935103364},{"_id":"public/images/2021-07-23-小波散射网络/小波神经网络的结构.png","hash":"3eca5854afa2bd3f406e7faf2b5d14f4c1998d3f","modified":1645935103364},{"_id":"public/images/2021-11-03-代理模型/RBF.jpg","hash":"ff073e62900221c7ef0795f09c3145966e5bd4eb","modified":1645935103364},{"_id":"public/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png","hash":"2641ab18f905dbe112e095b33251472fd31f6f59","modified":1645935103364},{"_id":"public/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png","hash":"5bb43c5ed2fa500e480973110a3da6e6bab296a7","modified":1645935103364},{"_id":"public/images/2d-fft.jpg","hash":"6bade03e5fe4ae3b8d9f969f01ccaf1447ef9bf8","modified":1645935103364},{"_id":"public/images/2d-fft_2.jpg","hash":"f32b95806e9e0811c4a68819b3c8871d74311e97","modified":1645935103364},{"_id":"public/images/QQ截图20210722190017.png","hash":"f6e351c0acd0818990cda3013058e3c5b34c2a69","modified":1645935103364},{"_id":"public/css/custom.css","hash":"606de2383433681228cbd0bb89b54c1a6a947559","modified":1645935103364},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1645935103364},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1645935103364},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1645935103364},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1645935103364},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1645935103364},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1645935103364},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1645935103364},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1645935103364},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1645935103364},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1645935103364},{"_id":"public/css/main.css","hash":"be9a0652de06d61fa26f4b4128b29bcc5a4a0ad7","modified":1645935103364},{"_id":"public/images/BN_and_LN.png","hash":"054b02e0a8f311d93a13596fe3f4873793d44924","modified":1645935103364},{"_id":"public/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg","hash":"88213b040374472497f3509f5adf33147ed78543","modified":1645935103364},{"_id":"public/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp","hash":"9543723da8de8145c63ed5319deaf7a5cfd003a9","modified":1645935103364},{"_id":"public/Reference/基于Kriging代理模型的改进EGO算法研究_王红涛.pdf","hash":"3ea014a517125a39f8b3bd1a0e145923f8e47ae8","modified":1645935103364},{"_id":"public/images/QQ截图20210722185927.png","hash":"782b9d71f16655408b2ab53a493d53894de15f12","modified":1645935103364},{"_id":"public/images/2021-11-03-代理模型/Kriging模型.png","hash":"06cd2df7db5ee10f67e3cd9c2baf1636adb3da9f","modified":1645935103364},{"_id":"public/images/QQ截图20210722185958.png","hash":"c2bf784ba1f9b103c305e953f002c76cf1101daa","modified":1645935103364},{"_id":"public/img/18180428_1361087742584.jpg","hash":"1e03128e1150ddd48b3a2ecef1638b2a24b52d24","modified":1645935103364},{"_id":"public/images/2021-07-23-小波散射网络/Scattering coefficients.PNG","hash":"557514c65b1d8870d44d4fc677551c0d600d222e","modified":1645935103364},{"_id":"public/Reference/基于Kriging模型的全局代理优化算法研究_张建侠.caj","hash":"8231e1579013a4856cf91f085e1e8b435880801b","modified":1645935103364}],"Category":[{"name":"jekyll","_id":"cl04r9i9j0003y8uxa8w88gl4"},{"name":"python","_id":"cl04r9i9o0008y8ux5i9ofjkg"},{"name":"Matlab","_id":"cl04r9i9r000ey8ux04tjg04g"},{"name":"signal processing","_id":"cl04r9i9z000ty8ux5hed4923"}],"Data":[],"Page":[{"title":"about","date":"2021-06-30T02:16:37.000Z","layout":"about","_content":"\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-06-30 10:16:37\nlayout: about\n---\n\n","updated":"2021-08-15T01:47:48.242Z","path":"about/index.html","comments":1,"_id":"cl04r9i9b0000y8uxa2oa4r22","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Getting Started：使用Jekyll创建GitHub Pages站点搭建博客（Windows）","author":"Shi Daming","date":"2021-03-01T09:00:00.000Z","pin":true,"_content":"### 一、必要组件的安装\n\n需要首先安装以下内容\n\n- **Ruby** - [是一种面向对象]()、命令式、函数式、动态的通用编程语言。Windows下直接下载安装即可[Ruby installer](https://rubyinstaller.org/)。注意，如遇报错，可能需要将安装目录（xxx\\Ruby27-x64\\bin）加入系统环境变量PATH。\n\n- **Bundler** - 是一个官方推荐的Ruby gem包管理软件，可以减少Jekyll的编译错误，和环境依赖相关的bug，相关链接[Bundler](https://bundler.io/)。只需在终端中运行以下两步：\n\n  1.安装bundler\n\n  ```\n  gem install bundler\n  ```\n\n  2.指定源\n\n  ```\n  gem sources 'https://rubygems.org'\n  ```\n\n- **Jekyll** -相当于一个编译工具，安装好jekyll后，你可以通过jekyll创建一个网站模板从而在本地进行预览，而不用上传至Github后再进行查看，此软件包将在之后的步骤中自动安装。\n\n### 二、网站托管（在Github上创建自己的repo）\n\ngithub.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：\n\n- 创建repo\n\n  登陆你的账户后，创建一个新的repo。请务必注意该repo的名字，必须保持格式`<username>.github.io`，其中 `<username） 替换成你的github账户名。\n\n- 把repo clone到本地\n\n  在目录下新建一个index.html的文件,在里面输入任意内容，然后再把代码push送到github上。\n\n- 测试地址\n\n  浏览器里访问<u>https://(username).github.io/</u>,可以发现这个url可以被访问了。\n\n到这里，一个免费且无限流量的Github代码托管仓库就创建完成了。\n\n### 三、基于Jekyll模板建立网站\n\n为了在发布前预览自己的网站，我们需要使用Jekyll，同时它也能为我们提供很多模板。\n\n1. 首先点击前往[jekyll 主题官网](http://jekyllthemes.org/)。\n\n2. 然后选择一个自己喜欢的主题模板，比如[Chirpy](http://jekyllthemes.org/themes/jekyll-theme-chirpy/)。\n\n3. 点击Download下载该模板至repo的本地目录，注意确保根目录下含有Gemfile这个文件。\n\n   <img src=\"/images/QQ截图20210308194033.png\"/>\n\n   注意插入图片时需要将图片文件放入assets文件夹，在md文件中由于路径不一致会无法正常显示，在网页中是正常的，无须担心。\n\n4. 在本地repo目录下打开命令窗口并运行\n\n   ```\n   bundle install\n   ```\n\n   自动安装所有依赖的环境\n\n5. 最后一步，开启测试\n\n   ```\n   bundle exec jekyll serve\n   ```\n\n   成功运行之后，我们就可以通过http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。\n\n### 四、Jekyll目录结构\n\n​\tJekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入[Liquid](https://shopify.github.io/liquid/)脚本的HTML格式存放。内容为markdown或者html。为了撰写自己的博客，需要对模板内容进行修改。\n\nJekyll模板通常包含的目录结构：\n\n```\n    _posts 博客内容\n    _pages 其他需要生成的网页，如About页\n    _layouts 网页排版模板\n    _includes 被模板包含的HTML片段，可在_config.yml中修改位置\n    assets 辅助资源 css布局 js脚本 图片等\n    _data 动态数据\n    _sites 最终生成的静态网页\n    _config.yml 网站的一些配置信息\n    index.html 网站的入口\n```\n\n1. 我们打开根目录下的index.html可以看到：\n\n   ```html\n   ---\n   layout: home\n   # Index page\n   ---\n   ```\n\n2. 上面的home我们到_layouts目录下可以找到：\n\n   ```html\n   ---\n   layout: page\n   # The Home page layout\n   ---\n   \n   {% raw %}\n   {% assign pinned = site.posts | where_exp: \"item\", \"item.pin == true\"  %}\n   {% assign default = site.posts | where_exp: \"item\", \"item.pin != true\"  %}\n   {% assign posts = \"\" | split: \"\" %}\n   ...\n      <div class=\"post-meta text-muted d-flex justify-content-between\">\n   \n         <div>\n           <!-- posted date -->\n           <i class=\"far fa-calendar fa-fw\"></i>\n           {% include timeago.html date=post.date tooltip=true %}\n   \n           <!-- time to read -->\n           <i class=\"far fa-clock fa-fw\"></i>\n           {% include read-time.html content=post.content %}\n   \n           <!-- page views -->\n           {% if site.google_analytics.pv.enabled %}\n           <i class=\"far fa-eye fa-fw\"></i>\n           <span id=\"pv_{{-post.title-}}\" class=\"pageviews\">\n             <i class=\"fas fa-spinner fa-spin fa-fw\"></i>\n           </span>\n           {% endif %}\n         </div>\n   \n         {% if post.pin %}\n         <div class=\"pin\">\n           <i class=\"fas fa-thumbtack fa-fw\"></i>\n           <span>{{ site.data.label.pin_prompt | default: 'Pinned' }}</span>\n         </div>\n         {% endif %}\n   \n       </div> <!-- .post-meta -->\n   \n     </div> <!-- .post-review -->\n   \n   {% endfor %}\n   \n   </div> <!-- #post-list -->\n   \n   {% if paginator.total_pages > 0 %}\n     {% include post-paginator.html %}\n   {% endif %}\n   {% endraw %}\n   ```\n\n   实际上根目录下index.html运行后是home里面的代码内容，1中**html代码段**会填充的上图中的**content**位置。jekyll是将分散在各个目录下的html文件拼接起来运行。\n\n3. 上图的page布局也可以在_layouts目录下找到：\n\n   ```html\n   ---\n   layout: default\n   # The page layout\n   ---\n   {% raw %}\n   <div class=\"row\">\n     <div class=\"col-12 col-lg-11 col-xl-8\">\n       <div id=\"page\" class=\"post pb-5 pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4 mb-md-4\">\n       {% if page.dynamic_title %}\n         <h1 class=\"dynamic-title\">{{ page.title }}</h1>\n         <div class=\"post-content\">\n           {{ content }}\n         </div>\n       {% else %}\n         {{ content }}\n       {% endif %}\n       </div> <!-- #page -->\n     </div><!-- .col-12 -->\n   \n     {% include panel.html %}\n   \n   </div>\n   \n   {% if site.disqus.comments and page.comments %}\n   <div class=\"row\">\n     <div class=\"col-12 col-lg-11 col-xl-8\">\n       <div class=\"pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4\">\n   \n       {% include disqus.html %}\n   \n       </div> <!-- .pl-1 pr-1 -->\n     </div> <!-- .col-12 -->\n   </div> <!-- .row -->\n   {% endif %}\n   {% endraw %}\n   ```\n\n   关于Jekyll的更详细用法可以参考[官方网站](http://jekyllcn.com/docs/home/)\n\n   ps: \n\n   - GitHub Page 的（一种）输入是 markdown 文件，输出是 HTML/CSS/JS 文件。\n- 如果 markdown 文件包含代码块，且代码块中包含花括号 { 或 }，尤其是包含 { % 或 { { 符号组合时，GitHub Page 会报错。\n   - 在代码前后添加{ % raw % }和{ % endraw % }（去掉大括号内的空格）\n   \n- 新版本Google Analytics的Tracking ID在管理→媒体资源→数据流中，也可以直接搜索。\n\n   pps:\n\n- 本站已使用**Hexo**重新部署，以上仅供参考。\n\n","source":"_posts/2021-03-01-Getting-Started.md","raw":"---\ntitle: Getting Started：使用Jekyll创建GitHub Pages站点搭建博客（Windows）\nauthor: Shi Daming\ndate: 2021-03-01 17:00:00 +0800\ncategories: jekyll\ntags: [getting started]\npin: true\n---\n### 一、必要组件的安装\n\n需要首先安装以下内容\n\n- **Ruby** - [是一种面向对象]()、命令式、函数式、动态的通用编程语言。Windows下直接下载安装即可[Ruby installer](https://rubyinstaller.org/)。注意，如遇报错，可能需要将安装目录（xxx\\Ruby27-x64\\bin）加入系统环境变量PATH。\n\n- **Bundler** - 是一个官方推荐的Ruby gem包管理软件，可以减少Jekyll的编译错误，和环境依赖相关的bug，相关链接[Bundler](https://bundler.io/)。只需在终端中运行以下两步：\n\n  1.安装bundler\n\n  ```\n  gem install bundler\n  ```\n\n  2.指定源\n\n  ```\n  gem sources 'https://rubygems.org'\n  ```\n\n- **Jekyll** -相当于一个编译工具，安装好jekyll后，你可以通过jekyll创建一个网站模板从而在本地进行预览，而不用上传至Github后再进行查看，此软件包将在之后的步骤中自动安装。\n\n### 二、网站托管（在Github上创建自己的repo）\n\ngithub.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：\n\n- 创建repo\n\n  登陆你的账户后，创建一个新的repo。请务必注意该repo的名字，必须保持格式`<username>.github.io`，其中 `<username） 替换成你的github账户名。\n\n- 把repo clone到本地\n\n  在目录下新建一个index.html的文件,在里面输入任意内容，然后再把代码push送到github上。\n\n- 测试地址\n\n  浏览器里访问<u>https://(username).github.io/</u>,可以发现这个url可以被访问了。\n\n到这里，一个免费且无限流量的Github代码托管仓库就创建完成了。\n\n### 三、基于Jekyll模板建立网站\n\n为了在发布前预览自己的网站，我们需要使用Jekyll，同时它也能为我们提供很多模板。\n\n1. 首先点击前往[jekyll 主题官网](http://jekyllthemes.org/)。\n\n2. 然后选择一个自己喜欢的主题模板，比如[Chirpy](http://jekyllthemes.org/themes/jekyll-theme-chirpy/)。\n\n3. 点击Download下载该模板至repo的本地目录，注意确保根目录下含有Gemfile这个文件。\n\n   <img src=\"/images/QQ截图20210308194033.png\"/>\n\n   注意插入图片时需要将图片文件放入assets文件夹，在md文件中由于路径不一致会无法正常显示，在网页中是正常的，无须担心。\n\n4. 在本地repo目录下打开命令窗口并运行\n\n   ```\n   bundle install\n   ```\n\n   自动安装所有依赖的环境\n\n5. 最后一步，开启测试\n\n   ```\n   bundle exec jekyll serve\n   ```\n\n   成功运行之后，我们就可以通过http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。\n\n### 四、Jekyll目录结构\n\n​\tJekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入[Liquid](https://shopify.github.io/liquid/)脚本的HTML格式存放。内容为markdown或者html。为了撰写自己的博客，需要对模板内容进行修改。\n\nJekyll模板通常包含的目录结构：\n\n```\n    _posts 博客内容\n    _pages 其他需要生成的网页，如About页\n    _layouts 网页排版模板\n    _includes 被模板包含的HTML片段，可在_config.yml中修改位置\n    assets 辅助资源 css布局 js脚本 图片等\n    _data 动态数据\n    _sites 最终生成的静态网页\n    _config.yml 网站的一些配置信息\n    index.html 网站的入口\n```\n\n1. 我们打开根目录下的index.html可以看到：\n\n   ```html\n   ---\n   layout: home\n   # Index page\n   ---\n   ```\n\n2. 上面的home我们到_layouts目录下可以找到：\n\n   ```html\n   ---\n   layout: page\n   # The Home page layout\n   ---\n   \n   {% raw %}\n   {% assign pinned = site.posts | where_exp: \"item\", \"item.pin == true\"  %}\n   {% assign default = site.posts | where_exp: \"item\", \"item.pin != true\"  %}\n   {% assign posts = \"\" | split: \"\" %}\n   ...\n      <div class=\"post-meta text-muted d-flex justify-content-between\">\n   \n         <div>\n           <!-- posted date -->\n           <i class=\"far fa-calendar fa-fw\"></i>\n           {% include timeago.html date=post.date tooltip=true %}\n   \n           <!-- time to read -->\n           <i class=\"far fa-clock fa-fw\"></i>\n           {% include read-time.html content=post.content %}\n   \n           <!-- page views -->\n           {% if site.google_analytics.pv.enabled %}\n           <i class=\"far fa-eye fa-fw\"></i>\n           <span id=\"pv_{{-post.title-}}\" class=\"pageviews\">\n             <i class=\"fas fa-spinner fa-spin fa-fw\"></i>\n           </span>\n           {% endif %}\n         </div>\n   \n         {% if post.pin %}\n         <div class=\"pin\">\n           <i class=\"fas fa-thumbtack fa-fw\"></i>\n           <span>{{ site.data.label.pin_prompt | default: 'Pinned' }}</span>\n         </div>\n         {% endif %}\n   \n       </div> <!-- .post-meta -->\n   \n     </div> <!-- .post-review -->\n   \n   {% endfor %}\n   \n   </div> <!-- #post-list -->\n   \n   {% if paginator.total_pages > 0 %}\n     {% include post-paginator.html %}\n   {% endif %}\n   {% endraw %}\n   ```\n\n   实际上根目录下index.html运行后是home里面的代码内容，1中**html代码段**会填充的上图中的**content**位置。jekyll是将分散在各个目录下的html文件拼接起来运行。\n\n3. 上图的page布局也可以在_layouts目录下找到：\n\n   ```html\n   ---\n   layout: default\n   # The page layout\n   ---\n   {% raw %}\n   <div class=\"row\">\n     <div class=\"col-12 col-lg-11 col-xl-8\">\n       <div id=\"page\" class=\"post pb-5 pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4 mb-md-4\">\n       {% if page.dynamic_title %}\n         <h1 class=\"dynamic-title\">{{ page.title }}</h1>\n         <div class=\"post-content\">\n           {{ content }}\n         </div>\n       {% else %}\n         {{ content }}\n       {% endif %}\n       </div> <!-- #page -->\n     </div><!-- .col-12 -->\n   \n     {% include panel.html %}\n   \n   </div>\n   \n   {% if site.disqus.comments and page.comments %}\n   <div class=\"row\">\n     <div class=\"col-12 col-lg-11 col-xl-8\">\n       <div class=\"pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4\">\n   \n       {% include disqus.html %}\n   \n       </div> <!-- .pl-1 pr-1 -->\n     </div> <!-- .col-12 -->\n   </div> <!-- .row -->\n   {% endif %}\n   {% endraw %}\n   ```\n\n   关于Jekyll的更详细用法可以参考[官方网站](http://jekyllcn.com/docs/home/)\n\n   ps: \n\n   - GitHub Page 的（一种）输入是 markdown 文件，输出是 HTML/CSS/JS 文件。\n- 如果 markdown 文件包含代码块，且代码块中包含花括号 { 或 }，尤其是包含 { % 或 { { 符号组合时，GitHub Page 会报错。\n   - 在代码前后添加{ % raw % }和{ % endraw % }（去掉大括号内的空格）\n   \n- 新版本Google Analytics的Tracking ID在管理→媒体资源→数据流中，也可以直接搜索。\n\n   pps:\n\n- 本站已使用**Hexo**重新部署，以上仅供参考。\n\n","slug":"Getting-Started","published":1,"updated":"2021-08-15T01:47:48.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9e0001y8uxa6tf9bxf","content":"<h3 id=\"一、必要组件的安装\"><a href=\"#一、必要组件的安装\" class=\"headerlink\" title=\"一、必要组件的安装\"></a>一、必要组件的安装</h3><p>需要首先安装以下内容</p>\n<ul>\n<li><p><strong>Ruby</strong> - <a href=\"\">是一种面向对象</a>、命令式、函数式、动态的通用编程语言。Windows下直接下载安装即可<a href=\"https://rubyinstaller.org/\">Ruby installer</a>。注意，如遇报错，可能需要将安装目录（xxx\\Ruby27-x64\\bin）加入系统环境变量PATH。</p>\n</li>\n<li><p><strong>Bundler</strong> - 是一个官方推荐的Ruby gem包管理软件，可以减少Jekyll的编译错误，和环境依赖相关的bug，相关链接<a href=\"https://bundler.io/\">Bundler</a>。只需在终端中运行以下两步：</p>\n<p>1.安装bundler</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">gem <span class=\"hljs-keyword\">install</span> bundler<br></code></pre></td></tr></table></figure>\n<p>2.指定源</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gem</span> sources <span class=\"hljs-string\">&#x27;https://rubygems.org&#x27;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Jekyll</strong> -相当于一个编译工具，安装好jekyll后，你可以通过jekyll创建一个网站模板从而在本地进行预览，而不用上传至Github后再进行查看，此软件包将在之后的步骤中自动安装。</p>\n</li>\n</ul>\n<h3 id=\"二、网站托管（在Github上创建自己的repo）\"><a href=\"#二、网站托管（在Github上创建自己的repo）\" class=\"headerlink\" title=\"二、网站托管（在Github上创建自己的repo）\"></a>二、网站托管（在Github上创建自己的repo）</h3><p>github.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：</p>\n<ul>\n<li><p>创建repo</p>\n<p>登陆你的账户后，创建一个新的repo。请务必注意该repo的名字，必须保持格式<code>&lt;username&gt;.github.io</code>，其中 `&lt;username） 替换成你的github账户名。</p>\n</li>\n<li><p>把repo clone到本地</p>\n<p>在目录下新建一个index.html的文件,在里面输入任意内容，然后再把代码push送到github上。</p>\n</li>\n<li><p>测试地址</p>\n<p>浏览器里访问<u><a href=\"https://(username).github.io/\">https://(username).github.io/</a></u>,可以发现这个url可以被访问了。</p>\n</li>\n</ul>\n<p>到这里，一个免费且无限流量的Github代码托管仓库就创建完成了。</p>\n<h3 id=\"三、基于Jekyll模板建立网站\"><a href=\"#三、基于Jekyll模板建立网站\" class=\"headerlink\" title=\"三、基于Jekyll模板建立网站\"></a>三、基于Jekyll模板建立网站</h3><p>为了在发布前预览自己的网站，我们需要使用Jekyll，同时它也能为我们提供很多模板。</p>\n<ol>\n<li><p>首先点击前往<a href=\"http://jekyllthemes.org/\">jekyll 主题官网</a>。</p>\n</li>\n<li><p>然后选择一个自己喜欢的主题模板，比如<a href=\"http://jekyllthemes.org/themes/jekyll-theme-chirpy/\">Chirpy</a>。</p>\n</li>\n<li><p>点击Download下载该模板至repo的本地目录，注意确保根目录下含有Gemfile这个文件。</p>\n<p><img src=\"/images/QQ截图20210308194033.png\"/></p>\n<p>注意插入图片时需要将图片文件放入assets文件夹，在md文件中由于路径不一致会无法正常显示，在网页中是正常的，无须担心。</p>\n</li>\n<li><p>在本地repo目录下打开命令窗口并运行</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">bundle <span class=\"hljs-keyword\">install</span><br></code></pre></td></tr></table></figure>\n<p>自动安装所有依赖的环境</p>\n</li>\n<li><p>最后一步，开启测试</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">bundle </span>exec <span class=\"hljs-keyword\">jekyll </span>serve<br></code></pre></td></tr></table></figure>\n<p>成功运行之后，我们就可以通过<a href=\"http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。\">http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。</a></p>\n</li>\n</ol>\n<h3 id=\"四、Jekyll目录结构\"><a href=\"#四、Jekyll目录结构\" class=\"headerlink\" title=\"四、Jekyll目录结构\"></a>四、Jekyll目录结构</h3><p>​    Jekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入<a href=\"https://shopify.github.io/liquid/\">Liquid</a>脚本的HTML格式存放。内容为markdown或者html。为了撰写自己的博客，需要对模板内容进行修改。</p>\n<p>Jekyll模板通常包含的目录结构：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-variable\">_posts</span> 博客内容<br><span class=\"hljs-variable\">_pages</span> 其他需要生成的网页，如About页<br><span class=\"hljs-variable\">_layouts</span> 网页排版模板<br><span class=\"hljs-variable\">_includes</span> 被模板包含的HTML片段，可在<span class=\"hljs-variable\">_config</span>.yml中修改位置<br>assets 辅助资源 css布局 js脚本 图片等<br><span class=\"hljs-variable\">_data</span> 动态数据<br><span class=\"hljs-variable\">_sites</span> 最终生成的静态网页<br><span class=\"hljs-variable\">_config</span>.yml 网站的一些配置信息<br>index.html 网站的入口<br></code></pre></td></tr></table></figure>\n<ol>\n<li><p>我们打开根目录下的index.html可以看到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: home<br># Index page<br>---<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>上面的home我们到_layouts目录下可以找到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: page<br># The Home page layout<br>---<br><br>&#123;% raw %&#125;<br>&#123;% assign pinned = site.posts | where_exp: &quot;item&quot;, &quot;item.pin == true&quot;  %&#125;<br>&#123;% assign default = site.posts | where_exp: &quot;item&quot;, &quot;item.pin != true&quot;  %&#125;<br>&#123;% assign posts = &quot;&quot; | split: &quot;&quot; %&#125;<br>...<br>   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post-meta text-muted d-flex justify-content-between&quot;</span>&gt;</span><br><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- posted date --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-calendar fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        &#123;% include timeago.html date=post.date tooltip=true %&#125;<br><br>        <span class=\"hljs-comment\">&lt;!-- time to read --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-clock fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        &#123;% include read-time.html content=post.content %&#125;<br><br>        <span class=\"hljs-comment\">&lt;!-- page views --&gt;</span><br>        &#123;% if site.google_analytics.pv.enabled %&#125;<br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-eye fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;pv_&#123;&#123;-post.title-&#125;&#125;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pageviews&quot;</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;fas fa-spinner fa-spin fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>        &#123;% endif %&#125;<br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>      &#123;% if post.pin %&#125;<br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pin&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;fas fa-thumbtack fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; site.data.label.pin_prompt | default: &#x27;Pinned&#x27; &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>      &#123;% endif %&#125;<br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .post-meta --&gt;</span><br><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .post-review --&gt;</span><br><br>&#123;% endfor %&#125;<br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- #post-list --&gt;</span><br><br>&#123;% if paginator.total_pages &gt; 0 %&#125;<br>  &#123;% include post-paginator.html %&#125;<br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure>\n<p>实际上根目录下index.html运行后是home里面的代码内容，1中<strong>html代码段</strong>会填充的上图中的<strong>content</strong>位置。jekyll是将分散在各个目录下的html文件拼接起来运行。</p>\n</li>\n<li><p>上图的page布局也可以在_layouts目录下找到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: default<br># The page layout<br>---<br>&#123;% raw %&#125;<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;row&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;page&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post pb-5 pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4 mb-md-4&quot;</span>&gt;</span><br>    &#123;% if page.dynamic_title %&#125;<br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;dynamic-title&quot;</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post-content&quot;</span>&gt;</span><br>        &#123;&#123; content &#125;&#125;<br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    &#123;% else %&#125;<br>      &#123;&#123; content &#125;&#125;<br>    &#123;% endif %&#125;<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- #page --&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- .col-12 --&gt;</span><br><br>  &#123;% include panel.html %&#125;<br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>&#123;% if site.disqus.comments and page.comments %&#125;<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;row&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4&quot;</span>&gt;</span><br><br>    &#123;% include disqus.html %&#125;<br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .pl-1 pr-1 --&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .col-12 --&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .row --&gt;</span><br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure>\n<p>关于Jekyll的更详细用法可以参考<a href=\"http://jekyllcn.com/docs/home/\">官方网站</a></p>\n<p>ps: </p>\n<ul>\n<li>GitHub Page 的（一种）输入是 markdown 文件，输出是 HTML/CSS/JS 文件。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>如果 markdown 文件包含代码块，且代码块中包含花括号 { 或 }，尤其是包含 { % 或 { { 符号组合时，GitHub Page 会报错。</p>\n<ul>\n<li>在代码前后添加{ % raw % }和{ % endraw % }（去掉大括号内的空格）</li>\n</ul>\n</li>\n<li><p>新版本Google Analytics的Tracking ID在管理→媒体资源→数据流中，也可以直接搜索。</p>\n<p> pps:</p>\n</li>\n<li><p>本站已使用<strong>Hexo</strong>重新部署，以上仅供参考。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、必要组件的安装\"><a href=\"#一、必要组件的安装\" class=\"headerlink\" title=\"一、必要组件的安装\"></a>一、必要组件的安装</h3><p>需要首先安装以下内容</p>\n<ul>\n<li><p><strong>Ruby</strong> - <a href=\"\">是一种面向对象</a>、命令式、函数式、动态的通用编程语言。Windows下直接下载安装即可<a href=\"https://rubyinstaller.org/\">Ruby installer</a>。注意，如遇报错，可能需要将安装目录（xxx\\Ruby27-x64\\bin）加入系统环境变量PATH。</p>\n</li>\n<li><p><strong>Bundler</strong> - 是一个官方推荐的Ruby gem包管理软件，可以减少Jekyll的编译错误，和环境依赖相关的bug，相关链接<a href=\"https://bundler.io/\">Bundler</a>。只需在终端中运行以下两步：</p>\n<p>1.安装bundler</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">gem <span class=\"hljs-keyword\">install</span> bundler<br></code></pre></td></tr></table></figure>\n<p>2.指定源</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">gem</span> sources <span class=\"hljs-string\">&#x27;https://rubygems.org&#x27;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Jekyll</strong> -相当于一个编译工具，安装好jekyll后，你可以通过jekyll创建一个网站模板从而在本地进行预览，而不用上传至Github后再进行查看，此软件包将在之后的步骤中自动安装。</p>\n</li>\n</ul>\n<h3 id=\"二、网站托管（在Github上创建自己的repo）\"><a href=\"#二、网站托管（在Github上创建自己的repo）\" class=\"headerlink\" title=\"二、网站托管（在Github上创建自己的repo）\"></a>二、网站托管（在Github上创建自己的repo）</h3><p>github.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：</p>\n<ul>\n<li><p>创建repo</p>\n<p>登陆你的账户后，创建一个新的repo。请务必注意该repo的名字，必须保持格式<code>&lt;username&gt;.github.io</code>，其中 `&lt;username） 替换成你的github账户名。</p>\n</li>\n<li><p>把repo clone到本地</p>\n<p>在目录下新建一个index.html的文件,在里面输入任意内容，然后再把代码push送到github上。</p>\n</li>\n<li><p>测试地址</p>\n<p>浏览器里访问<u><a href=\"https://(username).github.io/\">https://(username).github.io/</a></u>,可以发现这个url可以被访问了。</p>\n</li>\n</ul>\n<p>到这里，一个免费且无限流量的Github代码托管仓库就创建完成了。</p>\n<h3 id=\"三、基于Jekyll模板建立网站\"><a href=\"#三、基于Jekyll模板建立网站\" class=\"headerlink\" title=\"三、基于Jekyll模板建立网站\"></a>三、基于Jekyll模板建立网站</h3><p>为了在发布前预览自己的网站，我们需要使用Jekyll，同时它也能为我们提供很多模板。</p>\n<ol>\n<li><p>首先点击前往<a href=\"http://jekyllthemes.org/\">jekyll 主题官网</a>。</p>\n</li>\n<li><p>然后选择一个自己喜欢的主题模板，比如<a href=\"http://jekyllthemes.org/themes/jekyll-theme-chirpy/\">Chirpy</a>。</p>\n</li>\n<li><p>点击Download下载该模板至repo的本地目录，注意确保根目录下含有Gemfile这个文件。</p>\n<p><img src=\"/images/QQ截图20210308194033.png\"/></p>\n<p>注意插入图片时需要将图片文件放入assets文件夹，在md文件中由于路径不一致会无法正常显示，在网页中是正常的，无须担心。</p>\n</li>\n<li><p>在本地repo目录下打开命令窗口并运行</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">bundle <span class=\"hljs-keyword\">install</span><br></code></pre></td></tr></table></figure>\n<p>自动安装所有依赖的环境</p>\n</li>\n<li><p>最后一步，开启测试</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">bundle </span>exec <span class=\"hljs-keyword\">jekyll </span>serve<br></code></pre></td></tr></table></figure>\n<p>成功运行之后，我们就可以通过<a href=\"http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。\">http://127.0.0.1:4000/在本地访问创建的网站了。此时可以随时更改网站内容，并能实现自动实时更新。</a></p>\n</li>\n</ol>\n<h3 id=\"四、Jekyll目录结构\"><a href=\"#四、Jekyll目录结构\" class=\"headerlink\" title=\"四、Jekyll目录结构\"></a>四、Jekyll目录结构</h3><p>​    Jekyll使用Ruby脚本根据模板生成静态网页，实现了内容与排版的分离。模板以嵌入<a href=\"https://shopify.github.io/liquid/\">Liquid</a>脚本的HTML格式存放。内容为markdown或者html。为了撰写自己的博客，需要对模板内容进行修改。</p>\n<p>Jekyll模板通常包含的目录结构：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-variable\">_posts</span> 博客内容<br><span class=\"hljs-variable\">_pages</span> 其他需要生成的网页，如About页<br><span class=\"hljs-variable\">_layouts</span> 网页排版模板<br><span class=\"hljs-variable\">_includes</span> 被模板包含的HTML片段，可在<span class=\"hljs-variable\">_config</span>.yml中修改位置<br>assets 辅助资源 css布局 js脚本 图片等<br><span class=\"hljs-variable\">_data</span> 动态数据<br><span class=\"hljs-variable\">_sites</span> 最终生成的静态网页<br><span class=\"hljs-variable\">_config</span>.yml 网站的一些配置信息<br>index.html 网站的入口<br></code></pre></td></tr></table></figure>\n<ol>\n<li><p>我们打开根目录下的index.html可以看到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: home<br># Index page<br>---<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>上面的home我们到_layouts目录下可以找到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: page<br># The Home page layout<br>---<br><br>&#123;% raw %&#125;<br>&#123;% assign pinned = site.posts | where_exp: &quot;item&quot;, &quot;item.pin == true&quot;  %&#125;<br>&#123;% assign default = site.posts | where_exp: &quot;item&quot;, &quot;item.pin != true&quot;  %&#125;<br>&#123;% assign posts = &quot;&quot; | split: &quot;&quot; %&#125;<br>...<br>   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post-meta text-muted d-flex justify-content-between&quot;</span>&gt;</span><br><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-comment\">&lt;!-- posted date --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-calendar fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        &#123;% include timeago.html date=post.date tooltip=true %&#125;<br><br>        <span class=\"hljs-comment\">&lt;!-- time to read --&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-clock fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        &#123;% include read-time.html content=post.content %&#125;<br><br>        <span class=\"hljs-comment\">&lt;!-- page views --&gt;</span><br>        &#123;% if site.google_analytics.pv.enabled %&#125;<br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;far fa-eye fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;pv_&#123;&#123;-post.title-&#125;&#125;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pageviews&quot;</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;fas fa-spinner fa-spin fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>        &#123;% endif %&#125;<br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>      &#123;% if post.pin %&#125;<br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pin&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;fas fa-thumbtack fa-fw&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; site.data.label.pin_prompt | default: &#x27;Pinned&#x27; &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>      &#123;% endif %&#125;<br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .post-meta --&gt;</span><br><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .post-review --&gt;</span><br><br>&#123;% endfor %&#125;<br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- #post-list --&gt;</span><br><br>&#123;% if paginator.total_pages &gt; 0 %&#125;<br>  &#123;% include post-paginator.html %&#125;<br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure>\n<p>实际上根目录下index.html运行后是home里面的代码内容，1中<strong>html代码段</strong>会填充的上图中的<strong>content</strong>位置。jekyll是将分散在各个目录下的html文件拼接起来运行。</p>\n</li>\n<li><p>上图的page布局也可以在_layouts目录下找到：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">---<br>layout: default<br># The page layout<br>---<br>&#123;% raw %&#125;<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;row&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;page&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post pb-5 pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4 mb-md-4&quot;</span>&gt;</span><br>    &#123;% if page.dynamic_title %&#125;<br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;dynamic-title&quot;</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;post-content&quot;</span>&gt;</span><br>        &#123;&#123; content &#125;&#125;<br>      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    &#123;% else %&#125;<br>      &#123;&#123; content &#125;&#125;<br>    &#123;% endif %&#125;<br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- #page --&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- .col-12 --&gt;</span><br><br>  &#123;% include panel.html %&#125;<br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>&#123;% if site.disqus.comments and page.comments %&#125;<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;row&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;col-12 col-lg-11 col-xl-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4&quot;</span>&gt;</span><br><br>    &#123;% include disqus.html %&#125;<br><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .pl-1 pr-1 --&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .col-12 --&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- .row --&gt;</span><br>&#123;% endif %&#125;<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure>\n<p>关于Jekyll的更详细用法可以参考<a href=\"http://jekyllcn.com/docs/home/\">官方网站</a></p>\n<p>ps: </p>\n<ul>\n<li>GitHub Page 的（一种）输入是 markdown 文件，输出是 HTML/CSS/JS 文件。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>如果 markdown 文件包含代码块，且代码块中包含花括号 { 或 }，尤其是包含 { % 或 { { 符号组合时，GitHub Page 会报错。</p>\n<ul>\n<li>在代码前后添加{ % raw % }和{ % endraw % }（去掉大括号内的空格）</li>\n</ul>\n</li>\n<li><p>新版本Google Analytics的Tracking ID在管理→媒体资源→数据流中，也可以直接搜索。</p>\n<p> pps:</p>\n</li>\n<li><p>本站已使用<strong>Hexo</strong>重新部署，以上仅供参考。</p>\n</li>\n</ul>\n"},{"title":"python中的lambda和map函数","author":"Shi Daming","date":"2021-05-14T15:00:00.000Z","_content":"\n\n### 1、lambda函数\n\n他就是个没有名字的函数，比如匿名信这种。我们能在某一函数参数条件中直接调用他、或者借用其返回的实体构成新的函数名 如下。\n\n比如说  lambda x,y: x+y  就是说我的函数输入x,y，返回x+y\n\n```python\ny=lambda a,b,c:a+b+c\nprint('\\n',y(1,2,3))\n```\n\n\n结果为6\n\n仔细看看，是不是y成为了新的函数名？！\n\n \n\n### 2、map函数\n\nmap就是映射的意思，他肯定是将两种东西结合映射为某一个结果。他就是接收一个函数function和一个list列表，并通过把函数f依次作用在list的每一个元素，从而得到一个新的list返回（py3中返回一个map对象，用list函数转换一下即可）\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\nX=input().strip().split()\nN=list(map(int, X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n\n注意哈这个X必须是列表，int则表示函数了，当然也可以其他函数命名\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\ndef ex(c):\n    return int(c)\n        \nX=input().strip().split()\nN=list(map(ex, X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n\n注意他是自动迭代地对X列表的每一个元素操作，也就是说map自带迭代器！\n\n \n\n### 3、map函数和lambda函数结合\n\n显然只用改变map函数中的函数体就可以，无非就是函数体没有了实名，将lambda放于map的参数条件之中\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\ndef ex(c):\n    return int(c)\n        \n##X=input().strip().split()\n##N=list(map(ex, X))[0]\n##\n##for i in range(1, N):\n##\tprint(fib_recur(i),end=' ')\n\nX=input().strip().split()\nN=list(map(lambda a:int(a), X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n在本代码list(map(lambda a:int(a), X)) 这一句只用注意两个点：\n\n1） lambda参数只能是一个参数标量，因为map是自动对列表X的元素迭代的\n\n2）X为一维情况，所以他的每一个元素是标量\n\n针对X为二维情况，博主暂时没想到好的解决办法，只能是X[2]来选择其中的一个向量列表。\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\nX=[[1,2,3],[2,4,6],[3,6,9]]\nN=list(map(lambda a:int(a), X[2]))[2]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n————————————————\n版权声明：本文为CSDN博主「lamusique」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/lamusique/article/details/89162363","source":"_posts/2021-05-14-python中的lambda和map函数.md","raw":"---\ntitle: python中的lambda和map函数\nauthor: Shi Daming\ndate: 2021-05-14 23:00:00 +0800\ncategories: python\ntags: [python, lambda, map]\n---\n\n\n### 1、lambda函数\n\n他就是个没有名字的函数，比如匿名信这种。我们能在某一函数参数条件中直接调用他、或者借用其返回的实体构成新的函数名 如下。\n\n比如说  lambda x,y: x+y  就是说我的函数输入x,y，返回x+y\n\n```python\ny=lambda a,b,c:a+b+c\nprint('\\n',y(1,2,3))\n```\n\n\n结果为6\n\n仔细看看，是不是y成为了新的函数名？！\n\n \n\n### 2、map函数\n\nmap就是映射的意思，他肯定是将两种东西结合映射为某一个结果。他就是接收一个函数function和一个list列表，并通过把函数f依次作用在list的每一个元素，从而得到一个新的list返回（py3中返回一个map对象，用list函数转换一下即可）\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\nX=input().strip().split()\nN=list(map(int, X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n\n注意哈这个X必须是列表，int则表示函数了，当然也可以其他函数命名\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\ndef ex(c):\n    return int(c)\n        \nX=input().strip().split()\nN=list(map(ex, X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n\n注意他是自动迭代地对X列表的每一个元素操作，也就是说map自带迭代器！\n\n \n\n### 3、map函数和lambda函数结合\n\n显然只用改变map函数中的函数体就可以，无非就是函数体没有了实名，将lambda放于map的参数条件之中\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\ndef ex(c):\n    return int(c)\n        \n##X=input().strip().split()\n##N=list(map(ex, X))[0]\n##\n##for i in range(1, N):\n##\tprint(fib_recur(i),end=' ')\n\nX=input().strip().split()\nN=list(map(lambda a:int(a), X))[0]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n在本代码list(map(lambda a:int(a), X)) 这一句只用注意两个点：\n\n1） lambda参数只能是一个参数标量，因为map是自动对列表X的元素迭代的\n\n2）X为一维情况，所以他的每一个元素是标量\n\n针对X为二维情况，博主暂时没想到好的解决办法，只能是X[2]来选择其中的一个向量列表。\n\n```python\ndef fib_recur(n):\n    if n<=1:\n        return n\n    else:\n        return fib_recur(n-1)+fib_recur(n-2)\n\n\nX=[[1,2,3],[2,4,6],[3,6,9]]\nN=list(map(lambda a:int(a), X[2]))[2]\n\nfor i in range(1, N):\n    print(fib_recur(i),end=' ')\n```\n\n————————————————\n版权声明：本文为CSDN博主「lamusique」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/lamusique/article/details/89162363","slug":"python中的lambda和map函数","published":1,"updated":"2021-08-15T01:47:48.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9h0002y8uxciro2pts","content":"<h3 id=\"1、lambda函数\"><a href=\"#1、lambda函数\" class=\"headerlink\" title=\"1、lambda函数\"></a>1、lambda函数</h3><p>他就是个没有名字的函数，比如匿名信这种。我们能在某一函数参数条件中直接调用他、或者借用其返回的实体构成新的函数名 如下。</p>\n<p>比如说  lambda x,y: x+y  就是说我的函数输入x,y，返回x+y</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">y=<span class=\"hljs-keyword\">lambda</span> a,b,c:a+b+c<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>,y(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>))<br></code></pre></td></tr></table></figure>\n<p>结果为6</p>\n<p>仔细看看，是不是y成为了新的函数名？！</p>\n<h3 id=\"2、map函数\"><a href=\"#2、map函数\" class=\"headerlink\" title=\"2、map函数\"></a>2、map函数</h3><p>map就是映射的意思，他肯定是将两种东西结合映射为某一个结果。他就是接收一个函数function和一个list列表，并通过把函数f依次作用在list的每一个元素，从而得到一个新的list返回（py3中返回一个map对象，用list函数转换一下即可）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>注意哈这个X必须是列表，int则表示函数了，当然也可以其他函数命名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ex</span>(<span class=\"hljs-params\">c</span>):</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(c)<br>        <br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(ex, X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>注意他是自动迭代地对X列表的每一个元素操作，也就是说map自带迭代器！</p>\n<h3 id=\"3、map函数和lambda函数结合\"><a href=\"#3、map函数和lambda函数结合\" class=\"headerlink\" title=\"3、map函数和lambda函数结合\"></a>3、map函数和lambda函数结合</h3><p>显然只用改变map函数中的函数体就可以，无非就是函数体没有了实名，将lambda放于map的参数条件之中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ex</span>(<span class=\"hljs-params\">c</span>):</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(c)<br>        <br><span class=\"hljs-comment\">##X=input().strip().split()</span><br><span class=\"hljs-comment\">##N=list(map(ex, X))[0]</span><br><span class=\"hljs-comment\">##</span><br><span class=\"hljs-comment\">##for i in range(1, N):</span><br><span class=\"hljs-comment\">##\tprint(fib_recur(i),end=&#x27; &#x27;)</span><br><br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-keyword\">lambda</span> a:<span class=\"hljs-built_in\">int</span>(a), X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>在本代码list(map(lambda a:int(a), X)) 这一句只用注意两个点：</p>\n<p>1） lambda参数只能是一个参数标量，因为map是自动对列表X的元素迭代的</p>\n<p>2）X为一维情况，所以他的每一个元素是标量</p>\n<p>针对X为二维情况，博主暂时没想到好的解决办法，只能是X[2]来选择其中的一个向量列表。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br>X=[[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>],[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>],[<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">9</span>]]<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-keyword\">lambda</span> a:<span class=\"hljs-built_in\">int</span>(a), X[<span class=\"hljs-number\">2</span>]))[<span class=\"hljs-number\">2</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>————————————————<br>版权声明：本文为CSDN博主「lamusique」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/lamusique/article/details/89162363\">https://blog.csdn.net/lamusique/article/details/89162363</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、lambda函数\"><a href=\"#1、lambda函数\" class=\"headerlink\" title=\"1、lambda函数\"></a>1、lambda函数</h3><p>他就是个没有名字的函数，比如匿名信这种。我们能在某一函数参数条件中直接调用他、或者借用其返回的实体构成新的函数名 如下。</p>\n<p>比如说  lambda x,y: x+y  就是说我的函数输入x,y，返回x+y</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">y=<span class=\"hljs-keyword\">lambda</span> a,b,c:a+b+c<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>,y(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>))<br></code></pre></td></tr></table></figure>\n<p>结果为6</p>\n<p>仔细看看，是不是y成为了新的函数名？！</p>\n<h3 id=\"2、map函数\"><a href=\"#2、map函数\" class=\"headerlink\" title=\"2、map函数\"></a>2、map函数</h3><p>map就是映射的意思，他肯定是将两种东西结合映射为某一个结果。他就是接收一个函数function和一个list列表，并通过把函数f依次作用在list的每一个元素，从而得到一个新的list返回（py3中返回一个map对象，用list函数转换一下即可）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>注意哈这个X必须是列表，int则表示函数了，当然也可以其他函数命名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ex</span>(<span class=\"hljs-params\">c</span>):</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(c)<br>        <br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(ex, X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>注意他是自动迭代地对X列表的每一个元素操作，也就是说map自带迭代器！</p>\n<h3 id=\"3、map函数和lambda函数结合\"><a href=\"#3、map函数和lambda函数结合\" class=\"headerlink\" title=\"3、map函数和lambda函数结合\"></a>3、map函数和lambda函数结合</h3><p>显然只用改变map函数中的函数体就可以，无非就是函数体没有了实名，将lambda放于map的参数条件之中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ex</span>(<span class=\"hljs-params\">c</span>):</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(c)<br>        <br><span class=\"hljs-comment\">##X=input().strip().split()</span><br><span class=\"hljs-comment\">##N=list(map(ex, X))[0]</span><br><span class=\"hljs-comment\">##</span><br><span class=\"hljs-comment\">##for i in range(1, N):</span><br><span class=\"hljs-comment\">##\tprint(fib_recur(i),end=&#x27; &#x27;)</span><br><br>X=<span class=\"hljs-built_in\">input</span>().strip().split()<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-keyword\">lambda</span> a:<span class=\"hljs-built_in\">int</span>(a), X))[<span class=\"hljs-number\">0</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>在本代码list(map(lambda a:int(a), X)) 这一句只用注意两个点：</p>\n<p>1） lambda参数只能是一个参数标量，因为map是自动对列表X的元素迭代的</p>\n<p>2）X为一维情况，所以他的每一个元素是标量</p>\n<p>针对X为二维情况，博主暂时没想到好的解决办法，只能是X[2]来选择其中的一个向量列表。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">fib_recur</span>(<span class=\"hljs-params\">n</span>):</span><br>    <span class=\"hljs-keyword\">if</span> n&lt;=<span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> n<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-keyword\">return</span> fib_recur(n-<span class=\"hljs-number\">1</span>)+fib_recur(n-<span class=\"hljs-number\">2</span>)<br><br><br>X=[[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>],[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>],[<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">9</span>]]<br>N=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-keyword\">lambda</span> a:<span class=\"hljs-built_in\">int</span>(a), X[<span class=\"hljs-number\">2</span>]))[<span class=\"hljs-number\">2</span>]<br><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N):<br>    <span class=\"hljs-built_in\">print</span>(fib_recur(i),end=<span class=\"hljs-string\">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>————————————————<br>版权声明：本文为CSDN博主「lamusique」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/lamusique/article/details/89162363\">https://blog.csdn.net/lamusique/article/details/89162363</a></p>\n"},{"title":"Matlab作图：设置曲面颜色及范围函数 caxis","author":"Shi Daming","date":"2021-04-06T09:00:00.000Z","pin":true,"_content":"\n### 语法\n\n```\ncaxis(limits)\ncaxis('auto')\ncaxis('manual')\ncaxis(target,___)\ncl = caxis\n```\n\n### 说明\n\n`caxis(limits)` 设置当前坐标区的颜色图范围。`limits` 是 `[cmin cmax]` 形式的二元素向量。[颜色图索引数组](https://ww2.mathworks.cn/help/matlab/ref/caxis.html#mw_262386a0-0173-40a5-b123-7b5834c1d396)中小于或等于 `cmin` 的所有值映射到颜色图的第一行。大于或等于 `cmax` 的所有值映射到颜色图的最后一行。介于 `cmin` 和 `cmax` 之间的所有值以线性方式映射到颜色图的中间各行。\n\n\n\n**注意**\n\n`caxis` 函数只影响 `CDataMapping` 属性设置为 `'scaled'` 的图形对象，不影响使用真彩色或 `CDataMapping` 设置为 `'direct'` 的图形对象。\n\n`caxis('auto')` 在颜色图索引数组中的值更改时启用自动范围更新。这是默认行为。`caxis auto` 命令是此语法的另一种形式。\n\n`caxis('manual')` 禁用自动范围更新。`caxis manual` 命令是此语法的另一种形式。\n\n`caxis(target,___)` 为特定坐标区或图设置颜色图范围。指定 `target` 作为上述任何语法中的第一个输入参数。\n\n`cl = caxis` 返回当前坐标区或图的当前颜色图范围。\n\n### 示例\n\n#### 提高下限 \n\n绘制带有颜色栏的抛物面。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ = X.^2 + Y.^2;\nsurf(Z);\ncolorbar\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_01_zh_CN.png)\n\n获取当前颜色范围。\n\n```\nlim = caxis\nlim = 1×2\n\n     0    50\n```\n\n将下限提高到 `20`。请注意，小于或等于 `20` 的所有 `Z` 值映射到第一种颜色。\n\n```\ncaxis([20 50])\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_02_zh_CN.png)\n\n#### 保持多个曲面图的颜色范围不变 \n\n创建两个垂直偏移的抛物面。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ1 = X.^2 + Y.^2;\nZ2 = Z1 + 50;\n```\n\n绘制第一个抛物面。添加颜色栏，然后保持第二个抛物面的坐标区不变。\n\n```\nsurf(X,Y,Z1);\ncolorbar\nhold on\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_01_zh_CN.png)\n\n使用 `'manual'` 选项保持当前颜色范围不变。然后绘制第二个抛物面。\n\n```\ncaxis('manual');\nsurf(X,Y,Z2);\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_02_zh_CN.png)\n\n#### 指定曲面图的颜色图颜色 \n\n通过包含第四个矩阵输入 `C` 来指定曲面图的颜色。曲面图使用 `Z` 表示高度，`C` 表示颜色。使用*颜色图*指定颜色，该颜色图使用单个数字表示色谱上的颜色。使用颜色图时，`C` 与 `Z` 大小相同。向图中添加颜色栏以显示 `C` 中的数据值如何对应于颜色图中的颜色。\n\n```\n[X,Y] = meshgrid(1:0.5:10,1:20);\nZ = sin(X) + cos(Y);\nC = X.*Y;\nsurf(X,Y,Z,C)\ncolorbar\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/specifycolorsforsurfaceplotexample_01_zh_CN.png)\n\n#### 为曲面图指定真彩色\n\n通过包含第四个矩阵输入 `CO` 来指定曲面图的颜色。曲面图使用 `Z` 表示高度，`CO` 表示颜色。使用*真彩色*指定颜色，真彩色使用三个数字（即三元组）表示所有可能的颜色。使用真彩色时，如果 `Z` 为 `m`×`n`，则 `CO` 为 `m`×`n`×3。数组的第一页指示每种颜色的红色分量；第二页指示绿色分量；第三页指示蓝色分量。\n\n```\n[X,Y,Z] = peaks(25);\nCO(:,:,1) = zeros(25); % red\nCO(:,:,2) = ones(25).*linspace(0.5,0.6,25); % green\nCO(:,:,3) = ones(25).*linspace(0,1,25); % blue\nsurf(X,Y,Z,CO)\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/surfaceplotwithtruecolorsexample_01_zh_CN.png)\n\n#### 修改曲面图的外观 \n\n通过指定以 `0.5` 为值的 `FaceAlpha` 名称-值对组，来创建半透明曲面。要允许进一步修改，请将曲面对象赋给变量 `s`。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ = Y.*sin(X) - X.*cos(Y);\ns = surf(X,Y,Z,'FaceAlpha',0.5)\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_01_zh_CN.png)\n\n```\ns = \n  Surface with properties:\n\n       EdgeColor: [0 0 0]\n       LineStyle: '-'\n       FaceColor: 'flat'\n    FaceLighting: 'flat'\n       FaceAlpha: 0.5000\n           XData: [21x21 double]\n           YData: [21x21 double]\n           ZData: [21x21 double]\n           CData: [21x21 double]\n\n  Show all properties\n```\n\n在创建曲面对象之后可使用 `s` 访问并修改其属性。例如，通过设置 `EdgeColor` 属性来隐藏边。\n\n```\ns.EdgeColor = 'none';\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_02_zh_CN.png)","source":"_posts/2021-04-06-Matlab设置颜色图范围.md","raw":"---\ntitle: Matlab作图：设置曲面颜色及范围函数 caxis\nauthor: Shi Daming\ndate: 2021-04-06 17:00:00 +0800\ncategories: Matlab\ntags: [Matlab, surf, color]\npin: true\n---\n\n### 语法\n\n```\ncaxis(limits)\ncaxis('auto')\ncaxis('manual')\ncaxis(target,___)\ncl = caxis\n```\n\n### 说明\n\n`caxis(limits)` 设置当前坐标区的颜色图范围。`limits` 是 `[cmin cmax]` 形式的二元素向量。[颜色图索引数组](https://ww2.mathworks.cn/help/matlab/ref/caxis.html#mw_262386a0-0173-40a5-b123-7b5834c1d396)中小于或等于 `cmin` 的所有值映射到颜色图的第一行。大于或等于 `cmax` 的所有值映射到颜色图的最后一行。介于 `cmin` 和 `cmax` 之间的所有值以线性方式映射到颜色图的中间各行。\n\n\n\n**注意**\n\n`caxis` 函数只影响 `CDataMapping` 属性设置为 `'scaled'` 的图形对象，不影响使用真彩色或 `CDataMapping` 设置为 `'direct'` 的图形对象。\n\n`caxis('auto')` 在颜色图索引数组中的值更改时启用自动范围更新。这是默认行为。`caxis auto` 命令是此语法的另一种形式。\n\n`caxis('manual')` 禁用自动范围更新。`caxis manual` 命令是此语法的另一种形式。\n\n`caxis(target,___)` 为特定坐标区或图设置颜色图范围。指定 `target` 作为上述任何语法中的第一个输入参数。\n\n`cl = caxis` 返回当前坐标区或图的当前颜色图范围。\n\n### 示例\n\n#### 提高下限 \n\n绘制带有颜色栏的抛物面。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ = X.^2 + Y.^2;\nsurf(Z);\ncolorbar\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_01_zh_CN.png)\n\n获取当前颜色范围。\n\n```\nlim = caxis\nlim = 1×2\n\n     0    50\n```\n\n将下限提高到 `20`。请注意，小于或等于 `20` 的所有 `Z` 值映射到第一种颜色。\n\n```\ncaxis([20 50])\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_02_zh_CN.png)\n\n#### 保持多个曲面图的颜色范围不变 \n\n创建两个垂直偏移的抛物面。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ1 = X.^2 + Y.^2;\nZ2 = Z1 + 50;\n```\n\n绘制第一个抛物面。添加颜色栏，然后保持第二个抛物面的坐标区不变。\n\n```\nsurf(X,Y,Z1);\ncolorbar\nhold on\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_01_zh_CN.png)\n\n使用 `'manual'` 选项保持当前颜色范围不变。然后绘制第二个抛物面。\n\n```\ncaxis('manual');\nsurf(X,Y,Z2);\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_02_zh_CN.png)\n\n#### 指定曲面图的颜色图颜色 \n\n通过包含第四个矩阵输入 `C` 来指定曲面图的颜色。曲面图使用 `Z` 表示高度，`C` 表示颜色。使用*颜色图*指定颜色，该颜色图使用单个数字表示色谱上的颜色。使用颜色图时，`C` 与 `Z` 大小相同。向图中添加颜色栏以显示 `C` 中的数据值如何对应于颜色图中的颜色。\n\n```\n[X,Y] = meshgrid(1:0.5:10,1:20);\nZ = sin(X) + cos(Y);\nC = X.*Y;\nsurf(X,Y,Z,C)\ncolorbar\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/specifycolorsforsurfaceplotexample_01_zh_CN.png)\n\n#### 为曲面图指定真彩色\n\n通过包含第四个矩阵输入 `CO` 来指定曲面图的颜色。曲面图使用 `Z` 表示高度，`CO` 表示颜色。使用*真彩色*指定颜色，真彩色使用三个数字（即三元组）表示所有可能的颜色。使用真彩色时，如果 `Z` 为 `m`×`n`，则 `CO` 为 `m`×`n`×3。数组的第一页指示每种颜色的红色分量；第二页指示绿色分量；第三页指示蓝色分量。\n\n```\n[X,Y,Z] = peaks(25);\nCO(:,:,1) = zeros(25); % red\nCO(:,:,2) = ones(25).*linspace(0.5,0.6,25); % green\nCO(:,:,3) = ones(25).*linspace(0,1,25); % blue\nsurf(X,Y,Z,CO)\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/surfaceplotwithtruecolorsexample_01_zh_CN.png)\n\n#### 修改曲面图的外观 \n\n通过指定以 `0.5` 为值的 `FaceAlpha` 名称-值对组，来创建半透明曲面。要允许进一步修改，请将曲面对象赋给变量 `s`。\n\n```\n[X,Y] = meshgrid(-5:.5:5);\nZ = Y.*sin(X) - X.*cos(Y);\ns = surf(X,Y,Z,'FaceAlpha',0.5)\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_01_zh_CN.png)\n\n```\ns = \n  Surface with properties:\n\n       EdgeColor: [0 0 0]\n       LineStyle: '-'\n       FaceColor: 'flat'\n    FaceLighting: 'flat'\n       FaceAlpha: 0.5000\n           XData: [21x21 double]\n           YData: [21x21 double]\n           ZData: [21x21 double]\n           CData: [21x21 double]\n\n  Show all properties\n```\n\n在创建曲面对象之后可使用 `s` 访问并修改其属性。例如，通过设置 `EdgeColor` 属性来隐藏边。\n\n```\ns.EdgeColor = 'none';\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_02_zh_CN.png)","slug":"Matlab设置颜色图范围","published":1,"updated":"2021-08-15T01:47:48.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9l0005y8ux2iktfdzi","content":"<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(limits)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;auto&#x27;</span>)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;manual&#x27;</span>)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(target,___)</span></span><br>cl = caxis<br></code></pre></td></tr></table></figure>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p><code>caxis(limits)</code> 设置当前坐标区的颜色图范围。<code>limits</code> 是 <code>[cmin cmax]</code> 形式的二元素向量。<a href=\"https://ww2.mathworks.cn/help/matlab/ref/caxis.html#mw_262386a0-0173-40a5-b123-7b5834c1d396\">颜色图索引数组</a>中小于或等于 <code>cmin</code> 的所有值映射到颜色图的第一行。大于或等于 <code>cmax</code> 的所有值映射到颜色图的最后一行。介于 <code>cmin</code> 和 <code>cmax</code> 之间的所有值以线性方式映射到颜色图的中间各行。</p>\n<p><strong>注意</strong></p>\n<p><code>caxis</code> 函数只影响 <code>CDataMapping</code> 属性设置为 <code>&#39;scaled&#39;</code> 的图形对象，不影响使用真彩色或 <code>CDataMapping</code> 设置为 <code>&#39;direct&#39;</code> 的图形对象。</p>\n<p><code>caxis(&#39;auto&#39;)</code> 在颜色图索引数组中的值更改时启用自动范围更新。这是默认行为。<code>caxis auto</code> 命令是此语法的另一种形式。</p>\n<p><code>caxis(&#39;manual&#39;)</code> 禁用自动范围更新。<code>caxis manual</code> 命令是此语法的另一种形式。</p>\n<p><code>caxis(target,___)</code> 为特定坐标区或图设置颜色图范围。指定 <code>target</code> 作为上述任何语法中的第一个输入参数。</p>\n<p><code>cl = caxis</code> 返回当前坐标区或图的当前颜色图范围。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"提高下限\"><a href=\"#提高下限\" class=\"headerlink\" title=\"提高下限\"></a>提高下限</h4><p>绘制带有颜色栏的抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span> = <span class=\"hljs-keyword\">X</span>.^<span class=\"hljs-number\">2</span> + <span class=\"hljs-keyword\">Y</span>.^<span class=\"hljs-number\">2</span>;<br>surf(<span class=\"hljs-keyword\">Z</span>);<br>colorbar<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_01_zh_CN.png\" alt=\"img\"></p>\n<p>获取当前颜色范围。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">lim</span> = caxis<br><span class=\"hljs-attribute\">lim</span> = <span class=\"hljs-number\">1</span>×<span class=\"hljs-number\">2</span><br><br>     <span class=\"hljs-attribute\">0</span>    <span class=\"hljs-number\">50</span><br></code></pre></td></tr></table></figure>\n<p>将下限提高到 <code>20</code>。请注意，小于或等于 <code>20</code> 的所有 <code>Z</code> 值映射到第一种颜色。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">([<span class=\"hljs-number\">20</span> <span class=\"hljs-number\">50</span>])</span></span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_02_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"保持多个曲面图的颜色范围不变\"><a href=\"#保持多个曲面图的颜色范围不变\" class=\"headerlink\" title=\"保持多个曲面图的颜色范围不变\"></a>保持多个曲面图的颜色范围不变</h4><p>创建两个垂直偏移的抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span> = <span class=\"hljs-keyword\">X</span>.^<span class=\"hljs-number\">2</span> + <span class=\"hljs-keyword\">Y</span>.^<span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">2</span> = <span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">50</span>;<br></code></pre></td></tr></table></figure>\n<p>绘制第一个抛物面。添加颜色栏，然后保持第二个抛物面的坐标区不变。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span>);<br>colorbar<br>hold on<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_01_zh_CN.png\" alt=\"img\"></p>\n<p>使用 <code>&#39;manual&#39;</code> 选项保持当前颜色范围不变。然后绘制第二个抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">caxis(<span class=\"hljs-string\">&#x27;manual&#x27;</span>);<br>surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_02_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"指定曲面图的颜色图颜色\"><a href=\"#指定曲面图的颜色图颜色\" class=\"headerlink\" title=\"指定曲面图的颜色图颜色\"></a>指定曲面图的颜色图颜色</h4><p>通过包含第四个矩阵输入 <code>C</code> 来指定曲面图的颜色。曲面图使用 <code>Z</code> 表示高度，<code>C</code> 表示颜色。使用<em>颜色图</em>指定颜色，该颜色图使用单个数字表示色谱上的颜色。使用颜色图时，<code>C</code> 与 <code>Z</code> 大小相同。向图中添加颜色栏以显示 <code>C</code> 中的数据值如何对应于颜色图中的颜色。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">0</span><span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">20</span>);<br><span class=\"hljs-keyword\">Z</span> = sin(<span class=\"hljs-keyword\">X</span>) + cos(<span class=\"hljs-keyword\">Y</span>);<br>C = <span class=\"hljs-keyword\">X</span>.*<span class=\"hljs-keyword\">Y</span>;<br>surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>,C)<br>colorbar<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/specifycolorsforsurfaceplotexample_01_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"为曲面图指定真彩色\"><a href=\"#为曲面图指定真彩色\" class=\"headerlink\" title=\"为曲面图指定真彩色\"></a>为曲面图指定真彩色</h4><p>通过包含第四个矩阵输入 <code>CO</code> 来指定曲面图的颜色。曲面图使用 <code>Z</code> 表示高度，<code>CO</code> 表示颜色。使用<em>真彩色</em>指定颜色，真彩色使用三个数字（即三元组）表示所有可能的颜色。使用真彩色时，如果 <code>Z</code> 为 <code>m</code>×<code>n</code>，则 <code>CO</code> 为 <code>m</code>×<code>n</code>×3。数组的第一页指示每种颜色的红色分量；第二页指示绿色分量；第三页指示蓝色分量。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs matlab\">[X,Y,Z] = peaks(<span class=\"hljs-number\">25</span>);<br>CO(:,:,<span class=\"hljs-number\">1</span>) = <span class=\"hljs-built_in\">zeros</span>(<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% red</span><br>CO(:,:,<span class=\"hljs-number\">2</span>) = <span class=\"hljs-built_in\">ones</span>(<span class=\"hljs-number\">25</span>).*<span class=\"hljs-built_in\">linspace</span>(<span class=\"hljs-number\">0.5</span>,<span class=\"hljs-number\">0.6</span>,<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% green</span><br>CO(:,:,<span class=\"hljs-number\">3</span>) = <span class=\"hljs-built_in\">ones</span>(<span class=\"hljs-number\">25</span>).*<span class=\"hljs-built_in\">linspace</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% blue</span><br>surf(X,Y,Z,CO)<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/surfaceplotwithtruecolorsexample_01_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"修改曲面图的外观\"><a href=\"#修改曲面图的外观\" class=\"headerlink\" title=\"修改曲面图的外观\"></a>修改曲面图的外观</h4><p>通过指定以 <code>0.5</code> 为值的 <code>FaceAlpha</code> 名称-值对组，来创建半透明曲面。要允许进一步修改，请将曲面对象赋给变量 <code>s</code>。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span> = <span class=\"hljs-keyword\">Y</span>.*sin(<span class=\"hljs-keyword\">X</span>) - <span class=\"hljs-keyword\">X</span>.*cos(<span class=\"hljs-keyword\">Y</span>);<br>s = surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>,<span class=\"hljs-string\">&#x27;FaceAlpha&#x27;</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-number\">.5</span>)<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_01_zh_CN.png\" alt=\"img\"></p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">s = <br>  Surface with propertie<span class=\"hljs-variable\">s:</span><br><br>       EdgeColor: [<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>       LineStyle: <span class=\"hljs-string\">&#x27;-&#x27;</span><br>       FaceColor: <span class=\"hljs-string\">&#x27;flat&#x27;</span><br>    FaceLightin<span class=\"hljs-variable\">g:</span> <span class=\"hljs-string\">&#x27;flat&#x27;</span><br>       FaceAlph<span class=\"hljs-variable\">a:</span> <span class=\"hljs-number\">0.5000</span><br>           XDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           YDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           ZDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           CDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br><br>  Show <span class=\"hljs-keyword\">all</span> properties<br></code></pre></td></tr></table></figure>\n<p>在创建曲面对象之后可使用 <code>s</code> 访问并修改其属性。例如，通过设置 <code>EdgeColor</code> 属性来隐藏边。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">s.EdgeColor</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_02_zh_CN.png\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(limits)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;auto&#x27;</span>)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;manual&#x27;</span>)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">(target,___)</span></span><br>cl = caxis<br></code></pre></td></tr></table></figure>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p><code>caxis(limits)</code> 设置当前坐标区的颜色图范围。<code>limits</code> 是 <code>[cmin cmax]</code> 形式的二元素向量。<a href=\"https://ww2.mathworks.cn/help/matlab/ref/caxis.html#mw_262386a0-0173-40a5-b123-7b5834c1d396\">颜色图索引数组</a>中小于或等于 <code>cmin</code> 的所有值映射到颜色图的第一行。大于或等于 <code>cmax</code> 的所有值映射到颜色图的最后一行。介于 <code>cmin</code> 和 <code>cmax</code> 之间的所有值以线性方式映射到颜色图的中间各行。</p>\n<p><strong>注意</strong></p>\n<p><code>caxis</code> 函数只影响 <code>CDataMapping</code> 属性设置为 <code>&#39;scaled&#39;</code> 的图形对象，不影响使用真彩色或 <code>CDataMapping</code> 设置为 <code>&#39;direct&#39;</code> 的图形对象。</p>\n<p><code>caxis(&#39;auto&#39;)</code> 在颜色图索引数组中的值更改时启用自动范围更新。这是默认行为。<code>caxis auto</code> 命令是此语法的另一种形式。</p>\n<p><code>caxis(&#39;manual&#39;)</code> 禁用自动范围更新。<code>caxis manual</code> 命令是此语法的另一种形式。</p>\n<p><code>caxis(target,___)</code> 为特定坐标区或图设置颜色图范围。指定 <code>target</code> 作为上述任何语法中的第一个输入参数。</p>\n<p><code>cl = caxis</code> 返回当前坐标区或图的当前颜色图范围。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"提高下限\"><a href=\"#提高下限\" class=\"headerlink\" title=\"提高下限\"></a>提高下限</h4><p>绘制带有颜色栏的抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span> = <span class=\"hljs-keyword\">X</span>.^<span class=\"hljs-number\">2</span> + <span class=\"hljs-keyword\">Y</span>.^<span class=\"hljs-number\">2</span>;<br>surf(<span class=\"hljs-keyword\">Z</span>);<br>colorbar<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_01_zh_CN.png\" alt=\"img\"></p>\n<p>获取当前颜色范围。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">lim</span> = caxis<br><span class=\"hljs-attribute\">lim</span> = <span class=\"hljs-number\">1</span>×<span class=\"hljs-number\">2</span><br><br>     <span class=\"hljs-attribute\">0</span>    <span class=\"hljs-number\">50</span><br></code></pre></td></tr></table></figure>\n<p>将下限提高到 <code>20</code>。请注意，小于或等于 <code>20</code> 的所有 <code>Z</code> 值映射到第一种颜色。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">caxis</span><span class=\"hljs-params\">([<span class=\"hljs-number\">20</span> <span class=\"hljs-number\">50</span>])</span></span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxisraiselowerlimitexample_02_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"保持多个曲面图的颜色范围不变\"><a href=\"#保持多个曲面图的颜色范围不变\" class=\"headerlink\" title=\"保持多个曲面图的颜色范围不变\"></a>保持多个曲面图的颜色范围不变</h4><p>创建两个垂直偏移的抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span> = <span class=\"hljs-keyword\">X</span>.^<span class=\"hljs-number\">2</span> + <span class=\"hljs-keyword\">Y</span>.^<span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">2</span> = <span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">50</span>;<br></code></pre></td></tr></table></figure>\n<p>绘制第一个抛物面。添加颜色栏，然后保持第二个抛物面的坐标区不变。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">1</span>);<br>colorbar<br>hold on<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_01_zh_CN.png\" alt=\"img\"></p>\n<p>使用 <code>&#39;manual&#39;</code> 选项保持当前颜色范围不变。然后绘制第二个抛物面。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">caxis(<span class=\"hljs-string\">&#x27;manual&#x27;</span>);<br>surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span><span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/caxissharecolorlimitsexample_02_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"指定曲面图的颜色图颜色\"><a href=\"#指定曲面图的颜色图颜色\" class=\"headerlink\" title=\"指定曲面图的颜色图颜色\"></a>指定曲面图的颜色图颜色</h4><p>通过包含第四个矩阵输入 <code>C</code> 来指定曲面图的颜色。曲面图使用 <code>Z</code> 表示高度，<code>C</code> 表示颜色。使用<em>颜色图</em>指定颜色，该颜色图使用单个数字表示色谱上的颜色。使用颜色图时，<code>C</code> 与 <code>Z</code> 大小相同。向图中添加颜色栏以显示 <code>C</code> 中的数据值如何对应于颜色图中的颜色。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">0</span><span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">20</span>);<br><span class=\"hljs-keyword\">Z</span> = sin(<span class=\"hljs-keyword\">X</span>) + cos(<span class=\"hljs-keyword\">Y</span>);<br>C = <span class=\"hljs-keyword\">X</span>.*<span class=\"hljs-keyword\">Y</span>;<br>surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>,C)<br>colorbar<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/specifycolorsforsurfaceplotexample_01_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"为曲面图指定真彩色\"><a href=\"#为曲面图指定真彩色\" class=\"headerlink\" title=\"为曲面图指定真彩色\"></a>为曲面图指定真彩色</h4><p>通过包含第四个矩阵输入 <code>CO</code> 来指定曲面图的颜色。曲面图使用 <code>Z</code> 表示高度，<code>CO</code> 表示颜色。使用<em>真彩色</em>指定颜色，真彩色使用三个数字（即三元组）表示所有可能的颜色。使用真彩色时，如果 <code>Z</code> 为 <code>m</code>×<code>n</code>，则 <code>CO</code> 为 <code>m</code>×<code>n</code>×3。数组的第一页指示每种颜色的红色分量；第二页指示绿色分量；第三页指示蓝色分量。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs matlab\">[X,Y,Z] = peaks(<span class=\"hljs-number\">25</span>);<br>CO(:,:,<span class=\"hljs-number\">1</span>) = <span class=\"hljs-built_in\">zeros</span>(<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% red</span><br>CO(:,:,<span class=\"hljs-number\">2</span>) = <span class=\"hljs-built_in\">ones</span>(<span class=\"hljs-number\">25</span>).*<span class=\"hljs-built_in\">linspace</span>(<span class=\"hljs-number\">0.5</span>,<span class=\"hljs-number\">0.6</span>,<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% green</span><br>CO(:,:,<span class=\"hljs-number\">3</span>) = <span class=\"hljs-built_in\">ones</span>(<span class=\"hljs-number\">25</span>).*<span class=\"hljs-built_in\">linspace</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">25</span>); <span class=\"hljs-comment\">% blue</span><br>surf(X,Y,Z,CO)<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/surfaceplotwithtruecolorsexample_01_zh_CN.png\" alt=\"img\"></p>\n<h4 id=\"修改曲面图的外观\"><a href=\"#修改曲面图的外观\" class=\"headerlink\" title=\"修改曲面图的外观\"></a>修改曲面图的外观</h4><p>通过指定以 <code>0.5</code> 为值的 <code>FaceAlpha</code> 名称-值对组，来创建半透明曲面。要允许进一步修改，请将曲面对象赋给变量 <code>s</code>。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>] = meshgrid(<span class=\"hljs-number\">-5</span>:<span class=\"hljs-number\">.5</span>:<span class=\"hljs-number\">5</span>);<br><span class=\"hljs-keyword\">Z</span> = <span class=\"hljs-keyword\">Y</span>.*sin(<span class=\"hljs-keyword\">X</span>) - <span class=\"hljs-keyword\">X</span>.*cos(<span class=\"hljs-keyword\">Y</span>);<br>s = surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>,<span class=\"hljs-string\">&#x27;FaceAlpha&#x27;</span>,<span class=\"hljs-number\">0</span><span class=\"hljs-number\">.5</span>)<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_01_zh_CN.png\" alt=\"img\"></p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">s = <br>  Surface with propertie<span class=\"hljs-variable\">s:</span><br><br>       EdgeColor: [<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>       LineStyle: <span class=\"hljs-string\">&#x27;-&#x27;</span><br>       FaceColor: <span class=\"hljs-string\">&#x27;flat&#x27;</span><br>    FaceLightin<span class=\"hljs-variable\">g:</span> <span class=\"hljs-string\">&#x27;flat&#x27;</span><br>       FaceAlph<span class=\"hljs-variable\">a:</span> <span class=\"hljs-number\">0.5000</span><br>           XDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           YDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           ZDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br>           CDat<span class=\"hljs-variable\">a:</span> [<span class=\"hljs-number\">21</span>x21 double]<br><br>  Show <span class=\"hljs-keyword\">all</span> properties<br></code></pre></td></tr></table></figure>\n<p>在创建曲面对象之后可使用 <code>s</code> 访问并修改其属性。例如，通过设置 <code>EdgeColor</code> 属性来隐藏边。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">s.EdgeColor</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/ref/modifysurfaceplotappearanceexample_02_zh_CN.png\" alt=\"img\"></p>\n"},{"title":"Matlab作图：更改图像、填充或曲面的透明度","author":"Shi Daming","date":"2021-04-06T09:00:00.000Z","_content":"\n### 1、坐标区框中所有对象的透明度\n\n透明度值称为 alpha 值。使用 `alpha` 函数设置当前坐标区范围内所有图像、填充或曲面对象的透明度。指定一个介于 0（完全透明）和 1（完全不透明）之间的透明度值。\n\n```\nt = 0:0.1:2*pi;\nx = sin(t);\ny = cos(t);\n\nfigure\npatch(x,y,'r')            % make a red circular patch\npatch(x+0.8,y,'g')        % make a green circular path\npatch(x+0.4,y+0.8,'b')    % make a blue circular path\naxis square tight         % set axis to square\n\nalpha(0.3)                % set all patches transparency to 0.3\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_01_zh_CN.png)\n\n### 2、个别曲面的透明度\n\n曲面的透明度由其 `AlphaData` 属性定义。将 alpha 数据设置为用于指定曲面的每个顶点透明度的标量值或值矩阵。`FaceAlpha` 属性指示如何从顶点透明度确定曲面透明度。\n\n```\n[X,Y,Z] = peaks(20);\ns2 = surf(X,Y,Z);\n\ns2.AlphaData = gradient(Z);    % set vertex transparencies\ns2.FaceAlpha = 'flat';\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_02_zh_CN.png)\n\n### 3、个别图像的透明度\n\n与曲面一样，图像的透明度也由其 `AlphaData` 属性定义。对于图像，将 alpha 数据设置为用于指定图像数据的每个元素透明度的标量值或值矩阵。\n\n例如，使用透明度覆盖两个图像。首先，显示地球的图像。\n\n```\nearth = imread('landOcean.jpg');\nimage(earth)    % display Earth image\naxis image\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_03_zh_CN.png)\n\n然后，使用透明度将云图层添加到地球图像。\n\n```\nclouds = imread('cloudCombined.jpg');\nimage(earth)\naxis image\nhold on\n\nim = image(clouds);\nim.AlphaData = max(clouds,[],3);    % set transparency to maximum cloud value\nhold off\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_04_zh_CN.png)\n\n### 4、个别填充的透明度\n\n填充的透明度由其 `FaceAlpha` 和 `FaceVertexAlphaData` 属性定义。若要在整个填充上实现单一的透明度，请将 `FaceVertexAlphaData` 设置为一个介于 0（完全透明）和 1（完全不透明）之间的常量，并将 `FaceAlpha` 属性设置为 `'flat'`。\n\n```\ncla\np1 = patch(x,y,'r');             % make a red circular patch\naxis square tight                % set axis to square\n\np1.FaceVertexAlphaData = 0.2;    % Set constant transparency \np1.FaceAlpha = 'flat' ;          % Interpolate to find face transparency\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_05_zh_CN.png)\n\n若要在整个填充上实现可变的透明度，请将 `FaceVertexAlphaData` 设置为用于指定填充的每个顶点或每个面的透明度的值矩阵。然后，通过 `FaceAlpha` 属性指示如何使用 `FaceVertexAlphaData` 确定面的透明度。如果为顶点指定了 alpha 数据，则必须将 `FaceAlpha` 设置为 `'interp'`。\n\n```\np1.FaceVertexAlphaData = x';   % Set vertex transparency to x values\np1.FaceAlpha = 'interp' ;      % Interpolate to find face transparency\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_06_zh_CN.png)\n\n### 5、包含纹理映射的透明度\n\n纹理映射将二维图像映射到三维曲面上。通过将 `CData` 属性设置为图像数据并将 `FaceColor` 属性设置为 `'texturemap'`，可将图像映射到曲面上。\n\n此示例创建地球和云的三维视图。它创建球形表面，并使用纹理映射将地球和云的图像映射到曲面上。\n\n```\n[px,py,pz] = sphere(50);                % generate coordinates for a 50 x 50 sphere\n\ncla\nsEarth = surface(py, px ,flip(pz));   \nsEarth.FaceColor = 'texturemap';        % set color to texture mapping\nsEarth.EdgeColor = 'none';              % remove surface edge color\nsEarth.CData = earth;                   % set color data \n\nhold on\nsCloud = surface(px*1.02,py*1.02,flip(pz)*1.02); \n\nsCloud.FaceColor = 'texturemap';        % set color to texture mapping\nsCloud.EdgeColor = 'none';              % remove surface edge color\nsCloud.CData = clouds;                  % set color data \n \nsCloud.FaceAlpha = 'texturemap';        % set transparency to texture mapping\nsCloud.AlphaData = max(clouds,[],3);    % set transparency data \nhold off\n\nview([80 2])                            % specify viewpoint \ndaspect([1 1 1])                        % set aspect ratio\naxis off tight                          % remove axis and set limits to data range\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_07_zh_CN.png)","source":"_posts/2021-04-06-Matlab颜色进阶.md","raw":"---\ntitle: Matlab作图：更改图像、填充或曲面的透明度\nauthor: Shi Daming\ndate: 2021-04-06 17:00:00 +0800\ncategories: Matlab\ntags: [Matlab, transparency]\n---\n\n### 1、坐标区框中所有对象的透明度\n\n透明度值称为 alpha 值。使用 `alpha` 函数设置当前坐标区范围内所有图像、填充或曲面对象的透明度。指定一个介于 0（完全透明）和 1（完全不透明）之间的透明度值。\n\n```\nt = 0:0.1:2*pi;\nx = sin(t);\ny = cos(t);\n\nfigure\npatch(x,y,'r')            % make a red circular patch\npatch(x+0.8,y,'g')        % make a green circular path\npatch(x+0.4,y+0.8,'b')    % make a blue circular path\naxis square tight         % set axis to square\n\nalpha(0.3)                % set all patches transparency to 0.3\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_01_zh_CN.png)\n\n### 2、个别曲面的透明度\n\n曲面的透明度由其 `AlphaData` 属性定义。将 alpha 数据设置为用于指定曲面的每个顶点透明度的标量值或值矩阵。`FaceAlpha` 属性指示如何从顶点透明度确定曲面透明度。\n\n```\n[X,Y,Z] = peaks(20);\ns2 = surf(X,Y,Z);\n\ns2.AlphaData = gradient(Z);    % set vertex transparencies\ns2.FaceAlpha = 'flat';\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_02_zh_CN.png)\n\n### 3、个别图像的透明度\n\n与曲面一样，图像的透明度也由其 `AlphaData` 属性定义。对于图像，将 alpha 数据设置为用于指定图像数据的每个元素透明度的标量值或值矩阵。\n\n例如，使用透明度覆盖两个图像。首先，显示地球的图像。\n\n```\nearth = imread('landOcean.jpg');\nimage(earth)    % display Earth image\naxis image\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_03_zh_CN.png)\n\n然后，使用透明度将云图层添加到地球图像。\n\n```\nclouds = imread('cloudCombined.jpg');\nimage(earth)\naxis image\nhold on\n\nim = image(clouds);\nim.AlphaData = max(clouds,[],3);    % set transparency to maximum cloud value\nhold off\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_04_zh_CN.png)\n\n### 4、个别填充的透明度\n\n填充的透明度由其 `FaceAlpha` 和 `FaceVertexAlphaData` 属性定义。若要在整个填充上实现单一的透明度，请将 `FaceVertexAlphaData` 设置为一个介于 0（完全透明）和 1（完全不透明）之间的常量，并将 `FaceAlpha` 属性设置为 `'flat'`。\n\n```\ncla\np1 = patch(x,y,'r');             % make a red circular patch\naxis square tight                % set axis to square\n\np1.FaceVertexAlphaData = 0.2;    % Set constant transparency \np1.FaceAlpha = 'flat' ;          % Interpolate to find face transparency\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_05_zh_CN.png)\n\n若要在整个填充上实现可变的透明度，请将 `FaceVertexAlphaData` 设置为用于指定填充的每个顶点或每个面的透明度的值矩阵。然后，通过 `FaceAlpha` 属性指示如何使用 `FaceVertexAlphaData` 确定面的透明度。如果为顶点指定了 alpha 数据，则必须将 `FaceAlpha` 设置为 `'interp'`。\n\n```\np1.FaceVertexAlphaData = x';   % Set vertex transparency to x values\np1.FaceAlpha = 'interp' ;      % Interpolate to find face transparency\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_06_zh_CN.png)\n\n### 5、包含纹理映射的透明度\n\n纹理映射将二维图像映射到三维曲面上。通过将 `CData` 属性设置为图像数据并将 `FaceColor` 属性设置为 `'texturemap'`，可将图像映射到曲面上。\n\n此示例创建地球和云的三维视图。它创建球形表面，并使用纹理映射将地球和云的图像映射到曲面上。\n\n```\n[px,py,pz] = sphere(50);                % generate coordinates for a 50 x 50 sphere\n\ncla\nsEarth = surface(py, px ,flip(pz));   \nsEarth.FaceColor = 'texturemap';        % set color to texture mapping\nsEarth.EdgeColor = 'none';              % remove surface edge color\nsEarth.CData = earth;                   % set color data \n\nhold on\nsCloud = surface(px*1.02,py*1.02,flip(pz)*1.02); \n\nsCloud.FaceColor = 'texturemap';        % set color to texture mapping\nsCloud.EdgeColor = 'none';              % remove surface edge color\nsCloud.CData = clouds;                  % set color data \n \nsCloud.FaceAlpha = 'texturemap';        % set transparency to texture mapping\nsCloud.AlphaData = max(clouds,[],3);    % set transparency data \nhold off\n\nview([80 2])                            % specify viewpoint \ndaspect([1 1 1])                        % set aspect ratio\naxis off tight                          % remove axis and set limits to data range\n```\n\n![img](https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_07_zh_CN.png)","slug":"Matlab颜色进阶","published":1,"updated":"2021-08-15T01:47:48.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9m0006y8uxhpd46e4v","content":"<h3 id=\"1、坐标区框中所有对象的透明度\"><a href=\"#1、坐标区框中所有对象的透明度\" class=\"headerlink\" title=\"1、坐标区框中所有对象的透明度\"></a>1、坐标区框中所有对象的透明度</h3><p>透明度值称为 alpha 值。使用 <code>alpha</code> 函数设置当前坐标区范围内所有图像、填充或曲面对象的透明度。指定一个介于 0（完全透明）和 1（完全不透明）之间的透明度值。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">t</span> = <span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">2</span>*pi;<br><span class=\"hljs-attribute\">x</span> = sin(t);<br><span class=\"hljs-attribute\">y</span> = cos(t);<br><br><span class=\"hljs-attribute\">figure</span><br><span class=\"hljs-attribute\">patch</span>(x,y,&#x27;r&#x27;)            % make a red circular patch<br><span class=\"hljs-attribute\">patch</span>(x+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">8</span>,y,&#x27;g&#x27;)        % make a green circular path<br><span class=\"hljs-attribute\">patch</span>(x+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">4</span>,y+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">8</span>,&#x27;b&#x27;)    % make a blue circular path<br><span class=\"hljs-attribute\">axis</span> square tight         % set axis to square<br><br><span class=\"hljs-attribute\">alpha</span>(<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3</span>)                % set <span class=\"hljs-literal\">all</span> patches transparency to <span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_01_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"2、个别曲面的透明度\"><a href=\"#2、个别曲面的透明度\" class=\"headerlink\" title=\"2、个别曲面的透明度\"></a>2、个别曲面的透明度</h3><p>曲面的透明度由其 <code>AlphaData</code> 属性定义。将 alpha 数据设置为用于指定曲面的每个顶点透明度的标量值或值矩阵。<code>FaceAlpha</code> 属性指示如何从顶点透明度确定曲面透明度。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>] = peaks(<span class=\"hljs-number\">20</span>);<br>s<span class=\"hljs-number\">2</span> = surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>);<br><br>s<span class=\"hljs-number\">2</span>.AlphaData = gradient(<span class=\"hljs-keyword\">Z</span>);    % set vertex transparencies<br>s<span class=\"hljs-number\">2</span>.FaceAlpha = <span class=\"hljs-string\">&#x27;flat&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_02_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"3、个别图像的透明度\"><a href=\"#3、个别图像的透明度\" class=\"headerlink\" title=\"3、个别图像的透明度\"></a>3、个别图像的透明度</h3><p>与曲面一样，图像的透明度也由其 <code>AlphaData</code> 属性定义。对于图像，将 alpha 数据设置为用于指定图像数据的每个元素透明度的标量值或值矩阵。</p>\n<p>例如，使用透明度覆盖两个图像。首先，显示地球的图像。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">earth = imread(&#x27;landOcean.jpg&#x27;);<br><span class=\"hljs-built_in\">image</span>(earth)    <span class=\"hljs-symbol\">%</span> <span class=\"hljs-built_in\">display</span> Earth <span class=\"hljs-built_in\">image</span><br>axis <span class=\"hljs-built_in\">image</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_03_zh_CN.png\" alt=\"img\"></p>\n<p>然后，使用透明度将云图层添加到地球图像。</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\">clouds = imread(<span class=\"hljs-string\">&#x27;cloudCombined.jpg&#x27;</span>);<br><span class=\"hljs-built_in\">image</span>(earth)<br>axis <span class=\"hljs-built_in\">image</span><br>hold on<br><br>im = <span class=\"hljs-built_in\">image</span>(clouds);<br>im.AlphaData = <span class=\"hljs-built_in\">max</span>(clouds,[],<span class=\"hljs-number\">3</span>);    % <span class=\"hljs-built_in\">set</span> transparency <span class=\"hljs-keyword\">to</span> maximum cloud value<br>hold off<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_04_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"4、个别填充的透明度\"><a href=\"#4、个别填充的透明度\" class=\"headerlink\" title=\"4、个别填充的透明度\"></a>4、个别填充的透明度</h3><p>填充的透明度由其 <code>FaceAlpha</code> 和 <code>FaceVertexAlphaData</code> 属性定义。若要在整个填充上实现单一的透明度，请将 <code>FaceVertexAlphaData</code> 设置为一个介于 0（完全透明）和 1（完全不透明）之间的常量，并将 <code>FaceAlpha</code> 属性设置为 <code>&#39;flat&#39;</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">cla<br>p1 = patch(x,y,<span class=\"hljs-string\">&#x27;r&#x27;</span>);             % make a red circular patch<br>axis square tight                % <span class=\"hljs-builtin-name\">set</span> axis <span class=\"hljs-keyword\">to</span> square<br><br>p1.FaceVertexAlphaData = 0.2;    % <span class=\"hljs-builtin-name\">Set</span> constant transparency <br>p1.FaceAlpha = <span class=\"hljs-string\">&#x27;flat&#x27;</span> ;          % Interpolate <span class=\"hljs-keyword\">to</span> <span class=\"hljs-builtin-name\">find</span> face transparency<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_05_zh_CN.png\" alt=\"img\"></p>\n<p>若要在整个填充上实现可变的透明度，请将 <code>FaceVertexAlphaData</code> 设置为用于指定填充的每个顶点或每个面的透明度的值矩阵。然后，通过 <code>FaceAlpha</code> 属性指示如何使用 <code>FaceVertexAlphaData</code> 确定面的透明度。如果为顶点指定了 alpha 数据，则必须将 <code>FaceAlpha</code> 设置为 <code>&#39;interp&#39;</code>。</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">p1.FaceVertexAlphaData = x&#x27;;   <span class=\"hljs-comment\">% Set vertex transparency to x values</span><br>p1.FaceAlpha = <span class=\"hljs-string\">&#x27;interp&#x27;</span> ;      <span class=\"hljs-comment\">% Interpolate to find face transparency</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_06_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"5、包含纹理映射的透明度\"><a href=\"#5、包含纹理映射的透明度\" class=\"headerlink\" title=\"5、包含纹理映射的透明度\"></a>5、包含纹理映射的透明度</h3><p>纹理映射将二维图像映射到三维曲面上。通过将 <code>CData</code> 属性设置为图像数据并将 <code>FaceColor</code> 属性设置为 <code>&#39;texturemap&#39;</code>，可将图像映射到曲面上。</p>\n<p>此示例创建地球和云的三维视图。它创建球形表面，并使用纹理映射将地球和云的图像映射到曲面上。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">[px,py,pz] = sphere(50);                % generate coordinates <span class=\"hljs-keyword\">for</span> a 50 x 50 sphere<br><br>cla<br>sEarth = surface(py, px ,flip(pz));   <br>sEarth.FaceColor = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> color <span class=\"hljs-keyword\">to</span> texture mapping<br>sEarth.EdgeColor = <span class=\"hljs-string\">&#x27;none&#x27;</span>;              % <span class=\"hljs-builtin-name\">remove</span> surface edge color<br>sEarth.CData = earth;                   % <span class=\"hljs-builtin-name\">set</span> color data <br><br>hold on<br>sCloud = surface(px<span class=\"hljs-number\">*1</span>.02,py<span class=\"hljs-number\">*1</span>.02,flip(pz)<span class=\"hljs-number\">*1</span>.02); <br><br>sCloud.FaceColor = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> color <span class=\"hljs-keyword\">to</span> texture mapping<br>sCloud.EdgeColor = <span class=\"hljs-string\">&#x27;none&#x27;</span>;              % <span class=\"hljs-builtin-name\">remove</span> surface edge color<br>sCloud.CData = clouds;                  % <span class=\"hljs-builtin-name\">set</span> color data <br> <br>sCloud.FaceAlpha = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> transparency <span class=\"hljs-keyword\">to</span> texture mapping<br>sCloud.AlphaData = max(clouds,[],3);    % <span class=\"hljs-builtin-name\">set</span> transparency data <br>hold off<br><br>view([80 2])                            % specify viewpoint <br>daspect([1 1 1])                        % <span class=\"hljs-builtin-name\">set</span> aspect ratio<br>axis off tight                          % <span class=\"hljs-builtin-name\">remove</span> axis <span class=\"hljs-keyword\">and</span> <span class=\"hljs-builtin-name\">set</span> limits <span class=\"hljs-keyword\">to</span> data range<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_07_zh_CN.png\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、坐标区框中所有对象的透明度\"><a href=\"#1、坐标区框中所有对象的透明度\" class=\"headerlink\" title=\"1、坐标区框中所有对象的透明度\"></a>1、坐标区框中所有对象的透明度</h3><p>透明度值称为 alpha 值。使用 <code>alpha</code> 函数设置当前坐标区范围内所有图像、填充或曲面对象的透明度。指定一个介于 0（完全透明）和 1（完全不透明）之间的透明度值。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">t</span> = <span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">2</span>*pi;<br><span class=\"hljs-attribute\">x</span> = sin(t);<br><span class=\"hljs-attribute\">y</span> = cos(t);<br><br><span class=\"hljs-attribute\">figure</span><br><span class=\"hljs-attribute\">patch</span>(x,y,&#x27;r&#x27;)            % make a red circular patch<br><span class=\"hljs-attribute\">patch</span>(x+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">8</span>,y,&#x27;g&#x27;)        % make a green circular path<br><span class=\"hljs-attribute\">patch</span>(x+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">4</span>,y+<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">8</span>,&#x27;b&#x27;)    % make a blue circular path<br><span class=\"hljs-attribute\">axis</span> square tight         % set axis to square<br><br><span class=\"hljs-attribute\">alpha</span>(<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3</span>)                % set <span class=\"hljs-literal\">all</span> patches transparency to <span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_01_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"2、个别曲面的透明度\"><a href=\"#2、个别曲面的透明度\" class=\"headerlink\" title=\"2、个别曲面的透明度\"></a>2、个别曲面的透明度</h3><p>曲面的透明度由其 <code>AlphaData</code> 属性定义。将 alpha 数据设置为用于指定曲面的每个顶点透明度的标量值或值矩阵。<code>FaceAlpha</code> 属性指示如何从顶点透明度确定曲面透明度。</p>\n<figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tp\">[<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>] = peaks(<span class=\"hljs-number\">20</span>);<br>s<span class=\"hljs-number\">2</span> = surf(<span class=\"hljs-keyword\">X</span>,<span class=\"hljs-keyword\">Y</span>,<span class=\"hljs-keyword\">Z</span>);<br><br>s<span class=\"hljs-number\">2</span>.AlphaData = gradient(<span class=\"hljs-keyword\">Z</span>);    % set vertex transparencies<br>s<span class=\"hljs-number\">2</span>.FaceAlpha = <span class=\"hljs-string\">&#x27;flat&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_02_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"3、个别图像的透明度\"><a href=\"#3、个别图像的透明度\" class=\"headerlink\" title=\"3、个别图像的透明度\"></a>3、个别图像的透明度</h3><p>与曲面一样，图像的透明度也由其 <code>AlphaData</code> 属性定义。对于图像，将 alpha 数据设置为用于指定图像数据的每个元素透明度的标量值或值矩阵。</p>\n<p>例如，使用透明度覆盖两个图像。首先，显示地球的图像。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">earth = imread(&#x27;landOcean.jpg&#x27;);<br><span class=\"hljs-built_in\">image</span>(earth)    <span class=\"hljs-symbol\">%</span> <span class=\"hljs-built_in\">display</span> Earth <span class=\"hljs-built_in\">image</span><br>axis <span class=\"hljs-built_in\">image</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_03_zh_CN.png\" alt=\"img\"></p>\n<p>然后，使用透明度将云图层添加到地球图像。</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sqf\">clouds = imread(<span class=\"hljs-string\">&#x27;cloudCombined.jpg&#x27;</span>);<br><span class=\"hljs-built_in\">image</span>(earth)<br>axis <span class=\"hljs-built_in\">image</span><br>hold on<br><br>im = <span class=\"hljs-built_in\">image</span>(clouds);<br>im.AlphaData = <span class=\"hljs-built_in\">max</span>(clouds,[],<span class=\"hljs-number\">3</span>);    % <span class=\"hljs-built_in\">set</span> transparency <span class=\"hljs-keyword\">to</span> maximum cloud value<br>hold off<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_04_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"4、个别填充的透明度\"><a href=\"#4、个别填充的透明度\" class=\"headerlink\" title=\"4、个别填充的透明度\"></a>4、个别填充的透明度</h3><p>填充的透明度由其 <code>FaceAlpha</code> 和 <code>FaceVertexAlphaData</code> 属性定义。若要在整个填充上实现单一的透明度，请将 <code>FaceVertexAlphaData</code> 设置为一个介于 0（完全透明）和 1（完全不透明）之间的常量，并将 <code>FaceAlpha</code> 属性设置为 <code>&#39;flat&#39;</code>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">cla<br>p1 = patch(x,y,<span class=\"hljs-string\">&#x27;r&#x27;</span>);             % make a red circular patch<br>axis square tight                % <span class=\"hljs-builtin-name\">set</span> axis <span class=\"hljs-keyword\">to</span> square<br><br>p1.FaceVertexAlphaData = 0.2;    % <span class=\"hljs-builtin-name\">Set</span> constant transparency <br>p1.FaceAlpha = <span class=\"hljs-string\">&#x27;flat&#x27;</span> ;          % Interpolate <span class=\"hljs-keyword\">to</span> <span class=\"hljs-builtin-name\">find</span> face transparency<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_05_zh_CN.png\" alt=\"img\"></p>\n<p>若要在整个填充上实现可变的透明度，请将 <code>FaceVertexAlphaData</code> 设置为用于指定填充的每个顶点或每个面的透明度的值矩阵。然后，通过 <code>FaceAlpha</code> 属性指示如何使用 <code>FaceVertexAlphaData</code> 确定面的透明度。如果为顶点指定了 alpha 数据，则必须将 <code>FaceAlpha</code> 设置为 <code>&#39;interp&#39;</code>。</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang-repl\">p1.FaceVertexAlphaData = x&#x27;;   <span class=\"hljs-comment\">% Set vertex transparency to x values</span><br>p1.FaceAlpha = <span class=\"hljs-string\">&#x27;interp&#x27;</span> ;      <span class=\"hljs-comment\">% Interpolate to find face transparency</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_06_zh_CN.png\" alt=\"img\"></p>\n<h3 id=\"5、包含纹理映射的透明度\"><a href=\"#5、包含纹理映射的透明度\" class=\"headerlink\" title=\"5、包含纹理映射的透明度\"></a>5、包含纹理映射的透明度</h3><p>纹理映射将二维图像映射到三维曲面上。通过将 <code>CData</code> 属性设置为图像数据并将 <code>FaceColor</code> 属性设置为 <code>&#39;texturemap&#39;</code>，可将图像映射到曲面上。</p>\n<p>此示例创建地球和云的三维视图。它创建球形表面，并使用纹理映射将地球和云的图像映射到曲面上。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">[px,py,pz] = sphere(50);                % generate coordinates <span class=\"hljs-keyword\">for</span> a 50 x 50 sphere<br><br>cla<br>sEarth = surface(py, px ,flip(pz));   <br>sEarth.FaceColor = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> color <span class=\"hljs-keyword\">to</span> texture mapping<br>sEarth.EdgeColor = <span class=\"hljs-string\">&#x27;none&#x27;</span>;              % <span class=\"hljs-builtin-name\">remove</span> surface edge color<br>sEarth.CData = earth;                   % <span class=\"hljs-builtin-name\">set</span> color data <br><br>hold on<br>sCloud = surface(px<span class=\"hljs-number\">*1</span>.02,py<span class=\"hljs-number\">*1</span>.02,flip(pz)<span class=\"hljs-number\">*1</span>.02); <br><br>sCloud.FaceColor = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> color <span class=\"hljs-keyword\">to</span> texture mapping<br>sCloud.EdgeColor = <span class=\"hljs-string\">&#x27;none&#x27;</span>;              % <span class=\"hljs-builtin-name\">remove</span> surface edge color<br>sCloud.CData = clouds;                  % <span class=\"hljs-builtin-name\">set</span> color data <br> <br>sCloud.FaceAlpha = <span class=\"hljs-string\">&#x27;texturemap&#x27;</span>;        % <span class=\"hljs-builtin-name\">set</span> transparency <span class=\"hljs-keyword\">to</span> texture mapping<br>sCloud.AlphaData = max(clouds,[],3);    % <span class=\"hljs-builtin-name\">set</span> transparency data <br>hold off<br><br>view([80 2])                            % specify viewpoint <br>daspect([1 1 1])                        % <span class=\"hljs-builtin-name\">set</span> aspect ratio<br>axis off tight                          % <span class=\"hljs-builtin-name\">remove</span> axis <span class=\"hljs-keyword\">and</span> <span class=\"hljs-builtin-name\">set</span> limits <span class=\"hljs-keyword\">to</span> data range<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://ww2.mathworks.cn/help/matlab/creating_plots/changingtransparencyexample_07_zh_CN.png\" alt=\"img\"></p>\n"},{"title":"Keras中LN层的使用","author":"Shi Daming","date":"2021-06-09T15:00:00.000Z","typora-root-url":"..","_content":"\n### 1、BN的问题\n\nBN是按照样本数计算归一化统计量的，当样本数很少时，比如说只有4个。这四个样本的均值和方差便不能反映全局的统计分布息，所以基于少量样本的BN的效果会变得很差。\n\n### 2、LN层的使用\n\n<img src=\"/images/BN_and_LN.png\" style=\"zoom:80%;\" />\n\n这张图与我们平常看到的feature maps有些不同，立方体的3个维度为别为batch/ channel/ HW，而我们常见的feature maps中，3个维度分别为channel/ H/ W，没有batch。分析上图可知：BN计算均值和标准差时，固定channel(在一个channel内)，对HW和batch作平均；LN计算均值和标准差时，固定batch(在一个batch内)，对HW和channel作平均，更详细的推导过程可以查阅参考文献。\n\n可以看到与BN不同，LN没有对batch作平均，所以当batch变化时，网络的错误率不会有明显变化。论文的实验显示：LN和IN 在时间序列模型(RNN/LSTM)和生成模型(GAN)上有很好的效果，而GN在视觉模型(CNN)上表现更好。\n\nLN与BN层非常相似，特点主要体现在两个方面：\n\n1. LN得到的模型更稳定；\n2. LN有正则化的作用，得到的模型更不容易过拟合。\n\n关于Layer normalization， Keras官方API连接如下\n\nhttps://keras.io/api/layers/normalization_layers/layer_normalization/\n\n但是请注意，这个函数在Keras中可能无法正常使用，但可以通过pip正确安装\n\n**Install**\n\n```python\npip install keras-layer-normalization\n```\n\n**Usage**\n\n```python\nimport keras\nfrom keras_layer_normalization import LayerNormalization\n\n\ninput_layer = keras.layers.Input(shape=(2, 3))\nnorm_layer = LayerNormalization()(input_layer)\nmodel = keras.models.Model(inputs=input_layer, outputs=norm_layer)\nmodel.compile(optimizer='adam', loss='mse', metrics={},)\nmodel.summary()\n```\n\n**Reference**\n\n- [Lei Ba et al., 2016](https://arxiv.org/pdf/1607.06450.pdf).\n\n","source":"_posts/2021-06-09-keras中LN层的使用.md","raw":"---\ntitle: Keras中LN层的使用\nauthor: Shi Daming\ndate: 2021-06-09 23:00:00 +0800\ncategories: python\ntags: [python, Keras, LN]\ntypora-root-url: ..\n---\n\n### 1、BN的问题\n\nBN是按照样本数计算归一化统计量的，当样本数很少时，比如说只有4个。这四个样本的均值和方差便不能反映全局的统计分布息，所以基于少量样本的BN的效果会变得很差。\n\n### 2、LN层的使用\n\n<img src=\"/images/BN_and_LN.png\" style=\"zoom:80%;\" />\n\n这张图与我们平常看到的feature maps有些不同，立方体的3个维度为别为batch/ channel/ HW，而我们常见的feature maps中，3个维度分别为channel/ H/ W，没有batch。分析上图可知：BN计算均值和标准差时，固定channel(在一个channel内)，对HW和batch作平均；LN计算均值和标准差时，固定batch(在一个batch内)，对HW和channel作平均，更详细的推导过程可以查阅参考文献。\n\n可以看到与BN不同，LN没有对batch作平均，所以当batch变化时，网络的错误率不会有明显变化。论文的实验显示：LN和IN 在时间序列模型(RNN/LSTM)和生成模型(GAN)上有很好的效果，而GN在视觉模型(CNN)上表现更好。\n\nLN与BN层非常相似，特点主要体现在两个方面：\n\n1. LN得到的模型更稳定；\n2. LN有正则化的作用，得到的模型更不容易过拟合。\n\n关于Layer normalization， Keras官方API连接如下\n\nhttps://keras.io/api/layers/normalization_layers/layer_normalization/\n\n但是请注意，这个函数在Keras中可能无法正常使用，但可以通过pip正确安装\n\n**Install**\n\n```python\npip install keras-layer-normalization\n```\n\n**Usage**\n\n```python\nimport keras\nfrom keras_layer_normalization import LayerNormalization\n\n\ninput_layer = keras.layers.Input(shape=(2, 3))\nnorm_layer = LayerNormalization()(input_layer)\nmodel = keras.models.Model(inputs=input_layer, outputs=norm_layer)\nmodel.compile(optimizer='adam', loss='mse', metrics={},)\nmodel.summary()\n```\n\n**Reference**\n\n- [Lei Ba et al., 2016](https://arxiv.org/pdf/1607.06450.pdf).\n\n","slug":"keras中LN层的使用","published":1,"updated":"2021-08-15T01:47:48.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9o0007y8uxga8j47v0","content":"<h3 id=\"1、BN的问题\"><a href=\"#1、BN的问题\" class=\"headerlink\" title=\"1、BN的问题\"></a>1、BN的问题</h3><p>BN是按照样本数计算归一化统计量的，当样本数很少时，比如说只有4个。这四个样本的均值和方差便不能反映全局的统计分布息，所以基于少量样本的BN的效果会变得很差。</p>\n<h3 id=\"2、LN层的使用\"><a href=\"#2、LN层的使用\" class=\"headerlink\" title=\"2、LN层的使用\"></a>2、LN层的使用</h3><p><img src=\"/images/BN_and_LN.png\" style=\"zoom:80%;\" /></p>\n<p>这张图与我们平常看到的feature maps有些不同，立方体的3个维度为别为batch/ channel/ HW，而我们常见的feature maps中，3个维度分别为channel/ H/ W，没有batch。分析上图可知：BN计算均值和标准差时，固定channel(在一个channel内)，对HW和batch作平均；LN计算均值和标准差时，固定batch(在一个batch内)，对HW和channel作平均，更详细的推导过程可以查阅参考文献。</p>\n<p>可以看到与BN不同，LN没有对batch作平均，所以当batch变化时，网络的错误率不会有明显变化。论文的实验显示：LN和IN 在时间序列模型(RNN/LSTM)和生成模型(GAN)上有很好的效果，而GN在视觉模型(CNN)上表现更好。</p>\n<p>LN与BN层非常相似，特点主要体现在两个方面：</p>\n<ol>\n<li>LN得到的模型更稳定；</li>\n<li>LN有正则化的作用，得到的模型更不容易过拟合。</li>\n</ol>\n<p>关于Layer normalization， Keras官方API连接如下</p>\n<p><a href=\"https://keras.io/api/layers/normalization_layers/layer_normalization/\">https://keras.io/api/layers/normalization_layers/layer_normalization/</a></p>\n<p>但是请注意，这个函数在Keras中可能无法正常使用，但可以通过pip正确安装</p>\n<p><strong>Install</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pip install keras-layer-normalization<br></code></pre></td></tr></table></figure>\n<p><strong>Usage</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> keras<br><span class=\"hljs-keyword\">from</span> keras_layer_normalization <span class=\"hljs-keyword\">import</span> LayerNormalization<br><br><br>input_layer = keras.layers.Input(shape=(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>))<br>norm_layer = LayerNormalization()(input_layer)<br>model = keras.models.Model(inputs=input_layer, outputs=norm_layer)<br>model.<span class=\"hljs-built_in\">compile</span>(optimizer=<span class=\"hljs-string\">&#x27;adam&#x27;</span>, loss=<span class=\"hljs-string\">&#x27;mse&#x27;</span>, metrics=&#123;&#125;,)<br>model.summary()<br></code></pre></td></tr></table></figure>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://arxiv.org/pdf/1607.06450.pdf\">Lei Ba et al., 2016</a>.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、BN的问题\"><a href=\"#1、BN的问题\" class=\"headerlink\" title=\"1、BN的问题\"></a>1、BN的问题</h3><p>BN是按照样本数计算归一化统计量的，当样本数很少时，比如说只有4个。这四个样本的均值和方差便不能反映全局的统计分布息，所以基于少量样本的BN的效果会变得很差。</p>\n<h3 id=\"2、LN层的使用\"><a href=\"#2、LN层的使用\" class=\"headerlink\" title=\"2、LN层的使用\"></a>2、LN层的使用</h3><p><img src=\"/images/BN_and_LN.png\" style=\"zoom:80%;\" /></p>\n<p>这张图与我们平常看到的feature maps有些不同，立方体的3个维度为别为batch/ channel/ HW，而我们常见的feature maps中，3个维度分别为channel/ H/ W，没有batch。分析上图可知：BN计算均值和标准差时，固定channel(在一个channel内)，对HW和batch作平均；LN计算均值和标准差时，固定batch(在一个batch内)，对HW和channel作平均，更详细的推导过程可以查阅参考文献。</p>\n<p>可以看到与BN不同，LN没有对batch作平均，所以当batch变化时，网络的错误率不会有明显变化。论文的实验显示：LN和IN 在时间序列模型(RNN/LSTM)和生成模型(GAN)上有很好的效果，而GN在视觉模型(CNN)上表现更好。</p>\n<p>LN与BN层非常相似，特点主要体现在两个方面：</p>\n<ol>\n<li>LN得到的模型更稳定；</li>\n<li>LN有正则化的作用，得到的模型更不容易过拟合。</li>\n</ol>\n<p>关于Layer normalization， Keras官方API连接如下</p>\n<p><a href=\"https://keras.io/api/layers/normalization_layers/layer_normalization/\">https://keras.io/api/layers/normalization_layers/layer_normalization/</a></p>\n<p>但是请注意，这个函数在Keras中可能无法正常使用，但可以通过pip正确安装</p>\n<p><strong>Install</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pip install keras-layer-normalization<br></code></pre></td></tr></table></figure>\n<p><strong>Usage</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> keras<br><span class=\"hljs-keyword\">from</span> keras_layer_normalization <span class=\"hljs-keyword\">import</span> LayerNormalization<br><br><br>input_layer = keras.layers.Input(shape=(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>))<br>norm_layer = LayerNormalization()(input_layer)<br>model = keras.models.Model(inputs=input_layer, outputs=norm_layer)<br>model.<span class=\"hljs-built_in\">compile</span>(optimizer=<span class=\"hljs-string\">&#x27;adam&#x27;</span>, loss=<span class=\"hljs-string\">&#x27;mse&#x27;</span>, metrics=&#123;&#125;,)<br>model.summary()<br></code></pre></td></tr></table></figure>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://arxiv.org/pdf/1607.06450.pdf\">Lei Ba et al., 2016</a>.</li>\n</ul>\n"},{"title":"小波散射网络","date":"2021-07-23T03:45:25.000Z","math":true,"typora-root-url":"..","_content":"\n### 小波散射网络和小波神经网络\n\n#### 1. 小波网络\n\n小波神经网络是一种改进的BP网络，区别是将原来隐藏层的激活函数替换为小波函数，该网络属于小波分析和神经网络“紧致型”结合的一种方式，按照文献[1]中的说法，由于小波变换的时频局部特性，使得该网络在信号处理方面具有自适应性、容错能力和较强的网络逼近能力。小波神经网络的结构\n\n![图1 小波神经网络的结构](/images/2021-07-23-小波散射网络/小波神经网络的结构.png)\n\n小波网络模型可以表示为\n$$\ny_{i}(t)=\\sum_{i=0}^{n} w_{i j} \\psi_{a, b}\\left(\\sum_{k=0}^{m} w_{j k} x_{k}(t)\\right)\n$$\n本质上该网络的表示能力和BP网络并无区别，虽然在某些情况下可以获得更为优良的收敛速度和容错能力，但随着数据量提高，其预设的小波基会限制泛化性能。\n\n讨论：\n\n传统方法里，平移不变表示可以用配准算法或傅立叶变换模量来构造。为了避免傅立叶变换的不稳定性，建议用局部波形(如小波)代替正弦波。然而，小波变换对变化会有些敏感。从小波系数建立不变表示需要引入非线性算子，而卷积网络结构正好可以与之互补，有能力建立对变形反应稳定的大规模不变量。（PS:卷积网络的平移不变性仍然存疑[3]）。\n\n#### 2. 小波散射网络\n\n小波散射网络是由Mallat[2]等人提出的具有平移不变性的小波散射卷积神经网络，且对形变稳定，能保留高频信息进行分类。它将具有非线性模量和平均算子的小波反式卷积级联。第一网络层起到SIFT方法的效果，而下一层提供互补的不变信息，改进分类。小波散射网络的数学分析解释了深度卷积网络分类的重要性质。平稳过程的散射表示包含了高阶矩，因此可以区分具有相同傅立叶功率谱的纹理。\n\n设旋转变量$ r\\in G= \\{ angles=2k\\pi /K|0≤k<K \\}$​，$j$​表示尺度且$0≤j≤J$​，则二维方向小波函数为\n$$\n\\psi_{\\lambda}(u)=2^{-2 j} \\psi\\left(2^{-j} r^{-1} u\\right),   \\lambda=2^{-j} r\n$$\n其中如果小波基的傅里叶变换$\\hat{\\psi}(\\omega)$​的中心频率为$\\eta$​，则$\\hat{\\psi}_{2^{-j} r}(\\omega)=\\hat{\\psi}\\left(2^{j} r^{-1} \\omega\\right)$​的中心为$2^{-j}r\\eta$​，带宽正比于$2^{-j}$​。\n\n设$x$的小波系数为\n$$\nU[\\lambda] x=\\left|x * \\psi_{\\lambda}\\right|\n$$\n则序列$p=(\\lambda_{1}，\\lambda_{2}...\\lambda_{m})$​​​定义了一个路径，沿此路径频率降低，传播算子为\n$$\n\\begin{aligned} U[p] x &=U\\left[\\lambda_{m}\\right] \\cdots U\\left[\\lambda_{2}\\right] U\\left[\\lambda_{1}\\right] x \\\\ &=\\left|\\| x * \\psi_{\\lambda_{1}}\\right| * \\psi_{\\lambda_{2}}|\\cdots| * \\psi_{\\lambda_{m}} \\end{aligned}\n$$\n由此可得加窗的小波散射系数的表达式：\n$$\nS[p] x(u)=U[p] x * \\phi_{2^{J}}(u)=\\int U[p] x(v) \\phi_{2^{J}}(u-v) d v\n$$\n对于每个路径$p$，$S[p] x(u)$取决于窗的位置$u$。平均滤波器$\\phi_{2^{J}}(u)$使得当$|c| \\ll 2^{J}$时，$x_{c}(u)=x(u-c)$​​​ ，因此加窗的小波散射系数是近似具有平移不变性的。\n\n小波散射网络的迭代过程可以表示为如下所示\n\n![图2 A scattering propagator](/images/2021-07-23-小波散射网络/A scattering propagator.png)\n\n图3为两幅图像的傅里叶变换及其散射系数的幅值。平均尺度系数$2^J$等于图像尺寸。上面和下面的图像是非常不同的，但它们有相同的一阶散射系数。二阶系数可以清楚地分辨出这些图像。由于图像小波系数更稀疏，顶部图像的二阶散射系数振幅较大。高阶系数没有显示出来，因为它们的能量可以忽略不计。\n\n![图3 Scattering coefficients](/images/2021-07-23-小波散射网络/Scattering coefficients.PNG)\n\n\n\n**参考文献**\n\n[1] 左东广, 周帅, 张欣豫. 小波神经网络[J]. 四川兵工学报, 2012(05):90-92+104.\n\n[2] Bruna J, Mallat S. Invariant scattering convolution networks[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(8): 1872-1886.\n\n[3] Azulay A, Weiss Y. Why do deep convolutional networks generalize so poorly to small image transformations?[J]. arXiv preprint arXiv:1805.12177, 2018.\n\n","source":"_posts/2021-07-23-小波散射网络.md","raw":"---\ntitle: 小波散射网络\ndate: 2021-07-23 11:45:25\ncategories: signal processing\ntags:\nmath: true\ntypora-root-url: ..\n---\n\n### 小波散射网络和小波神经网络\n\n#### 1. 小波网络\n\n小波神经网络是一种改进的BP网络，区别是将原来隐藏层的激活函数替换为小波函数，该网络属于小波分析和神经网络“紧致型”结合的一种方式，按照文献[1]中的说法，由于小波变换的时频局部特性，使得该网络在信号处理方面具有自适应性、容错能力和较强的网络逼近能力。小波神经网络的结构\n\n![图1 小波神经网络的结构](/images/2021-07-23-小波散射网络/小波神经网络的结构.png)\n\n小波网络模型可以表示为\n$$\ny_{i}(t)=\\sum_{i=0}^{n} w_{i j} \\psi_{a, b}\\left(\\sum_{k=0}^{m} w_{j k} x_{k}(t)\\right)\n$$\n本质上该网络的表示能力和BP网络并无区别，虽然在某些情况下可以获得更为优良的收敛速度和容错能力，但随着数据量提高，其预设的小波基会限制泛化性能。\n\n讨论：\n\n传统方法里，平移不变表示可以用配准算法或傅立叶变换模量来构造。为了避免傅立叶变换的不稳定性，建议用局部波形(如小波)代替正弦波。然而，小波变换对变化会有些敏感。从小波系数建立不变表示需要引入非线性算子，而卷积网络结构正好可以与之互补，有能力建立对变形反应稳定的大规模不变量。（PS:卷积网络的平移不变性仍然存疑[3]）。\n\n#### 2. 小波散射网络\n\n小波散射网络是由Mallat[2]等人提出的具有平移不变性的小波散射卷积神经网络，且对形变稳定，能保留高频信息进行分类。它将具有非线性模量和平均算子的小波反式卷积级联。第一网络层起到SIFT方法的效果，而下一层提供互补的不变信息，改进分类。小波散射网络的数学分析解释了深度卷积网络分类的重要性质。平稳过程的散射表示包含了高阶矩，因此可以区分具有相同傅立叶功率谱的纹理。\n\n设旋转变量$ r\\in G= \\{ angles=2k\\pi /K|0≤k<K \\}$​，$j$​表示尺度且$0≤j≤J$​，则二维方向小波函数为\n$$\n\\psi_{\\lambda}(u)=2^{-2 j} \\psi\\left(2^{-j} r^{-1} u\\right),   \\lambda=2^{-j} r\n$$\n其中如果小波基的傅里叶变换$\\hat{\\psi}(\\omega)$​的中心频率为$\\eta$​，则$\\hat{\\psi}_{2^{-j} r}(\\omega)=\\hat{\\psi}\\left(2^{j} r^{-1} \\omega\\right)$​的中心为$2^{-j}r\\eta$​，带宽正比于$2^{-j}$​。\n\n设$x$的小波系数为\n$$\nU[\\lambda] x=\\left|x * \\psi_{\\lambda}\\right|\n$$\n则序列$p=(\\lambda_{1}，\\lambda_{2}...\\lambda_{m})$​​​定义了一个路径，沿此路径频率降低，传播算子为\n$$\n\\begin{aligned} U[p] x &=U\\left[\\lambda_{m}\\right] \\cdots U\\left[\\lambda_{2}\\right] U\\left[\\lambda_{1}\\right] x \\\\ &=\\left|\\| x * \\psi_{\\lambda_{1}}\\right| * \\psi_{\\lambda_{2}}|\\cdots| * \\psi_{\\lambda_{m}} \\end{aligned}\n$$\n由此可得加窗的小波散射系数的表达式：\n$$\nS[p] x(u)=U[p] x * \\phi_{2^{J}}(u)=\\int U[p] x(v) \\phi_{2^{J}}(u-v) d v\n$$\n对于每个路径$p$，$S[p] x(u)$取决于窗的位置$u$。平均滤波器$\\phi_{2^{J}}(u)$使得当$|c| \\ll 2^{J}$时，$x_{c}(u)=x(u-c)$​​​ ，因此加窗的小波散射系数是近似具有平移不变性的。\n\n小波散射网络的迭代过程可以表示为如下所示\n\n![图2 A scattering propagator](/images/2021-07-23-小波散射网络/A scattering propagator.png)\n\n图3为两幅图像的傅里叶变换及其散射系数的幅值。平均尺度系数$2^J$等于图像尺寸。上面和下面的图像是非常不同的，但它们有相同的一阶散射系数。二阶系数可以清楚地分辨出这些图像。由于图像小波系数更稀疏，顶部图像的二阶散射系数振幅较大。高阶系数没有显示出来，因为它们的能量可以忽略不计。\n\n![图3 Scattering coefficients](/images/2021-07-23-小波散射网络/Scattering coefficients.PNG)\n\n\n\n**参考文献**\n\n[1] 左东广, 周帅, 张欣豫. 小波神经网络[J]. 四川兵工学报, 2012(05):90-92+104.\n\n[2] Bruna J, Mallat S. Invariant scattering convolution networks[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(8): 1872-1886.\n\n[3] Azulay A, Weiss Y. Why do deep convolutional networks generalize so poorly to small image transformations?[J]. arXiv preprint arXiv:1805.12177, 2018.\n\n","slug":"小波散射网络","published":1,"updated":"2021-11-05T09:11:37.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9q000by8ux8hpa21bw","content":"<h3 id=\"小波散射网络和小波神经网络\"><a href=\"#小波散射网络和小波神经网络\" class=\"headerlink\" title=\"小波散射网络和小波神经网络\"></a>小波散射网络和小波神经网络</h3><h4 id=\"1-小波网络\"><a href=\"#1-小波网络\" class=\"headerlink\" title=\"1. 小波网络\"></a>1. 小波网络</h4><p>小波神经网络是一种改进的BP网络，区别是将原来隐藏层的激活函数替换为小波函数，该网络属于小波分析和神经网络“紧致型”结合的一种方式，按照文献[1]中的说法，由于小波变换的时频局部特性，使得该网络在信号处理方面具有自适应性、容错能力和较强的网络逼近能力。小波神经网络的结构</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/小波神经网络的结构.png\" alt=\"图1 小波神经网络的结构\"></p>\n<p>小波网络模型可以表示为</p>\n<script type=\"math/tex; mode=display\">\ny_{i}(t)=\\sum_{i=0}^{n} w_{i j} \\psi_{a, b}\\left(\\sum_{k=0}^{m} w_{j k} x_{k}(t)\\right)</script><p>本质上该网络的表示能力和BP网络并无区别，虽然在某些情况下可以获得更为优良的收敛速度和容错能力，但随着数据量提高，其预设的小波基会限制泛化性能。</p>\n<p>讨论：</p>\n<p>传统方法里，平移不变表示可以用配准算法或傅立叶变换模量来构造。为了避免傅立叶变换的不稳定性，建议用局部波形(如小波)代替正弦波。然而，小波变换对变化会有些敏感。从小波系数建立不变表示需要引入非线性算子，而卷积网络结构正好可以与之互补，有能力建立对变形反应稳定的大规模不变量。（PS:卷积网络的平移不变性仍然存疑[3]）。</p>\n<h4 id=\"2-小波散射网络\"><a href=\"#2-小波散射网络\" class=\"headerlink\" title=\"2. 小波散射网络\"></a>2. 小波散射网络</h4><p>小波散射网络是由Mallat[2]等人提出的具有平移不变性的小波散射卷积神经网络，且对形变稳定，能保留高频信息进行分类。它将具有非线性模量和平均算子的小波反式卷积级联。第一网络层起到SIFT方法的效果，而下一层提供互补的不变信息，改进分类。小波散射网络的数学分析解释了深度卷积网络分类的重要性质。平稳过程的散射表示包含了高阶矩，因此可以区分具有相同傅立叶功率谱的纹理。</p>\n<p>设旋转变量$ r\\in G= \\{ angles=2k\\pi /K|0≤k&lt;K \\}$​，$j$​表示尺度且$0≤j≤J$​，则二维方向小波函数为</p>\n<script type=\"math/tex; mode=display\">\n\\psi_{\\lambda}(u)=2^{-2 j} \\psi\\left(2^{-j} r^{-1} u\\right),   \\lambda=2^{-j} r</script><p>其中如果小波基的傅里叶变换$\\hat{\\psi}(\\omega)$​的中心频率为$\\eta$​，则$\\hat{\\psi}_{2^{-j} r}(\\omega)=\\hat{\\psi}\\left(2^{j} r^{-1} \\omega\\right)$​的中心为$2^{-j}r\\eta$​，带宽正比于$2^{-j}$​。</p>\n<p>设$x$的小波系数为</p>\n<script type=\"math/tex; mode=display\">\nU[\\lambda] x=\\left|x * \\psi_{\\lambda}\\right|</script><p>则序列$p=(\\lambda_{1}，\\lambda_{2}…\\lambda_{m})$​​​定义了一个路径，沿此路径频率降低，传播算子为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} U[p] x &=U\\left[\\lambda_{m}\\right] \\cdots U\\left[\\lambda_{2}\\right] U\\left[\\lambda_{1}\\right] x \\\\ &=\\left|\\| x * \\psi_{\\lambda_{1}}\\right| * \\psi_{\\lambda_{2}}|\\cdots| * \\psi_{\\lambda_{m}} \\end{aligned}</script><p>由此可得加窗的小波散射系数的表达式：</p>\n<script type=\"math/tex; mode=display\">\nS[p] x(u)=U[p] x * \\phi_{2^{J}}(u)=\\int U[p] x(v) \\phi_{2^{J}}(u-v) d v</script><p>对于每个路径$p$，$S[p] x(u)$取决于窗的位置$u$。平均滤波器$\\phi_{2^{J}}(u)$使得当$|c| \\ll 2^{J}$时，$x_{c}(u)=x(u-c)$​​​ ，因此加窗的小波散射系数是近似具有平移不变性的。</p>\n<p>小波散射网络的迭代过程可以表示为如下所示</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/A scattering propagator.png\" alt=\"图2 A scattering propagator\"></p>\n<p>图3为两幅图像的傅里叶变换及其散射系数的幅值。平均尺度系数$2^J$等于图像尺寸。上面和下面的图像是非常不同的，但它们有相同的一阶散射系数。二阶系数可以清楚地分辨出这些图像。由于图像小波系数更稀疏，顶部图像的二阶散射系数振幅较大。高阶系数没有显示出来，因为它们的能量可以忽略不计。</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/Scattering coefficients.PNG\" alt=\"图3 Scattering coefficients\"></p>\n<p><strong>参考文献</strong></p>\n<p>[1] 左东广, 周帅, 张欣豫. 小波神经网络[J]. 四川兵工学报, 2012(05):90-92+104.</p>\n<p>[2] Bruna J, Mallat S. Invariant scattering convolution networks[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(8): 1872-1886.</p>\n<p>[3] Azulay A, Weiss Y. Why do deep convolutional networks generalize so poorly to small image transformations?[J]. arXiv preprint arXiv:1805.12177, 2018.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"小波散射网络和小波神经网络\"><a href=\"#小波散射网络和小波神经网络\" class=\"headerlink\" title=\"小波散射网络和小波神经网络\"></a>小波散射网络和小波神经网络</h3><h4 id=\"1-小波网络\"><a href=\"#1-小波网络\" class=\"headerlink\" title=\"1. 小波网络\"></a>1. 小波网络</h4><p>小波神经网络是一种改进的BP网络，区别是将原来隐藏层的激活函数替换为小波函数，该网络属于小波分析和神经网络“紧致型”结合的一种方式，按照文献[1]中的说法，由于小波变换的时频局部特性，使得该网络在信号处理方面具有自适应性、容错能力和较强的网络逼近能力。小波神经网络的结构</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/小波神经网络的结构.png\" alt=\"图1 小波神经网络的结构\"></p>\n<p>小波网络模型可以表示为</p>\n<script type=\"math/tex; mode=display\">\ny_{i}(t)=\\sum_{i=0}^{n} w_{i j} \\psi_{a, b}\\left(\\sum_{k=0}^{m} w_{j k} x_{k}(t)\\right)</script><p>本质上该网络的表示能力和BP网络并无区别，虽然在某些情况下可以获得更为优良的收敛速度和容错能力，但随着数据量提高，其预设的小波基会限制泛化性能。</p>\n<p>讨论：</p>\n<p>传统方法里，平移不变表示可以用配准算法或傅立叶变换模量来构造。为了避免傅立叶变换的不稳定性，建议用局部波形(如小波)代替正弦波。然而，小波变换对变化会有些敏感。从小波系数建立不变表示需要引入非线性算子，而卷积网络结构正好可以与之互补，有能力建立对变形反应稳定的大规模不变量。（PS:卷积网络的平移不变性仍然存疑[3]）。</p>\n<h4 id=\"2-小波散射网络\"><a href=\"#2-小波散射网络\" class=\"headerlink\" title=\"2. 小波散射网络\"></a>2. 小波散射网络</h4><p>小波散射网络是由Mallat[2]等人提出的具有平移不变性的小波散射卷积神经网络，且对形变稳定，能保留高频信息进行分类。它将具有非线性模量和平均算子的小波反式卷积级联。第一网络层起到SIFT方法的效果，而下一层提供互补的不变信息，改进分类。小波散射网络的数学分析解释了深度卷积网络分类的重要性质。平稳过程的散射表示包含了高阶矩，因此可以区分具有相同傅立叶功率谱的纹理。</p>\n<p>设旋转变量$ r\\in G= \\{ angles=2k\\pi /K|0≤k&lt;K \\}$​，$j$​表示尺度且$0≤j≤J$​，则二维方向小波函数为</p>\n<script type=\"math/tex; mode=display\">\n\\psi_{\\lambda}(u)=2^{-2 j} \\psi\\left(2^{-j} r^{-1} u\\right),   \\lambda=2^{-j} r</script><p>其中如果小波基的傅里叶变换$\\hat{\\psi}(\\omega)$​的中心频率为$\\eta$​，则$\\hat{\\psi}_{2^{-j} r}(\\omega)=\\hat{\\psi}\\left(2^{j} r^{-1} \\omega\\right)$​的中心为$2^{-j}r\\eta$​，带宽正比于$2^{-j}$​。</p>\n<p>设$x$的小波系数为</p>\n<script type=\"math/tex; mode=display\">\nU[\\lambda] x=\\left|x * \\psi_{\\lambda}\\right|</script><p>则序列$p=(\\lambda_{1}，\\lambda_{2}…\\lambda_{m})$​​​定义了一个路径，沿此路径频率降低，传播算子为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} U[p] x &=U\\left[\\lambda_{m}\\right] \\cdots U\\left[\\lambda_{2}\\right] U\\left[\\lambda_{1}\\right] x \\\\ &=\\left|\\| x * \\psi_{\\lambda_{1}}\\right| * \\psi_{\\lambda_{2}}|\\cdots| * \\psi_{\\lambda_{m}} \\end{aligned}</script><p>由此可得加窗的小波散射系数的表达式：</p>\n<script type=\"math/tex; mode=display\">\nS[p] x(u)=U[p] x * \\phi_{2^{J}}(u)=\\int U[p] x(v) \\phi_{2^{J}}(u-v) d v</script><p>对于每个路径$p$，$S[p] x(u)$取决于窗的位置$u$。平均滤波器$\\phi_{2^{J}}(u)$使得当$|c| \\ll 2^{J}$时，$x_{c}(u)=x(u-c)$​​​ ，因此加窗的小波散射系数是近似具有平移不变性的。</p>\n<p>小波散射网络的迭代过程可以表示为如下所示</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/A scattering propagator.png\" alt=\"图2 A scattering propagator\"></p>\n<p>图3为两幅图像的傅里叶变换及其散射系数的幅值。平均尺度系数$2^J$等于图像尺寸。上面和下面的图像是非常不同的，但它们有相同的一阶散射系数。二阶系数可以清楚地分辨出这些图像。由于图像小波系数更稀疏，顶部图像的二阶散射系数振幅较大。高阶系数没有显示出来，因为它们的能量可以忽略不计。</p>\n<p><img src=\"/images/2021-07-23-小波散射网络/Scattering coefficients.PNG\" alt=\"图3 Scattering coefficients\"></p>\n<p><strong>参考文献</strong></p>\n<p>[1] 左东广, 周帅, 张欣豫. 小波神经网络[J]. 四川兵工学报, 2012(05):90-92+104.</p>\n<p>[2] Bruna J, Mallat S. Invariant scattering convolution networks[J]. IEEE transactions on pattern analysis and machine intelligence, 2013, 35(8): 1872-1886.</p>\n<p>[3] Azulay A, Weiss Y. Why do deep convolutional networks generalize so poorly to small image transformations?[J]. arXiv preprint arXiv:1805.12177, 2018.</p>\n"},{"title":"信号处理|傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换、经验小波变换、变分模态分解","author":"Shi Daming","date":"2021-06-20T02:00:00.000Z","math":true,"pin":true,"typora-root-url":"..","_content":"\n\n\n对于非平稳信号，其频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频域分析，包括短时傅里叶变换、小波变换、希尔伯特变换和希尔伯特黄变换，一下注意进行分析。\n\n### 傅里叶变换(Fourier Transform, FT)\n\n简单介绍一下一个连续信号$f(t)$的傅里叶变换和其逆变换\n$$\n\\begin{array}{l}\nF(\\omega)=F[f(t)]=\\int_{-\\infty}^{+\\infty} f(t) e^{-j \\omega t} d t \\\\\nf(t)=F^{-1}[F(\\omega)]=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} F(\\omega) e^{j \\omega t} d \\omega\n\\end{array}\n$$\n\n当然在实际应用中，一般使用离散傅里叶变换\n$$\nX(k)=\\sum_{n=0}^{N-1} x(n) e^{-j2\\pi kn/N}\\\\\nx(n)=\\frac{1}{N}\\sum_{n=0}^{N-1} X(n) e^{j2\\pi kn/N}\n$$\n如果信号的频率特性在任何时间都不发生改变(即该信号是平稳信号)的话，使用傅里叶变换是没有问题的，然而如果该信号是非平稳信号，这时候时域信息就相当重要了。\n\n### 短时傅里叶变换(Short-Time Fourier Transform, STFT)\n\n$$\nX(n, \\omega)=\\sum_{m=-\\infty}^{\\infty} x(m) w(n-m) e^{-j \\omega m}\n$$\n\n其中$w(n-m)$是窗函数，我们可以据此对信号进行时频分析。\n\n### 小波变换(Wavelet Transform, WT)\n\n对于任意能量有限信号$f(t)$，其连续小波变换(CWT)定义为\n$$\nW_{f}(a, b)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{+\\infty} f(t) \\psi^{*}\\left(\\frac{t-b}{a}\\right) d t\n$$\n在低频区域的变换结果具有较高的频率分辨率(频率轴是对数轴，在低频区域跨度较小)，在高频区域具有较高的时间分辨率。\n\n### 小结\n\n- 对于时域信号，它可以有很高的时间分辨率，然而其频率分辨率为零。\n- 经过傅里叶变换得到的频域信号可以实现很高的频率分辨率，然而其时间分辨率为零。\n- 对于短时傅里叶变换(STFT)，它在时域和频域都有一定的分辨率，并且在全局范围内STFT的时频分辨率都是一样的。但是由于Heisenberg不确定原理(也就是量子力学中的测不准原理)的制约，每一个时频窗的面积都是固定的，即时间分辨率和频率分辨率成反比，所以这两个分辨率不能同时很高。\n- 小波变换在不同时间和频率上具有不同尺寸的时频窗，可以在低频区域实现较高的频率分辨率，然而其仍然受到Heisenberg不确定原理的限制，时间分辨率和频率分辨率不能两全其美。同时小波变换的时频窗并非完全是自适应的，它还需要人为地选择基函数。\n\n上述的方法都会受到Heisenberg不确定原理的限制，而且并不是完全自适应的方法。接下来介绍一种不受Heisenberg不确定原理限制、同时还有更好的自适应性的时频分析方法——希尔伯特黄变换\n\n### 希尔伯特变换(Hilbert Transform, HT)\n\n希尔伯特变换也是傅里叶变换的一种扩展，它常常用于通信系统中的调制解调，当然它也可以用于信号的时频分析。\n\n单频率成分信号，即同一时刻只有一个频率分量的信号，我们可以由Hilbert谱很好地观察出信号的时频特征，且有很高的的时间分辨率，但是信号边界处的误差往往较大。\n\n对多频率成分信号不能直接进行Hilbert变换，我们还需要对其进行进一步处理，将原始信号分解成单频率信号的叠加，这就要用到希尔伯特黄变换中的EMD分解。\n\n### 希尔伯特黄变换(Hilbert-Huang Transform, HHT)\n\n相比于HT，HHT就多了一个经验模态分解(Empirical Mode Decomposition, EMD)，EMD就是把复杂信号分解成从高频到低频的若干个固有模态函数(Intrinsic Mode Function, IMF)，IMF需要满足两个条件：\n\n1. 信号极值点的数量与零点数相等或相差为1\n2. 信号的由极大值定义的上包络和由极小值定义 的下包络的局部均值为0(即包络上下对称)\n\n简单的理解就是，EMD是依次提取信号在每个局部的最高频分量的过程，所以每个IMF实际上是一个单频率分量信号，这样我们就可以对每个IMF分量进行Hilbert变换，从而得到每个分量的Hilbert谱。\n\n当然HHT并不是完美的，目前对于它的关键步骤EMD分解的研究尚不完善，缺乏一些理论基础。HHT在低频区域可能会出现一些不存在的频率分量。\n\n### 经验小波变换(EWT)\n\n经验小波变换（EWT）是一种新的自适应信号分解方法,该方法继承了EMD和小波分析方法的各自优点,通过提取频域极大值点自适应地分割傅里叶频谱以分离不同的模态,然后在频域自适应地构造带通滤波器组从而构造正交小波函数,以提取具有紧支撑傅立叶频谱的调幅-调频（AM-FM）成分。\n\n推荐论文：[基于经验小波变换的机械故障诊断方法研究](https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2015&filename=YQXB201411003&v=BAME6dADRg3hOUnynmQVUKsxm%25mmd2FjYPYGBRfazqTaU5nsKX1iiwwW3TcNUdsL%25mmd2F2hgO)\n\n### 变分模态分解(VMD)\n\nVMD（Variational mode decomposition）是一种自适应、完全非递归的模态变分和信号处理的方法。该技术具有可以确定模态分解个数的优点，其自适应性表现在根据实际情况确定所给序列的模态分解个数，随后的搜索和求解过程中可以自适应地匹配每种模态的最佳中心频率和有限带宽，并且可以实现固有模态分量（IMF）的有效分离、信号的频域划分、进而得到给定信号的有效分解成分，最终获得变分问题的最优解。它克服了EMD方法存在端点效应和模态分量混叠的问题。\n\nVMD的核心思想是构建和求解变分问题实现IMF的有效分离。\n\n推荐论文：[ 基于VMD的激光雷达回波信号去噪方法研究](https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2019&filename=JGHW201811024&v=UsZgNaRI7%25mmd2BXIcXhf68qkQ0zRFSa2mGSVb5rb%25mmd2FL48hZ9plvZdpsKV6H3NsWeyu3YT)\n\n### 二维傅里叶变换(2D-FT)\n\n**定义**\n\n一维信号是一个序列，FT将其分解成若干个一维的简单函数之和。而二维FT将一个图像分解成若干个复平面波$e^{j 2 \\pi(u x+v y)}$之和。**二维FT的公式**如下： \n$$\nF(u, v)=\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x, y) e^{-j 2 \\pi(u x+v y)} d x d y\n$$\n通过公式，我们可以计算出，每个平面波在图像中成分是多少。从公式也可以看到，二维傅里叶变换就是将图像与每个不同频率的不同方向的复平面波做内积（先点乘在求和），也就是一个求在**基**$e^{-j 2 \\pi(u x+v y)}$上的**投影**的过程。\n\n![通过傅里叶变换分解](/images/QQ截图20210722190017.png)\n\n**二维频率域K-SPACE**\n\n对于正弦平面波，可以这样理解，在一个方向上存在一个正弦函数，在法线方向上将其拉伸。前面说过三个参数可以确定一个一维的正弦波。哪几个参数可以确定一个二维的正弦平面波呢？答案是四个，其中三个和一维的情况一样（频率$\\omega$ ,幅度$A$，相位$\\varphi$），但是具有相同这些参数的平面波却可以有不同的方向$\\vec{n}$ 。\n\n类比一维中，幅度和相位可以用一个复数表示，它可以作为我们存储的内容。但是还有两个：一个频率一个方向。这时想到向量是有方向的，也是有长度的。所以我们用一个二维的矩阵的来保存分解之后得到的信息。这个矩阵就是K空间。（一般用k来表示空间频率，单位是1/m）\n\n就是说一个二维矩阵点 $(u,v)$代表这个平面波的法向量$\\vec{n}$，这个向量的模$\\sqrt{u^{2}+v^{2}}$代表这个平面波的频率$\\omega$ ，这个点里面保存的内容复数就是此平面波的幅度和相位。下面这个图很好的体现了这一点：\n\n![二维傅里叶变换的K空间](/images/2d-fft.jpg)\n\n也因此K空间的中心对于低频，周围对于高频。再如下面这个图片，**中心低频贡献了图像的主体，周围高频提供图像的细节和边缘。**\n\n![低通滤波和高通滤波](/images/QQ截图20210722185927.png)\n\n因此，k空间的每一个位置存储的数代表了所在位置复平面波在图像中占多少成分，我们就可以用每个系数所代表的平面波相加得到原来的图像。所以**k空间和对应图像储存的信息含量是一样的**，只不过表现形式不同，或者说基不同。\n\n**K空间的一些性质**\n\n频率混叠。在数字图像中，数据都是离散的。也就涉及到采样的问题，和一维一样，如果采样率过低，k空间就会混叠。同时在k空间中采样过低，图像也会混叠。**FOV和分辨率在k空间和图像中是相反的关系**\n$$\n\\Delta x=\\frac{1}{2 * k_{x m a x}}, \\Delta k=\\frac{1}{2 * x_{x m a x}}=\\frac{1}{F O V}\n$$\n旋转不变性。从平面波的角度很容易理解，旋转没有改变平面波的幅度相位，只是将所有的平面波都旋转了一个角度。下面这个图像显示了二维傅里叶变换中，实空间旋转多少，频率空间也会相应旋转多少。这其实是**高维傅里叶变换缩放定理的一种特殊情况。**\n\n**PS**\n\n- 1.因为matlab中的fft算法都是将0放在第一个的，所有写matlab时一定要将k空间fftshift一下使得零频回到k空间中心。\n\n- 2.简单的应用k空间进行去噪例子。通过去掉明显的k空间的异常峰，可以去除图像中有规律变化的噪声或者伪影。\n\n<img src=\"/images/QQ截图20210722185958.png\" alt=\"应用k空间进行降噪\" style=\"zoom:80%;\" />\n\n**Reference**\n\nhttps://zhuanlan.zhihu.com/p/150705777\n\nhttps://www.zhihu.com/question/22611929\n\nhttps://zhuanlan.zhihu.com/p/110026009\n\nhttps://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\n","source":"_posts/2021-06-20-信号处理傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换.md","raw":"---\ntitle: 信号处理|傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换、经验小波变换、变分模态分解\nauthor: Shi Daming\ndate: 2021-06-20 10:00:00 +0800\ncategories: signal processing\ntags: [FFT, STFT, WT, HT, HHT, signal processing]\nmath: true\npin: true\ntypora-root-url: ..\n---\n\n\n\n对于非平稳信号，其频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频域分析，包括短时傅里叶变换、小波变换、希尔伯特变换和希尔伯特黄变换，一下注意进行分析。\n\n### 傅里叶变换(Fourier Transform, FT)\n\n简单介绍一下一个连续信号$f(t)$的傅里叶变换和其逆变换\n$$\n\\begin{array}{l}\nF(\\omega)=F[f(t)]=\\int_{-\\infty}^{+\\infty} f(t) e^{-j \\omega t} d t \\\\\nf(t)=F^{-1}[F(\\omega)]=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} F(\\omega) e^{j \\omega t} d \\omega\n\\end{array}\n$$\n\n当然在实际应用中，一般使用离散傅里叶变换\n$$\nX(k)=\\sum_{n=0}^{N-1} x(n) e^{-j2\\pi kn/N}\\\\\nx(n)=\\frac{1}{N}\\sum_{n=0}^{N-1} X(n) e^{j2\\pi kn/N}\n$$\n如果信号的频率特性在任何时间都不发生改变(即该信号是平稳信号)的话，使用傅里叶变换是没有问题的，然而如果该信号是非平稳信号，这时候时域信息就相当重要了。\n\n### 短时傅里叶变换(Short-Time Fourier Transform, STFT)\n\n$$\nX(n, \\omega)=\\sum_{m=-\\infty}^{\\infty} x(m) w(n-m) e^{-j \\omega m}\n$$\n\n其中$w(n-m)$是窗函数，我们可以据此对信号进行时频分析。\n\n### 小波变换(Wavelet Transform, WT)\n\n对于任意能量有限信号$f(t)$，其连续小波变换(CWT)定义为\n$$\nW_{f}(a, b)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{+\\infty} f(t) \\psi^{*}\\left(\\frac{t-b}{a}\\right) d t\n$$\n在低频区域的变换结果具有较高的频率分辨率(频率轴是对数轴，在低频区域跨度较小)，在高频区域具有较高的时间分辨率。\n\n### 小结\n\n- 对于时域信号，它可以有很高的时间分辨率，然而其频率分辨率为零。\n- 经过傅里叶变换得到的频域信号可以实现很高的频率分辨率，然而其时间分辨率为零。\n- 对于短时傅里叶变换(STFT)，它在时域和频域都有一定的分辨率，并且在全局范围内STFT的时频分辨率都是一样的。但是由于Heisenberg不确定原理(也就是量子力学中的测不准原理)的制约，每一个时频窗的面积都是固定的，即时间分辨率和频率分辨率成反比，所以这两个分辨率不能同时很高。\n- 小波变换在不同时间和频率上具有不同尺寸的时频窗，可以在低频区域实现较高的频率分辨率，然而其仍然受到Heisenberg不确定原理的限制，时间分辨率和频率分辨率不能两全其美。同时小波变换的时频窗并非完全是自适应的，它还需要人为地选择基函数。\n\n上述的方法都会受到Heisenberg不确定原理的限制，而且并不是完全自适应的方法。接下来介绍一种不受Heisenberg不确定原理限制、同时还有更好的自适应性的时频分析方法——希尔伯特黄变换\n\n### 希尔伯特变换(Hilbert Transform, HT)\n\n希尔伯特变换也是傅里叶变换的一种扩展，它常常用于通信系统中的调制解调，当然它也可以用于信号的时频分析。\n\n单频率成分信号，即同一时刻只有一个频率分量的信号，我们可以由Hilbert谱很好地观察出信号的时频特征，且有很高的的时间分辨率，但是信号边界处的误差往往较大。\n\n对多频率成分信号不能直接进行Hilbert变换，我们还需要对其进行进一步处理，将原始信号分解成单频率信号的叠加，这就要用到希尔伯特黄变换中的EMD分解。\n\n### 希尔伯特黄变换(Hilbert-Huang Transform, HHT)\n\n相比于HT，HHT就多了一个经验模态分解(Empirical Mode Decomposition, EMD)，EMD就是把复杂信号分解成从高频到低频的若干个固有模态函数(Intrinsic Mode Function, IMF)，IMF需要满足两个条件：\n\n1. 信号极值点的数量与零点数相等或相差为1\n2. 信号的由极大值定义的上包络和由极小值定义 的下包络的局部均值为0(即包络上下对称)\n\n简单的理解就是，EMD是依次提取信号在每个局部的最高频分量的过程，所以每个IMF实际上是一个单频率分量信号，这样我们就可以对每个IMF分量进行Hilbert变换，从而得到每个分量的Hilbert谱。\n\n当然HHT并不是完美的，目前对于它的关键步骤EMD分解的研究尚不完善，缺乏一些理论基础。HHT在低频区域可能会出现一些不存在的频率分量。\n\n### 经验小波变换(EWT)\n\n经验小波变换（EWT）是一种新的自适应信号分解方法,该方法继承了EMD和小波分析方法的各自优点,通过提取频域极大值点自适应地分割傅里叶频谱以分离不同的模态,然后在频域自适应地构造带通滤波器组从而构造正交小波函数,以提取具有紧支撑傅立叶频谱的调幅-调频（AM-FM）成分。\n\n推荐论文：[基于经验小波变换的机械故障诊断方法研究](https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2015&filename=YQXB201411003&v=BAME6dADRg3hOUnynmQVUKsxm%25mmd2FjYPYGBRfazqTaU5nsKX1iiwwW3TcNUdsL%25mmd2F2hgO)\n\n### 变分模态分解(VMD)\n\nVMD（Variational mode decomposition）是一种自适应、完全非递归的模态变分和信号处理的方法。该技术具有可以确定模态分解个数的优点，其自适应性表现在根据实际情况确定所给序列的模态分解个数，随后的搜索和求解过程中可以自适应地匹配每种模态的最佳中心频率和有限带宽，并且可以实现固有模态分量（IMF）的有效分离、信号的频域划分、进而得到给定信号的有效分解成分，最终获得变分问题的最优解。它克服了EMD方法存在端点效应和模态分量混叠的问题。\n\nVMD的核心思想是构建和求解变分问题实现IMF的有效分离。\n\n推荐论文：[ 基于VMD的激光雷达回波信号去噪方法研究](https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2019&filename=JGHW201811024&v=UsZgNaRI7%25mmd2BXIcXhf68qkQ0zRFSa2mGSVb5rb%25mmd2FL48hZ9plvZdpsKV6H3NsWeyu3YT)\n\n### 二维傅里叶变换(2D-FT)\n\n**定义**\n\n一维信号是一个序列，FT将其分解成若干个一维的简单函数之和。而二维FT将一个图像分解成若干个复平面波$e^{j 2 \\pi(u x+v y)}$之和。**二维FT的公式**如下： \n$$\nF(u, v)=\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x, y) e^{-j 2 \\pi(u x+v y)} d x d y\n$$\n通过公式，我们可以计算出，每个平面波在图像中成分是多少。从公式也可以看到，二维傅里叶变换就是将图像与每个不同频率的不同方向的复平面波做内积（先点乘在求和），也就是一个求在**基**$e^{-j 2 \\pi(u x+v y)}$上的**投影**的过程。\n\n![通过傅里叶变换分解](/images/QQ截图20210722190017.png)\n\n**二维频率域K-SPACE**\n\n对于正弦平面波，可以这样理解，在一个方向上存在一个正弦函数，在法线方向上将其拉伸。前面说过三个参数可以确定一个一维的正弦波。哪几个参数可以确定一个二维的正弦平面波呢？答案是四个，其中三个和一维的情况一样（频率$\\omega$ ,幅度$A$，相位$\\varphi$），但是具有相同这些参数的平面波却可以有不同的方向$\\vec{n}$ 。\n\n类比一维中，幅度和相位可以用一个复数表示，它可以作为我们存储的内容。但是还有两个：一个频率一个方向。这时想到向量是有方向的，也是有长度的。所以我们用一个二维的矩阵的来保存分解之后得到的信息。这个矩阵就是K空间。（一般用k来表示空间频率，单位是1/m）\n\n就是说一个二维矩阵点 $(u,v)$代表这个平面波的法向量$\\vec{n}$，这个向量的模$\\sqrt{u^{2}+v^{2}}$代表这个平面波的频率$\\omega$ ，这个点里面保存的内容复数就是此平面波的幅度和相位。下面这个图很好的体现了这一点：\n\n![二维傅里叶变换的K空间](/images/2d-fft.jpg)\n\n也因此K空间的中心对于低频，周围对于高频。再如下面这个图片，**中心低频贡献了图像的主体，周围高频提供图像的细节和边缘。**\n\n![低通滤波和高通滤波](/images/QQ截图20210722185927.png)\n\n因此，k空间的每一个位置存储的数代表了所在位置复平面波在图像中占多少成分，我们就可以用每个系数所代表的平面波相加得到原来的图像。所以**k空间和对应图像储存的信息含量是一样的**，只不过表现形式不同，或者说基不同。\n\n**K空间的一些性质**\n\n频率混叠。在数字图像中，数据都是离散的。也就涉及到采样的问题，和一维一样，如果采样率过低，k空间就会混叠。同时在k空间中采样过低，图像也会混叠。**FOV和分辨率在k空间和图像中是相反的关系**\n$$\n\\Delta x=\\frac{1}{2 * k_{x m a x}}, \\Delta k=\\frac{1}{2 * x_{x m a x}}=\\frac{1}{F O V}\n$$\n旋转不变性。从平面波的角度很容易理解，旋转没有改变平面波的幅度相位，只是将所有的平面波都旋转了一个角度。下面这个图像显示了二维傅里叶变换中，实空间旋转多少，频率空间也会相应旋转多少。这其实是**高维傅里叶变换缩放定理的一种特殊情况。**\n\n**PS**\n\n- 1.因为matlab中的fft算法都是将0放在第一个的，所有写matlab时一定要将k空间fftshift一下使得零频回到k空间中心。\n\n- 2.简单的应用k空间进行去噪例子。通过去掉明显的k空间的异常峰，可以去除图像中有规律变化的噪声或者伪影。\n\n<img src=\"/images/QQ截图20210722185958.png\" alt=\"应用k空间进行降噪\" style=\"zoom:80%;\" />\n\n**Reference**\n\nhttps://zhuanlan.zhihu.com/p/150705777\n\nhttps://www.zhihu.com/question/22611929\n\nhttps://zhuanlan.zhihu.com/p/110026009\n\nhttps://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\n","slug":"信号处理傅里叶变换、短时傅里叶变换、小波变换、希尔伯特变换、希尔伯特黄变换","published":1,"updated":"2021-11-05T09:11:43.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9r000cy8ux5zn06c7l","content":"<p>对于非平稳信号，其频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频域分析，包括短时傅里叶变换、小波变换、希尔伯特变换和希尔伯特黄变换，一下注意进行分析。</p>\n<h3 id=\"傅里叶变换-Fourier-Transform-FT\"><a href=\"#傅里叶变换-Fourier-Transform-FT\" class=\"headerlink\" title=\"傅里叶变换(Fourier Transform, FT)\"></a>傅里叶变换(Fourier Transform, FT)</h3><p>简单介绍一下一个连续信号$f(t)$的傅里叶变换和其逆变换</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}\nF(\\omega)=F[f(t)]=\\int_{-\\infty}^{+\\infty} f(t) e^{-j \\omega t} d t \\\\\nf(t)=F^{-1}[F(\\omega)]=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} F(\\omega) e^{j \\omega t} d \\omega\n\\end{array}</script><p>当然在实际应用中，一般使用离散傅里叶变换</p>\n<script type=\"math/tex; mode=display\">\nX(k)=\\sum_{n=0}^{N-1} x(n) e^{-j2\\pi kn/N}\\\\\nx(n)=\\frac{1}{N}\\sum_{n=0}^{N-1} X(n) e^{j2\\pi kn/N}</script><p>如果信号的频率特性在任何时间都不发生改变(即该信号是平稳信号)的话，使用傅里叶变换是没有问题的，然而如果该信号是非平稳信号，这时候时域信息就相当重要了。</p>\n<h3 id=\"短时傅里叶变换-Short-Time-Fourier-Transform-STFT\"><a href=\"#短时傅里叶变换-Short-Time-Fourier-Transform-STFT\" class=\"headerlink\" title=\"短时傅里叶变换(Short-Time Fourier Transform, STFT)\"></a>短时傅里叶变换(Short-Time Fourier Transform, STFT)</h3><script type=\"math/tex; mode=display\">\nX(n, \\omega)=\\sum_{m=-\\infty}^{\\infty} x(m) w(n-m) e^{-j \\omega m}</script><p>其中$w(n-m)$是窗函数，我们可以据此对信号进行时频分析。</p>\n<h3 id=\"小波变换-Wavelet-Transform-WT\"><a href=\"#小波变换-Wavelet-Transform-WT\" class=\"headerlink\" title=\"小波变换(Wavelet Transform, WT)\"></a>小波变换(Wavelet Transform, WT)</h3><p>对于任意能量有限信号$f(t)$，其连续小波变换(CWT)定义为</p>\n<script type=\"math/tex; mode=display\">\nW_{f}(a, b)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{+\\infty} f(t) \\psi^{*}\\left(\\frac{t-b}{a}\\right) d t</script><p>在低频区域的变换结果具有较高的频率分辨率(频率轴是对数轴，在低频区域跨度较小)，在高频区域具有较高的时间分辨率。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>对于时域信号，它可以有很高的时间分辨率，然而其频率分辨率为零。</li>\n<li>经过傅里叶变换得到的频域信号可以实现很高的频率分辨率，然而其时间分辨率为零。</li>\n<li>对于短时傅里叶变换(STFT)，它在时域和频域都有一定的分辨率，并且在全局范围内STFT的时频分辨率都是一样的。但是由于Heisenberg不确定原理(也就是量子力学中的测不准原理)的制约，每一个时频窗的面积都是固定的，即时间分辨率和频率分辨率成反比，所以这两个分辨率不能同时很高。</li>\n<li>小波变换在不同时间和频率上具有不同尺寸的时频窗，可以在低频区域实现较高的频率分辨率，然而其仍然受到Heisenberg不确定原理的限制，时间分辨率和频率分辨率不能两全其美。同时小波变换的时频窗并非完全是自适应的，它还需要人为地选择基函数。</li>\n</ul>\n<p>上述的方法都会受到Heisenberg不确定原理的限制，而且并不是完全自适应的方法。接下来介绍一种不受Heisenberg不确定原理限制、同时还有更好的自适应性的时频分析方法——希尔伯特黄变换</p>\n<h3 id=\"希尔伯特变换-Hilbert-Transform-HT\"><a href=\"#希尔伯特变换-Hilbert-Transform-HT\" class=\"headerlink\" title=\"希尔伯特变换(Hilbert Transform, HT)\"></a>希尔伯特变换(Hilbert Transform, HT)</h3><p>希尔伯特变换也是傅里叶变换的一种扩展，它常常用于通信系统中的调制解调，当然它也可以用于信号的时频分析。</p>\n<p>单频率成分信号，即同一时刻只有一个频率分量的信号，我们可以由Hilbert谱很好地观察出信号的时频特征，且有很高的的时间分辨率，但是信号边界处的误差往往较大。</p>\n<p>对多频率成分信号不能直接进行Hilbert变换，我们还需要对其进行进一步处理，将原始信号分解成单频率信号的叠加，这就要用到希尔伯特黄变换中的EMD分解。</p>\n<h3 id=\"希尔伯特黄变换-Hilbert-Huang-Transform-HHT\"><a href=\"#希尔伯特黄变换-Hilbert-Huang-Transform-HHT\" class=\"headerlink\" title=\"希尔伯特黄变换(Hilbert-Huang Transform, HHT)\"></a>希尔伯特黄变换(Hilbert-Huang Transform, HHT)</h3><p>相比于HT，HHT就多了一个经验模态分解(Empirical Mode Decomposition, EMD)，EMD就是把复杂信号分解成从高频到低频的若干个固有模态函数(Intrinsic Mode Function, IMF)，IMF需要满足两个条件：</p>\n<ol>\n<li>信号极值点的数量与零点数相等或相差为1</li>\n<li>信号的由极大值定义的上包络和由极小值定义 的下包络的局部均值为0(即包络上下对称)</li>\n</ol>\n<p>简单的理解就是，EMD是依次提取信号在每个局部的最高频分量的过程，所以每个IMF实际上是一个单频率分量信号，这样我们就可以对每个IMF分量进行Hilbert变换，从而得到每个分量的Hilbert谱。</p>\n<p>当然HHT并不是完美的，目前对于它的关键步骤EMD分解的研究尚不完善，缺乏一些理论基础。HHT在低频区域可能会出现一些不存在的频率分量。</p>\n<h3 id=\"经验小波变换-EWT\"><a href=\"#经验小波变换-EWT\" class=\"headerlink\" title=\"经验小波变换(EWT)\"></a>经验小波变换(EWT)</h3><p>经验小波变换（EWT）是一种新的自适应信号分解方法,该方法继承了EMD和小波分析方法的各自优点,通过提取频域极大值点自适应地分割傅里叶频谱以分离不同的模态,然后在频域自适应地构造带通滤波器组从而构造正交小波函数,以提取具有紧支撑傅立叶频谱的调幅-调频（AM-FM）成分。</p>\n<p>推荐论文：<a href=\"https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2015&amp;filename=YQXB201411003&amp;v=BAME6dADRg3hOUnynmQVUKsxm%25mmd2FjYPYGBRfazqTaU5nsKX1iiwwW3TcNUdsL%25mmd2F2hgO\">基于经验小波变换的机械故障诊断方法研究</a></p>\n<h3 id=\"变分模态分解-VMD\"><a href=\"#变分模态分解-VMD\" class=\"headerlink\" title=\"变分模态分解(VMD)\"></a>变分模态分解(VMD)</h3><p>VMD（Variational mode decomposition）是一种自适应、完全非递归的模态变分和信号处理的方法。该技术具有可以确定模态分解个数的优点，其自适应性表现在根据实际情况确定所给序列的模态分解个数，随后的搜索和求解过程中可以自适应地匹配每种模态的最佳中心频率和有限带宽，并且可以实现固有模态分量（IMF）的有效分离、信号的频域划分、进而得到给定信号的有效分解成分，最终获得变分问题的最优解。它克服了EMD方法存在端点效应和模态分量混叠的问题。</p>\n<p>VMD的核心思想是构建和求解变分问题实现IMF的有效分离。</p>\n<p>推荐论文：<a href=\"https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2019&amp;filename=JGHW201811024&amp;v=UsZgNaRI7%25mmd2BXIcXhf68qkQ0zRFSa2mGSVb5rb%25mmd2FL48hZ9plvZdpsKV6H3NsWeyu3YT\"> 基于VMD的激光雷达回波信号去噪方法研究</a></p>\n<h3 id=\"二维傅里叶变换-2D-FT\"><a href=\"#二维傅里叶变换-2D-FT\" class=\"headerlink\" title=\"二维傅里叶变换(2D-FT)\"></a>二维傅里叶变换(2D-FT)</h3><p><strong>定义</strong></p>\n<p>一维信号是一个序列，FT将其分解成若干个一维的简单函数之和。而二维FT将一个图像分解成若干个复平面波$e^{j 2 \\pi(u x+v y)}$之和。<strong>二维FT的公式</strong>如下： </p>\n<script type=\"math/tex; mode=display\">\nF(u, v)=\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x, y) e^{-j 2 \\pi(u x+v y)} d x d y</script><p>通过公式，我们可以计算出，每个平面波在图像中成分是多少。从公式也可以看到，二维傅里叶变换就是将图像与每个不同频率的不同方向的复平面波做内积（先点乘在求和），也就是一个求在<strong>基</strong>$e^{-j 2 \\pi(u x+v y)}$上的<strong>投影</strong>的过程。</p>\n<p><img src=\"/images/QQ截图20210722190017.png\" alt=\"通过傅里叶变换分解\"></p>\n<p><strong>二维频率域K-SPACE</strong></p>\n<p>对于正弦平面波，可以这样理解，在一个方向上存在一个正弦函数，在法线方向上将其拉伸。前面说过三个参数可以确定一个一维的正弦波。哪几个参数可以确定一个二维的正弦平面波呢？答案是四个，其中三个和一维的情况一样（频率$\\omega$ ,幅度$A$，相位$\\varphi$），但是具有相同这些参数的平面波却可以有不同的方向$\\vec{n}$ 。</p>\n<p>类比一维中，幅度和相位可以用一个复数表示，它可以作为我们存储的内容。但是还有两个：一个频率一个方向。这时想到向量是有方向的，也是有长度的。所以我们用一个二维的矩阵的来保存分解之后得到的信息。这个矩阵就是K空间。（一般用k来表示空间频率，单位是1/m）</p>\n<p>就是说一个二维矩阵点 $(u,v)$代表这个平面波的法向量$\\vec{n}$，这个向量的模$\\sqrt{u^{2}+v^{2}}$代表这个平面波的频率$\\omega$ ，这个点里面保存的内容复数就是此平面波的幅度和相位。下面这个图很好的体现了这一点：</p>\n<p><img src=\"/images/2d-fft.jpg\" alt=\"二维傅里叶变换的K空间\"></p>\n<p>也因此K空间的中心对于低频，周围对于高频。再如下面这个图片，<strong>中心低频贡献了图像的主体，周围高频提供图像的细节和边缘。</strong></p>\n<p><img src=\"/images/QQ截图20210722185927.png\" alt=\"低通滤波和高通滤波\"></p>\n<p>因此，k空间的每一个位置存储的数代表了所在位置复平面波在图像中占多少成分，我们就可以用每个系数所代表的平面波相加得到原来的图像。所以<strong>k空间和对应图像储存的信息含量是一样的</strong>，只不过表现形式不同，或者说基不同。</p>\n<p><strong>K空间的一些性质</strong></p>\n<p>频率混叠。在数字图像中，数据都是离散的。也就涉及到采样的问题，和一维一样，如果采样率过低，k空间就会混叠。同时在k空间中采样过低，图像也会混叠。<strong>FOV和分辨率在k空间和图像中是相反的关系</strong></p>\n<script type=\"math/tex; mode=display\">\n\\Delta x=\\frac{1}{2 * k_{x m a x}}, \\Delta k=\\frac{1}{2 * x_{x m a x}}=\\frac{1}{F O V}</script><p>旋转不变性。从平面波的角度很容易理解，旋转没有改变平面波的幅度相位，只是将所有的平面波都旋转了一个角度。下面这个图像显示了二维傅里叶变换中，实空间旋转多少，频率空间也会相应旋转多少。这其实是<strong>高维傅里叶变换缩放定理的一种特殊情况。</strong></p>\n<p><strong>PS</strong></p>\n<ul>\n<li><p>1.因为matlab中的fft算法都是将0放在第一个的，所有写matlab时一定要将k空间fftshift一下使得零频回到k空间中心。</p>\n</li>\n<li><p>2.简单的应用k空间进行去噪例子。通过去掉明显的k空间的异常峰，可以去除图像中有规律变化的噪声或者伪影。</p>\n</li>\n</ul>\n<p><img src=\"/images/QQ截图20210722185958.png\" alt=\"应用k空间进行降噪\" style=\"zoom:80%;\" /></p>\n<p><strong>Reference</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/150705777\">https://zhuanlan.zhihu.com/p/150705777</a></p>\n<p><a href=\"https://www.zhihu.com/question/22611929\">https://www.zhihu.com/question/22611929</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/110026009\">https://zhuanlan.zhihu.com/p/110026009</a></p>\n<p><a href=\"https://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\">https://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于非平稳信号，其频率特性会随时间变化，为了捕获这一时变特性，我们需要对信号进行时频域分析，包括短时傅里叶变换、小波变换、希尔伯特变换和希尔伯特黄变换，一下注意进行分析。</p>\n<h3 id=\"傅里叶变换-Fourier-Transform-FT\"><a href=\"#傅里叶变换-Fourier-Transform-FT\" class=\"headerlink\" title=\"傅里叶变换(Fourier Transform, FT)\"></a>傅里叶变换(Fourier Transform, FT)</h3><p>简单介绍一下一个连续信号$f(t)$的傅里叶变换和其逆变换</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}\nF(\\omega)=F[f(t)]=\\int_{-\\infty}^{+\\infty} f(t) e^{-j \\omega t} d t \\\\\nf(t)=F^{-1}[F(\\omega)]=\\frac{1}{2 \\pi} \\int_{-\\infty}^{+\\infty} F(\\omega) e^{j \\omega t} d \\omega\n\\end{array}</script><p>当然在实际应用中，一般使用离散傅里叶变换</p>\n<script type=\"math/tex; mode=display\">\nX(k)=\\sum_{n=0}^{N-1} x(n) e^{-j2\\pi kn/N}\\\\\nx(n)=\\frac{1}{N}\\sum_{n=0}^{N-1} X(n) e^{j2\\pi kn/N}</script><p>如果信号的频率特性在任何时间都不发生改变(即该信号是平稳信号)的话，使用傅里叶变换是没有问题的，然而如果该信号是非平稳信号，这时候时域信息就相当重要了。</p>\n<h3 id=\"短时傅里叶变换-Short-Time-Fourier-Transform-STFT\"><a href=\"#短时傅里叶变换-Short-Time-Fourier-Transform-STFT\" class=\"headerlink\" title=\"短时傅里叶变换(Short-Time Fourier Transform, STFT)\"></a>短时傅里叶变换(Short-Time Fourier Transform, STFT)</h3><script type=\"math/tex; mode=display\">\nX(n, \\omega)=\\sum_{m=-\\infty}^{\\infty} x(m) w(n-m) e^{-j \\omega m}</script><p>其中$w(n-m)$是窗函数，我们可以据此对信号进行时频分析。</p>\n<h3 id=\"小波变换-Wavelet-Transform-WT\"><a href=\"#小波变换-Wavelet-Transform-WT\" class=\"headerlink\" title=\"小波变换(Wavelet Transform, WT)\"></a>小波变换(Wavelet Transform, WT)</h3><p>对于任意能量有限信号$f(t)$，其连续小波变换(CWT)定义为</p>\n<script type=\"math/tex; mode=display\">\nW_{f}(a, b)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{+\\infty} f(t) \\psi^{*}\\left(\\frac{t-b}{a}\\right) d t</script><p>在低频区域的变换结果具有较高的频率分辨率(频率轴是对数轴，在低频区域跨度较小)，在高频区域具有较高的时间分辨率。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>对于时域信号，它可以有很高的时间分辨率，然而其频率分辨率为零。</li>\n<li>经过傅里叶变换得到的频域信号可以实现很高的频率分辨率，然而其时间分辨率为零。</li>\n<li>对于短时傅里叶变换(STFT)，它在时域和频域都有一定的分辨率，并且在全局范围内STFT的时频分辨率都是一样的。但是由于Heisenberg不确定原理(也就是量子力学中的测不准原理)的制约，每一个时频窗的面积都是固定的，即时间分辨率和频率分辨率成反比，所以这两个分辨率不能同时很高。</li>\n<li>小波变换在不同时间和频率上具有不同尺寸的时频窗，可以在低频区域实现较高的频率分辨率，然而其仍然受到Heisenberg不确定原理的限制，时间分辨率和频率分辨率不能两全其美。同时小波变换的时频窗并非完全是自适应的，它还需要人为地选择基函数。</li>\n</ul>\n<p>上述的方法都会受到Heisenberg不确定原理的限制，而且并不是完全自适应的方法。接下来介绍一种不受Heisenberg不确定原理限制、同时还有更好的自适应性的时频分析方法——希尔伯特黄变换</p>\n<h3 id=\"希尔伯特变换-Hilbert-Transform-HT\"><a href=\"#希尔伯特变换-Hilbert-Transform-HT\" class=\"headerlink\" title=\"希尔伯特变换(Hilbert Transform, HT)\"></a>希尔伯特变换(Hilbert Transform, HT)</h3><p>希尔伯特变换也是傅里叶变换的一种扩展，它常常用于通信系统中的调制解调，当然它也可以用于信号的时频分析。</p>\n<p>单频率成分信号，即同一时刻只有一个频率分量的信号，我们可以由Hilbert谱很好地观察出信号的时频特征，且有很高的的时间分辨率，但是信号边界处的误差往往较大。</p>\n<p>对多频率成分信号不能直接进行Hilbert变换，我们还需要对其进行进一步处理，将原始信号分解成单频率信号的叠加，这就要用到希尔伯特黄变换中的EMD分解。</p>\n<h3 id=\"希尔伯特黄变换-Hilbert-Huang-Transform-HHT\"><a href=\"#希尔伯特黄变换-Hilbert-Huang-Transform-HHT\" class=\"headerlink\" title=\"希尔伯特黄变换(Hilbert-Huang Transform, HHT)\"></a>希尔伯特黄变换(Hilbert-Huang Transform, HHT)</h3><p>相比于HT，HHT就多了一个经验模态分解(Empirical Mode Decomposition, EMD)，EMD就是把复杂信号分解成从高频到低频的若干个固有模态函数(Intrinsic Mode Function, IMF)，IMF需要满足两个条件：</p>\n<ol>\n<li>信号极值点的数量与零点数相等或相差为1</li>\n<li>信号的由极大值定义的上包络和由极小值定义 的下包络的局部均值为0(即包络上下对称)</li>\n</ol>\n<p>简单的理解就是，EMD是依次提取信号在每个局部的最高频分量的过程，所以每个IMF实际上是一个单频率分量信号，这样我们就可以对每个IMF分量进行Hilbert变换，从而得到每个分量的Hilbert谱。</p>\n<p>当然HHT并不是完美的，目前对于它的关键步骤EMD分解的研究尚不完善，缺乏一些理论基础。HHT在低频区域可能会出现一些不存在的频率分量。</p>\n<h3 id=\"经验小波变换-EWT\"><a href=\"#经验小波变换-EWT\" class=\"headerlink\" title=\"经验小波变换(EWT)\"></a>经验小波变换(EWT)</h3><p>经验小波变换（EWT）是一种新的自适应信号分解方法,该方法继承了EMD和小波分析方法的各自优点,通过提取频域极大值点自适应地分割傅里叶频谱以分离不同的模态,然后在频域自适应地构造带通滤波器组从而构造正交小波函数,以提取具有紧支撑傅立叶频谱的调幅-调频（AM-FM）成分。</p>\n<p>推荐论文：<a href=\"https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2015&amp;filename=YQXB201411003&amp;v=BAME6dADRg3hOUnynmQVUKsxm%25mmd2FjYPYGBRfazqTaU5nsKX1iiwwW3TcNUdsL%25mmd2F2hgO\">基于经验小波变换的机械故障诊断方法研究</a></p>\n<h3 id=\"变分模态分解-VMD\"><a href=\"#变分模态分解-VMD\" class=\"headerlink\" title=\"变分模态分解(VMD)\"></a>变分模态分解(VMD)</h3><p>VMD（Variational mode decomposition）是一种自适应、完全非递归的模态变分和信号处理的方法。该技术具有可以确定模态分解个数的优点，其自适应性表现在根据实际情况确定所给序列的模态分解个数，随后的搜索和求解过程中可以自适应地匹配每种模态的最佳中心频率和有限带宽，并且可以实现固有模态分量（IMF）的有效分离、信号的频域划分、进而得到给定信号的有效分解成分，最终获得变分问题的最优解。它克服了EMD方法存在端点效应和模态分量混叠的问题。</p>\n<p>VMD的核心思想是构建和求解变分问题实现IMF的有效分离。</p>\n<p>推荐论文：<a href=\"https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFDLAST2019&amp;filename=JGHW201811024&amp;v=UsZgNaRI7%25mmd2BXIcXhf68qkQ0zRFSa2mGSVb5rb%25mmd2FL48hZ9plvZdpsKV6H3NsWeyu3YT\"> 基于VMD的激光雷达回波信号去噪方法研究</a></p>\n<h3 id=\"二维傅里叶变换-2D-FT\"><a href=\"#二维傅里叶变换-2D-FT\" class=\"headerlink\" title=\"二维傅里叶变换(2D-FT)\"></a>二维傅里叶变换(2D-FT)</h3><p><strong>定义</strong></p>\n<p>一维信号是一个序列，FT将其分解成若干个一维的简单函数之和。而二维FT将一个图像分解成若干个复平面波$e^{j 2 \\pi(u x+v y)}$之和。<strong>二维FT的公式</strong>如下： </p>\n<script type=\"math/tex; mode=display\">\nF(u, v)=\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x, y) e^{-j 2 \\pi(u x+v y)} d x d y</script><p>通过公式，我们可以计算出，每个平面波在图像中成分是多少。从公式也可以看到，二维傅里叶变换就是将图像与每个不同频率的不同方向的复平面波做内积（先点乘在求和），也就是一个求在<strong>基</strong>$e^{-j 2 \\pi(u x+v y)}$上的<strong>投影</strong>的过程。</p>\n<p><img src=\"/images/QQ截图20210722190017.png\" alt=\"通过傅里叶变换分解\"></p>\n<p><strong>二维频率域K-SPACE</strong></p>\n<p>对于正弦平面波，可以这样理解，在一个方向上存在一个正弦函数，在法线方向上将其拉伸。前面说过三个参数可以确定一个一维的正弦波。哪几个参数可以确定一个二维的正弦平面波呢？答案是四个，其中三个和一维的情况一样（频率$\\omega$ ,幅度$A$，相位$\\varphi$），但是具有相同这些参数的平面波却可以有不同的方向$\\vec{n}$ 。</p>\n<p>类比一维中，幅度和相位可以用一个复数表示，它可以作为我们存储的内容。但是还有两个：一个频率一个方向。这时想到向量是有方向的，也是有长度的。所以我们用一个二维的矩阵的来保存分解之后得到的信息。这个矩阵就是K空间。（一般用k来表示空间频率，单位是1/m）</p>\n<p>就是说一个二维矩阵点 $(u,v)$代表这个平面波的法向量$\\vec{n}$，这个向量的模$\\sqrt{u^{2}+v^{2}}$代表这个平面波的频率$\\omega$ ，这个点里面保存的内容复数就是此平面波的幅度和相位。下面这个图很好的体现了这一点：</p>\n<p><img src=\"/images/2d-fft.jpg\" alt=\"二维傅里叶变换的K空间\"></p>\n<p>也因此K空间的中心对于低频，周围对于高频。再如下面这个图片，<strong>中心低频贡献了图像的主体，周围高频提供图像的细节和边缘。</strong></p>\n<p><img src=\"/images/QQ截图20210722185927.png\" alt=\"低通滤波和高通滤波\"></p>\n<p>因此，k空间的每一个位置存储的数代表了所在位置复平面波在图像中占多少成分，我们就可以用每个系数所代表的平面波相加得到原来的图像。所以<strong>k空间和对应图像储存的信息含量是一样的</strong>，只不过表现形式不同，或者说基不同。</p>\n<p><strong>K空间的一些性质</strong></p>\n<p>频率混叠。在数字图像中，数据都是离散的。也就涉及到采样的问题，和一维一样，如果采样率过低，k空间就会混叠。同时在k空间中采样过低，图像也会混叠。<strong>FOV和分辨率在k空间和图像中是相反的关系</strong></p>\n<script type=\"math/tex; mode=display\">\n\\Delta x=\\frac{1}{2 * k_{x m a x}}, \\Delta k=\\frac{1}{2 * x_{x m a x}}=\\frac{1}{F O V}</script><p>旋转不变性。从平面波的角度很容易理解，旋转没有改变平面波的幅度相位，只是将所有的平面波都旋转了一个角度。下面这个图像显示了二维傅里叶变换中，实空间旋转多少，频率空间也会相应旋转多少。这其实是<strong>高维傅里叶变换缩放定理的一种特殊情况。</strong></p>\n<p><strong>PS</strong></p>\n<ul>\n<li><p>1.因为matlab中的fft算法都是将0放在第一个的，所有写matlab时一定要将k空间fftshift一下使得零频回到k空间中心。</p>\n</li>\n<li><p>2.简单的应用k空间进行去噪例子。通过去掉明显的k空间的异常峰，可以去除图像中有规律变化的噪声或者伪影。</p>\n</li>\n</ul>\n<p><img src=\"/images/QQ截图20210722185958.png\" alt=\"应用k空间进行降噪\" style=\"zoom:80%;\" /></p>\n<p><strong>Reference</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/150705777\">https://zhuanlan.zhihu.com/p/150705777</a></p>\n<p><a href=\"https://www.zhihu.com/question/22611929\">https://www.zhihu.com/question/22611929</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/110026009\">https://zhuanlan.zhihu.com/p/110026009</a></p>\n<p><a href=\"https://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf\">https://www.robots.ox.ac.uk/~az/lectures/ia/lect2.pdf</a></p>\n"},{"title":"微分方程","date":"2021-09-07T02:55:37.000Z","math":true,"typora-root-url":"..","_content":"\n### 微分方程边界条件\n\n以二阶常微分方程为例\n$$\ny^{\\prime \\prime}(s)=f\\left(y(s), y^{\\prime}(s), s\\right)\n$$\n柯西边界条件（起始值条件）\n$$\ny(a)=\\alpha，\ny^{\\prime}(a)=\\beta\n$$\n狄利克雷边界条件（第一类边界条件）\n$$\ny(a)=\\alpha_{1}，y(b)=\\alpha_{2}\n$$\n诺依曼边界条件（第二类边界条件）\n$$\ny^{\\prime}(a)=\\alpha_{1},y^{\\prime}(b)=\\alpha_{2}\n$$\n","source":"_posts/2021-09-07-微分方程.md","raw":"---\ntitle: 微分方程\ndate: 2021-09-07 10:55:37\ntags:\nmath: true\ntypora-root-url: ..\n---\n\n### 微分方程边界条件\n\n以二阶常微分方程为例\n$$\ny^{\\prime \\prime}(s)=f\\left(y(s), y^{\\prime}(s), s\\right)\n$$\n柯西边界条件（起始值条件）\n$$\ny(a)=\\alpha，\ny^{\\prime}(a)=\\beta\n$$\n狄利克雷边界条件（第一类边界条件）\n$$\ny(a)=\\alpha_{1}，y(b)=\\alpha_{2}\n$$\n诺依曼边界条件（第二类边界条件）\n$$\ny^{\\prime}(a)=\\alpha_{1},y^{\\prime}(b)=\\alpha_{2}\n$$\n","slug":"微分方程","published":1,"updated":"2021-11-05T09:11:32.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9s000gy8uxelqw5u87","content":"<h3 id=\"微分方程边界条件\"><a href=\"#微分方程边界条件\" class=\"headerlink\" title=\"微分方程边界条件\"></a>微分方程边界条件</h3><p>以二阶常微分方程为例</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime \\prime}(s)=f\\left(y(s), y^{\\prime}(s), s\\right)</script><p>柯西边界条件（起始值条件）</p>\n<script type=\"math/tex; mode=display\">\ny(a)=\\alpha，\ny^{\\prime}(a)=\\beta</script><p>狄利克雷边界条件（第一类边界条件）</p>\n<script type=\"math/tex; mode=display\">\ny(a)=\\alpha_{1}，y(b)=\\alpha_{2}</script><p>诺依曼边界条件（第二类边界条件）</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime}(a)=\\alpha_{1},y^{\\prime}(b)=\\alpha_{2}</script>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"微分方程边界条件\"><a href=\"#微分方程边界条件\" class=\"headerlink\" title=\"微分方程边界条件\"></a>微分方程边界条件</h3><p>以二阶常微分方程为例</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime \\prime}(s)=f\\left(y(s), y^{\\prime}(s), s\\right)</script><p>柯西边界条件（起始值条件）</p>\n<script type=\"math/tex; mode=display\">\ny(a)=\\alpha，\ny^{\\prime}(a)=\\beta</script><p>狄利克雷边界条件（第一类边界条件）</p>\n<script type=\"math/tex; mode=display\">\ny(a)=\\alpha_{1}，y(b)=\\alpha_{2}</script><p>诺依曼边界条件（第二类边界条件）</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime}(a)=\\alpha_{1},y^{\\prime}(b)=\\alpha_{2}</script>"},{"title":"回归模型","date":"2021-11-05T11:06:19.000Z","math":true,"typora-root-url":"..","_content":"\n### 回归模型\n\n广义线性模型、混合效应模型、高斯过程回归\n\n三种模型中，相对最有名的应是**广义线性模型(GLM)。**包括吴恩达的机器学习课程中也包含GLM。简单来说，广义线性模型是采用线性方法来解决非线性的相关，实际上是一种特殊的非线性模型。 **混合效应模型（MEM）**在固定效应（如线性模型）的基础上加了一项“随机效应”。固定效应通常是传统的线性回归或者其它函数关系。随机效应则与所抽取的样本分布有关。因此随机效应具有先验分布，而固定效应没有。MEM拟合能力较强，相对模型也更容易解释，缺点是需要有大量的项，模型建立时需要自己指定每一项，故而相当繁琐。下面重点介绍一下**高斯过程回归（GPR）**。\n\n\n\n#### Reference\n\n[1] [功能强大的回归模型——高斯过程回归 ](https://mp.weixin.qq.com/s?__biz=Mzg3NTAzOTYzOA==&mid=2247483762&idx=1&sn=23d193866ce6ee128ce9485e90e952f3&chksm=cec6df8bf9b1569d117c4042c81199310d6e652f1fcb0675aa367af7f3ddbdf946c1a7949900&scene=21#wechat_redirect)\n\n[2] [高斯过程的最强实现工具--GPflow OR GPyTorch - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101160180)\n\n","source":"_posts/2021-11-05-回归模型.md","raw":"---\ntitle: 回归模型\ndate: 2021-11-05 19:06:19\ntags:\nmath: true\ntypora-root-url: ..\n---\n\n### 回归模型\n\n广义线性模型、混合效应模型、高斯过程回归\n\n三种模型中，相对最有名的应是**广义线性模型(GLM)。**包括吴恩达的机器学习课程中也包含GLM。简单来说，广义线性模型是采用线性方法来解决非线性的相关，实际上是一种特殊的非线性模型。 **混合效应模型（MEM）**在固定效应（如线性模型）的基础上加了一项“随机效应”。固定效应通常是传统的线性回归或者其它函数关系。随机效应则与所抽取的样本分布有关。因此随机效应具有先验分布，而固定效应没有。MEM拟合能力较强，相对模型也更容易解释，缺点是需要有大量的项，模型建立时需要自己指定每一项，故而相当繁琐。下面重点介绍一下**高斯过程回归（GPR）**。\n\n\n\n#### Reference\n\n[1] [功能强大的回归模型——高斯过程回归 ](https://mp.weixin.qq.com/s?__biz=Mzg3NTAzOTYzOA==&mid=2247483762&idx=1&sn=23d193866ce6ee128ce9485e90e952f3&chksm=cec6df8bf9b1569d117c4042c81199310d6e652f1fcb0675aa367af7f3ddbdf946c1a7949900&scene=21#wechat_redirect)\n\n[2] [高斯过程的最强实现工具--GPflow OR GPyTorch - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101160180)\n\n","slug":"回归模型","published":1,"updated":"2021-11-09T02:00:07.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9t000hy8ux1ysl2soe","content":"<h3 id=\"回归模型\"><a href=\"#回归模型\" class=\"headerlink\" title=\"回归模型\"></a>回归模型</h3><p>广义线性模型、混合效应模型、高斯过程回归</p>\n<p>三种模型中，相对最有名的应是<strong>广义线性模型(GLM)。</strong>包括吴恩达的机器学习课程中也包含GLM。简单来说，广义线性模型是采用线性方法来解决非线性的相关，实际上是一种特殊的非线性模型。 <strong>混合效应模型（MEM）</strong>在固定效应（如线性模型）的基础上加了一项“随机效应”。固定效应通常是传统的线性回归或者其它函数关系。随机效应则与所抽取的样本分布有关。因此随机效应具有先验分布，而固定效应没有。MEM拟合能力较强，相对模型也更容易解释，缺点是需要有大量的项，模型建立时需要自己指定每一项，故而相当繁琐。下面重点介绍一下<strong>高斯过程回归（GPR）</strong>。</p>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p>[1] <a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NTAzOTYzOA==&amp;mid=2247483762&amp;idx=1&amp;sn=23d193866ce6ee128ce9485e90e952f3&amp;chksm=cec6df8bf9b1569d117c4042c81199310d6e652f1fcb0675aa367af7f3ddbdf946c1a7949900&amp;scene=21#wechat_redirect\">功能强大的回归模型——高斯过程回归 </a></p>\n<p>[2] <a href=\"https://zhuanlan.zhihu.com/p/101160180\">高斯过程的最强实现工具—GPflow OR GPyTorch - 知乎 (zhihu.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"回归模型\"><a href=\"#回归模型\" class=\"headerlink\" title=\"回归模型\"></a>回归模型</h3><p>广义线性模型、混合效应模型、高斯过程回归</p>\n<p>三种模型中，相对最有名的应是<strong>广义线性模型(GLM)。</strong>包括吴恩达的机器学习课程中也包含GLM。简单来说，广义线性模型是采用线性方法来解决非线性的相关，实际上是一种特殊的非线性模型。 <strong>混合效应模型（MEM）</strong>在固定效应（如线性模型）的基础上加了一项“随机效应”。固定效应通常是传统的线性回归或者其它函数关系。随机效应则与所抽取的样本分布有关。因此随机效应具有先验分布，而固定效应没有。MEM拟合能力较强，相对模型也更容易解释，缺点是需要有大量的项，模型建立时需要自己指定每一项，故而相当繁琐。下面重点介绍一下<strong>高斯过程回归（GPR）</strong>。</p>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p>[1] <a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NTAzOTYzOA==&amp;mid=2247483762&amp;idx=1&amp;sn=23d193866ce6ee128ce9485e90e952f3&amp;chksm=cec6df8bf9b1569d117c4042c81199310d6e652f1fcb0675aa367af7f3ddbdf946c1a7949900&amp;scene=21#wechat_redirect\">功能强大的回归模型——高斯过程回归 </a></p>\n<p>[2] <a href=\"https://zhuanlan.zhihu.com/p/101160180\">高斯过程的最强实现工具—GPflow OR GPyTorch - 知乎 (zhihu.com)</a></p>\n"},{"title":"代理模型","date":"2021-12-29T12:53:07.258Z","math":true,"typora-root-url":"..","_content":"\n### 代理模型简介\n\n代理模型是复杂工程优化设计问题的关键技术之一。许多复杂问题的优化方法，如遗传算法、模拟退火算法、粒子群算法和蚁群算法等等。与传统的基于梯度的优化方法比，上述这些算法具有很好的鲁棒性、全局性和高度并行性等特点，在多峰值的非线性函数优化问题中得到了成功的应用。但是这些算法的最大缺点是收敛速度慢，需要对目标函数进行大量的评估，如果目标函数评估方法比较耗时(如工程优化中的CFD和FEM分析)，则计算量很大，严重制约了其在工程中的应用。为了克服全局优化算法的这个缺点，人们采用了一种称为代理模型(surrogate model)的方法来代替耗时的精确模型评估。代理模型的计算量比精确模型小得多，同时精度也可以得到保证，采用代理模型可以大大减少优化过程的计算量，提高工程优化设计的效率。常用的代理模型主要包括**插值法**、**响应面模型**、**人工神经元网络模型**、**径向基函数模型**及**Kriging模型**等。其中Kriging模型具有训练样本点处无偏估计、良好的高度非线性近似能力，非常适合作为代理模型使用。目前Kriging模型在工程优化设计领域得到了广泛应用。[1]\n\n这其中，多项式响应面、多项式插值接近于回归拟合领域，比较简单。支持向量机回归（相对于分类支持向量机）其应用较少，在此不做讨论。神经网络作为一套独立的体系，应该说其对原模型的近似程度最高，随着节点和隐含层的增多，实现模型的完美逼近。不过其运算速度也不会很快，且可解释性差，很多网络本身就是一个黑箱。克里金插值和径向基函数插值是目前应用较多的两种方法。\n\n#### 1. 插值法\n\n利用函数f (x)在某区间中插入若干点的函数值，作出适当的特定函数，在这些点上取已知值，在区间的其他点上用这特定函数的值作为函数f (x)的近似值。\n\n#### 2. 响应面模型\n\n也称作响应曲面设计方法(Response Surface Methodology，RSM)，是通过一系列多变量试验，通过多项式回归方程来模拟真实状态曲面的方法。一般情况下，二次回归方程可以给出较为满意的答案，即\n$$\n\\begin{equation}\ny=\\beta_{0}+\\sum_{i=1}^{m} \\beta_{i} x_{i}+\\sum_{i=1}^{m} \\beta_{i i} x_{i} x_{i}+\\sum \\sum_{i<j} \\beta_{i j} x_{i} x_{j}+\\varepsilon\n\\end{equation}\n$$\n写成更紧凑的形式：\n$$\n\\begin{equation}\ny_{i}=\\beta_{0}+\\sum_{j=1}^{k} \\beta_{j} x_{i j}+\\varepsilon_{i} \\quad i=1,2, \\ldots, n\n\\end{equation}\n$$\n多次观测后写成矩阵形式为：\n$$\n\\begin{equation}\n\\mathbf{y}=\\mathbf{X} \\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon}\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\begin{split}\n& \\mathbf{y}=\\left[\\begin{array}{c}\ny_{1} \\\\\ny_{2} \\\\\n\\vdots \\\\\ny_{n}\n\\end{array}\\right], \\mathbf{X}=\\left[\\begin{array}{ccccc}\n1 & x_{11} & x_{12} & \\ldots & x_{1 k} \\\\\n1 & x_{21} & x_{22} & \\ldots & x_{2 k} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & x_{n 1} & x_{n 2} & \\ldots & x_{n k}\n\\end{array}\\right], \\\\\n& \\boldsymbol{\\beta}=\\left[\\begin{array}{c}\n\\beta_{0} \\\\\n\\beta_{1} \\\\\n\\vdots \\\\\n\\beta_{k}\n\\end{array}\\right],\\boldsymbol{\\varepsilon}=\\left[\\begin{array}{c}\n\\varepsilon_{0} \\\\\n\\varepsilon_{1} \\\\\n\\vdots \\\\\n\\varepsilon_{k}\n\\end{array}\\right]\n\\end{split}\n\\end{equation}\n$$\n\n\n观测误差方差为\n$$\n\\mathbf{L}=\\sum_{i=1}^{n} \\varepsilon_{i}^{2}=\\boldsymbol{\\varepsilon}^{\\prime} \\boldsymbol{\\varepsilon}=(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})^{\\prime}(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})\n$$\n当方差最小时，显然拟合曲面和实际值最接近，此时\n$$\n\\left.\\frac{\\partial \\mathbf{L}}{\\partial \\boldsymbol{\\beta}}\\right|_{\\hat{\\beta}}=-2 \\mathbf{X}^{\\prime} \\mathbf{y}+2 \\mathbf{X}^{\\prime} \\mathbf{X} \\hat{\\boldsymbol{\\beta}}=0\n$$\n\n则\n\n$$\n\\hat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^{\\prime} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\prime} \\mathbf{y}\n$$\n\n可得响应面为\n\n$$\n\\hat{\\mathbf{y}}=\\mathbf{X} \\hat{\\boldsymbol{\\beta}}\n$$\n\n#### 3. 神经网络模型\n\n一种万能逼近模型。当代人工智能、深度学习的核心。\n\n#### 4. 径向基函数模型\n\n1985年，Powell提出了多变量插值的径向基函数（RBF）方法。1988年Moody和Darken提出了一种神经网络结构，即RBF神经网络，属于前向神经网络类型，它能够以任意精度逼近任意连续函数，特别适合于解决分类问题。\n\nRBF网络的结构与多层前向网络类似，它是一种三层前向网络。输入层由信号源结点组成，第二层为隐含层，隐单元数视所描述问题的需要而定，隐单元的变换函数是RBF，它是对中心点径向对称且衰减的非负非线性函数，第三层为输出层，它对输入模式的作用作出相应。从输入空间到隐含层空间的变换是非线性的，而从隐含层空间到输出层空间变换是线性的。\n\nRBF网络的基本思想是：用RBF作为隐单元的“基”构成隐含层空间，这样就可以将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和，此处的权即为网络可调参数。从总体上看，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。\n\n<img src=\"/images/2021-11-03-代理模型/RBF.jpg\" alt=\"RBF网络结构\" style=\"zoom:70%;\" />\n\n\n\n#### 5. 克里金模型\n\n克里金（Kriging）模型实际上就是**高斯随机过程模型**，只是实现上稍有不同。\n\n代理模型在**优化过程**中的使用方式非常重要，最常用的也是最简单的方式是以代理模型的预测值为目标函数对其寻优得到校正点，然后把校正点用精确模型评估并把结果用以更新代理模型，依此往复迭代直至收敛。这种选择校正点的方法极易使优化过程陷入局部极值点。Kriging模型与多项式响应面模型及人工神经网络模型最大的不同之处在于，Kriging模型不仅提供了1) 未知点处的**预测值**，还提供了2) 未知点处的**预测标准差**，可以方便地衡量预测的精度。针对简单地对代理模型预测值寻优确定校正点的方法所带来的局部收敛问题。Schonlau提出了以 Kriging 模型为代理模型的 EGO(efficient global optimization)算法， 该算法在 选取校正点时综合考虑了 Kriging 模型的预测值和 预测精度 ，避免了优化过程局部收敛的风险。\n\n##### 5.1 克里金模型的基本理论\n\n###### 形式一 [6]\n\n$$\n\\left\\{\\begin{array}{l}\n\\hat{y}_{1}(x)=\\hat{\\mu}+r^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu}) \\\\\ns_{1}^{2}(x)=\\hat{\\sigma}\\left[1-r^{T} C^{-1} r+\\frac{\\left(1-\\mathbf{1}^{T} C^{-1} r\\right)^{2}}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}}\\right]\n\\end{array}\\right.\n$$\n\n其中\n$$\n\\left\\{\\begin{array}{l}\n\\hat{\\mu}=\\frac{\\mathbf{1}^{T} C^{-1} y}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}} \\\\\n\\hat{\\sigma}^{2}=\\frac{(y-\\mathbf{1} \\hat{\\mu})^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu})}{n}\n\\end{array}\\right.\n$$\n假设有n个数据点，1个预测点。r是数据点X和预测点x之间的协方差矩阵。C是数据点X之间的协方差矩阵。y是数据点的目标值。**1**是n*1的矩阵。\n\n###### 形式二 [7]\n\n$$\n\\left\\{\\begin{array}{l}\n\\hat{y}_{2}(x)=f(x)^{T} \\beta^{*}+r^{T}(x) \\gamma^{*} \\\\\ns_{2}^{2}(x)=\\sigma^{2}\\left(1+u^{T}\\left(F^{T} C^{-1} F\\right)^{-1} u-r^{T} R^{-1} r\\right)\n\\end{array}\\right.\n$$\n\n其中\n$$\n\\left\\{\\begin{array}{l}\n\\beta^{*}=\\left(F^{T} R^{-1} F\\right)^{-1} F^{T} C^{-1} Y \\\\\nC \\gamma^{*}=Y-F \\beta^{*} \\\\\nu=F^{T} C^{-1} r-f(x) \\\\\n\\sigma^{2}=\\frac{1}{m}\\left(Y-F \\beta^{*}\\right)^{T} C^{-1}\\left(Y-F \\beta^{*}\\right)\n\\end{array}\\right.\n$$\n**形式一是形式二在基函数为0次函数(即f(x)=1)时的特例**。\n\n对于形式一，给定数据集为$\\boldsymbol{X}=\\{\\boldsymbol{x}^{1}, \\boldsymbol{x}^{2}, \\ldots, \\boldsymbol{x}^{n}\\}^{T}$​​​​​，对应的目标函数为$\\boldsymbol{y}=\\{y^{1}, y^{2}, \\ldots, y^{n}\\}^{T}$​​​​​克里金法假设所有数据之间都服从n维的正态分布。所以目标函数$\\boldsymbol{y}$​​​​​​是一个随机过程，里面的每一个变量$y_i$​​​都是一个随机变量。我们把这个随机过程记做：\n$$\n\\left(\\begin{array}{c}\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\n\\vdots \\\\\nY\\left(\\boldsymbol{x}^{n}\\right)\n\\end{array}\\right) \\sim N(\\boldsymbol{\\mu}, C)\n$$\n我们把均值取为常数$\\boldsymbol{1}$​ 是n*1的矩阵。协方差取为\n$$\n\\begin{equation}\n\\begin{aligned}\n&\\operatorname{cor}\\left[Y\\left(\\boldsymbol{x}^{i}\\right), Y\\left(\\boldsymbol{x}^{l}\\right)\\right]=\\exp \\left(-\\sum_{j=1}^{k} \\theta_{j}\\left|x_{j}^{i}-x_{j}^{l}\\right|^{2}\\right) \\\\\n&C=\\left(\\begin{array}{ccc}\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right) \\\\\n\\vdots & \\ddots, & \\vdots \\\\\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right)\n\\end{array}\\right)\n\\end{aligned}\n\\end{equation}\n$$\n则Y的条件概率为\n$$\n\\begin{equation}\nL\\left(\\boldsymbol{Y}^{1}, \\boldsymbol{Y}^{2}, \\ldots, \\boldsymbol{Y}^{n} \\mid \\mu, \\sigma\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}} \\exp \\left(-\\frac{\\Sigma\\left(\\boldsymbol{Y}^{i}-\\boldsymbol{\\mu}\\right)^{2}}{2 \\sigma^{2}}\\right)\n\\end{equation}\n$$\n这个条件概率可以表示为\n$$\n\\begin{equation}\nL=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}|C|^{1 / 2}} \\exp \\left[-\\frac{(\\boldsymbol{y}-\\mathbf{1} \\mu)^{T} C^{-1}(\\boldsymbol{y}-\\mathbf{1} \\mu)}{2 \\sigma^{2}}\\right]\n\\end{equation}\n$$\n利用最大似然概率的方法可以得到先验参数$\\hat{\\mu}，\\hat{\\sigma}，\\theta_{i}$​​​​的值，最后通过代入已知和未知点，最大​化对数似然概率函数可得式(9.1)。证明过程详见参考文献[8]。\n\n##### 5.2 改进的EGO算法\n\n选择代理模型预测值的最优点作为校正点的方法称为响应最优策略。如图所示，当最初的样本点分布不均匀时，Kriging模型的预测值在样本点稀疏的地方与真实函数值相差很大，如果以预测值的最优点作为校正点只是使校正后的Kriging模型在样本点集中的区域预测精度不断提高，在样本点稀疏区域预测精度却没有太多变化，如果真实函数的最优值在样本点稀疏区域，则采用最优策略选择校正点就使得优化过程陷入了局部极值点，可见为了避免采用响应最优策略确定校正点所带来的局部收敛问题，有必要在选择校正点时综合考虑Kriging模型的预测值与预测标准差。\n\n<img src=\"/images/2021-11-03-代理模型/Kriging模型.png\" alt=\"Kriging模型拟合函数示意图\" style=\"zoom: 20%;\" />\n\nJones 和 Schonlau提出的EGO算法是一种贝叶斯全局优化算法，针对式(10)表示的一般形式的优化问题，其基本流程为:\n\n1. 在设计空间中，利用试验设计方法(DOE)生成初始样本库。\n2. 采用Kriging模型分别构建设计变量与目标函数、约束函数间的近似映射关系。\n3. EI (expected improvement)函数的值为目标函数，选择使其最大的点作为校正点。\n4. 对校正点采用高精度初始模型评估得到校正点的响应值，把校正点及其响应值加入样本库中。\n5. 重复步骤(2),(3),(4)直至收敛。\n\n其中EI函数(加点准则)定义为:\n$$\n\\begin{equation}\nEI(\\boldsymbol{x})=\\left(y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})\\right) \\Phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)+s_{\\hat{y}}(\\boldsymbol{x}) \\phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)\n\\end{equation}\n$$\n其中$y_{\\min } $​​为当前试验点上的目标函数的最小值，$\\mu_{\\hat{y}}(\\boldsymbol{x})$​​和$s_{\\hat{y}}$​​分别是$\\boldsymbol{x}$​​处的Kriging模型的预测值和标准差，$\\phi( )$​​和$\\Phi( )$​​分别是标准正态分布的密度函数和分布函数。\n\nEGO算法将EI准则的最大值点作为新增试验点，故EGO算法倾向于在Kriging模型预测值优（小）和预测不确定性大（预测标准差大）的地方添加新试验点，兼具了开发局部最优区域和探索潜在最优区域的功能。\n\nEI加点准则巧妙利用了Kriging模型的预测不确定性度量能力，倾向于在Kriging模型预测值优和不确定性大的地方添加新试验点，保证了EGO算法的收敛效率和全局收敛性。此后的代理优化算法，大多沿袭了EGO算法的自适应优化思想，并致力于设计出合理的兼具局部开发和全局探索功能的加点准则。\n\n#### 6. 多精度代理模型\n\n代理模型的预测精度取决于其训练集的精度，可以想象训练集的精度越高、数量越多，训练得到的代理模型精度也会越高。但是在实际应用过程中，如果要获取大量高精度训练集需要耗费过多的时间和计算资源，因此为了解决这一问题，我们可以考虑使用多精度代理模型（multi-fidelity surrogate model）。多精度代理模型的出发点是希望能够用**大量低精度**的数据和**少量高精度**的数据构建高精度代理模型，这样就可以大大江都获取高精度代理模型的难度。\n\n\n\n\n\n#### Reference\n\n[1]王红涛,竺晓程,杜朝辉.基于Kriging代理模型的改进EGO算法研究[J].工程设计学报,2009,16(04):266-270+302.\n\n[2]张建侠. 基于Kriging模型的全局代理优化算法研究[D].南京理工大学,2018.\n\n[3]乐春宇,马义中,张建侠.结合Kriging和物理规划的多目标代理优化算法[J].计算机工程与应用,2019,55(21):240-246.\n\n[4]乐春宇. 基于Kriging模型的代理优化理论研究和应用[D].南京理工大学,2020.\n\n[5] 偷天换日，斗转星移——代理优化算法 https://zhuanlan.zhihu.com/p/99609634\n\n[6] Zhan, D., et al. (2017). \"Expected Improvement Matrix-Based Infill Criteria for Expensive Multiobjective Optimization.\" IEEE Transactions on Evolutionary Computation 21(6): 956-975.\n\n[7] Sacks, Jerome, et al. \"Design and analysis of computer experiments.\"*Statistical science*(1989): 409-423.\n\n[8] [克里金(Kriging)模型详细推导 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/377620800)\n\n[9] [Multi-fidelity optimization via surrogate modelling](https://link.jianshu.com?t=http%3A%2F%2Fwww.southampton.ac.uk%2F~aijf197%2F07PA0124.pdf) by Alexander I. J. Forrester, Andras Sobester and Andy J. Keane\n\n\n\n\n\n","source":"_posts/2021-11-03-代理模型.md","raw":"---\ntitle: 代理模型\ndate: 2021-11-0310:44:23\ntags:\nmath: true\ntypora-root-url: ..\n---\n\n### 代理模型简介\n\n代理模型是复杂工程优化设计问题的关键技术之一。许多复杂问题的优化方法，如遗传算法、模拟退火算法、粒子群算法和蚁群算法等等。与传统的基于梯度的优化方法比，上述这些算法具有很好的鲁棒性、全局性和高度并行性等特点，在多峰值的非线性函数优化问题中得到了成功的应用。但是这些算法的最大缺点是收敛速度慢，需要对目标函数进行大量的评估，如果目标函数评估方法比较耗时(如工程优化中的CFD和FEM分析)，则计算量很大，严重制约了其在工程中的应用。为了克服全局优化算法的这个缺点，人们采用了一种称为代理模型(surrogate model)的方法来代替耗时的精确模型评估。代理模型的计算量比精确模型小得多，同时精度也可以得到保证，采用代理模型可以大大减少优化过程的计算量，提高工程优化设计的效率。常用的代理模型主要包括**插值法**、**响应面模型**、**人工神经元网络模型**、**径向基函数模型**及**Kriging模型**等。其中Kriging模型具有训练样本点处无偏估计、良好的高度非线性近似能力，非常适合作为代理模型使用。目前Kriging模型在工程优化设计领域得到了广泛应用。[1]\n\n这其中，多项式响应面、多项式插值接近于回归拟合领域，比较简单。支持向量机回归（相对于分类支持向量机）其应用较少，在此不做讨论。神经网络作为一套独立的体系，应该说其对原模型的近似程度最高，随着节点和隐含层的增多，实现模型的完美逼近。不过其运算速度也不会很快，且可解释性差，很多网络本身就是一个黑箱。克里金插值和径向基函数插值是目前应用较多的两种方法。\n\n#### 1. 插值法\n\n利用函数f (x)在某区间中插入若干点的函数值，作出适当的特定函数，在这些点上取已知值，在区间的其他点上用这特定函数的值作为函数f (x)的近似值。\n\n#### 2. 响应面模型\n\n也称作响应曲面设计方法(Response Surface Methodology，RSM)，是通过一系列多变量试验，通过多项式回归方程来模拟真实状态曲面的方法。一般情况下，二次回归方程可以给出较为满意的答案，即\n$$\n\\begin{equation}\ny=\\beta_{0}+\\sum_{i=1}^{m} \\beta_{i} x_{i}+\\sum_{i=1}^{m} \\beta_{i i} x_{i} x_{i}+\\sum \\sum_{i<j} \\beta_{i j} x_{i} x_{j}+\\varepsilon\n\\end{equation}\n$$\n写成更紧凑的形式：\n$$\n\\begin{equation}\ny_{i}=\\beta_{0}+\\sum_{j=1}^{k} \\beta_{j} x_{i j}+\\varepsilon_{i} \\quad i=1,2, \\ldots, n\n\\end{equation}\n$$\n多次观测后写成矩阵形式为：\n$$\n\\begin{equation}\n\\mathbf{y}=\\mathbf{X} \\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon}\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\begin{split}\n& \\mathbf{y}=\\left[\\begin{array}{c}\ny_{1} \\\\\ny_{2} \\\\\n\\vdots \\\\\ny_{n}\n\\end{array}\\right], \\mathbf{X}=\\left[\\begin{array}{ccccc}\n1 & x_{11} & x_{12} & \\ldots & x_{1 k} \\\\\n1 & x_{21} & x_{22} & \\ldots & x_{2 k} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & x_{n 1} & x_{n 2} & \\ldots & x_{n k}\n\\end{array}\\right], \\\\\n& \\boldsymbol{\\beta}=\\left[\\begin{array}{c}\n\\beta_{0} \\\\\n\\beta_{1} \\\\\n\\vdots \\\\\n\\beta_{k}\n\\end{array}\\right],\\boldsymbol{\\varepsilon}=\\left[\\begin{array}{c}\n\\varepsilon_{0} \\\\\n\\varepsilon_{1} \\\\\n\\vdots \\\\\n\\varepsilon_{k}\n\\end{array}\\right]\n\\end{split}\n\\end{equation}\n$$\n\n\n观测误差方差为\n$$\n\\mathbf{L}=\\sum_{i=1}^{n} \\varepsilon_{i}^{2}=\\boldsymbol{\\varepsilon}^{\\prime} \\boldsymbol{\\varepsilon}=(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})^{\\prime}(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})\n$$\n当方差最小时，显然拟合曲面和实际值最接近，此时\n$$\n\\left.\\frac{\\partial \\mathbf{L}}{\\partial \\boldsymbol{\\beta}}\\right|_{\\hat{\\beta}}=-2 \\mathbf{X}^{\\prime} \\mathbf{y}+2 \\mathbf{X}^{\\prime} \\mathbf{X} \\hat{\\boldsymbol{\\beta}}=0\n$$\n\n则\n\n$$\n\\hat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^{\\prime} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\prime} \\mathbf{y}\n$$\n\n可得响应面为\n\n$$\n\\hat{\\mathbf{y}}=\\mathbf{X} \\hat{\\boldsymbol{\\beta}}\n$$\n\n#### 3. 神经网络模型\n\n一种万能逼近模型。当代人工智能、深度学习的核心。\n\n#### 4. 径向基函数模型\n\n1985年，Powell提出了多变量插值的径向基函数（RBF）方法。1988年Moody和Darken提出了一种神经网络结构，即RBF神经网络，属于前向神经网络类型，它能够以任意精度逼近任意连续函数，特别适合于解决分类问题。\n\nRBF网络的结构与多层前向网络类似，它是一种三层前向网络。输入层由信号源结点组成，第二层为隐含层，隐单元数视所描述问题的需要而定，隐单元的变换函数是RBF，它是对中心点径向对称且衰减的非负非线性函数，第三层为输出层，它对输入模式的作用作出相应。从输入空间到隐含层空间的变换是非线性的，而从隐含层空间到输出层空间变换是线性的。\n\nRBF网络的基本思想是：用RBF作为隐单元的“基”构成隐含层空间，这样就可以将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和，此处的权即为网络可调参数。从总体上看，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。\n\n<img src=\"/images/2021-11-03-代理模型/RBF.jpg\" alt=\"RBF网络结构\" style=\"zoom:70%;\" />\n\n\n\n#### 5. 克里金模型\n\n克里金（Kriging）模型实际上就是**高斯随机过程模型**，只是实现上稍有不同。\n\n代理模型在**优化过程**中的使用方式非常重要，最常用的也是最简单的方式是以代理模型的预测值为目标函数对其寻优得到校正点，然后把校正点用精确模型评估并把结果用以更新代理模型，依此往复迭代直至收敛。这种选择校正点的方法极易使优化过程陷入局部极值点。Kriging模型与多项式响应面模型及人工神经网络模型最大的不同之处在于，Kriging模型不仅提供了1) 未知点处的**预测值**，还提供了2) 未知点处的**预测标准差**，可以方便地衡量预测的精度。针对简单地对代理模型预测值寻优确定校正点的方法所带来的局部收敛问题。Schonlau提出了以 Kriging 模型为代理模型的 EGO(efficient global optimization)算法， 该算法在 选取校正点时综合考虑了 Kriging 模型的预测值和 预测精度 ，避免了优化过程局部收敛的风险。\n\n##### 5.1 克里金模型的基本理论\n\n###### 形式一 [6]\n\n$$\n\\left\\{\\begin{array}{l}\n\\hat{y}_{1}(x)=\\hat{\\mu}+r^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu}) \\\\\ns_{1}^{2}(x)=\\hat{\\sigma}\\left[1-r^{T} C^{-1} r+\\frac{\\left(1-\\mathbf{1}^{T} C^{-1} r\\right)^{2}}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}}\\right]\n\\end{array}\\right.\n$$\n\n其中\n$$\n\\left\\{\\begin{array}{l}\n\\hat{\\mu}=\\frac{\\mathbf{1}^{T} C^{-1} y}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}} \\\\\n\\hat{\\sigma}^{2}=\\frac{(y-\\mathbf{1} \\hat{\\mu})^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu})}{n}\n\\end{array}\\right.\n$$\n假设有n个数据点，1个预测点。r是数据点X和预测点x之间的协方差矩阵。C是数据点X之间的协方差矩阵。y是数据点的目标值。**1**是n*1的矩阵。\n\n###### 形式二 [7]\n\n$$\n\\left\\{\\begin{array}{l}\n\\hat{y}_{2}(x)=f(x)^{T} \\beta^{*}+r^{T}(x) \\gamma^{*} \\\\\ns_{2}^{2}(x)=\\sigma^{2}\\left(1+u^{T}\\left(F^{T} C^{-1} F\\right)^{-1} u-r^{T} R^{-1} r\\right)\n\\end{array}\\right.\n$$\n\n其中\n$$\n\\left\\{\\begin{array}{l}\n\\beta^{*}=\\left(F^{T} R^{-1} F\\right)^{-1} F^{T} C^{-1} Y \\\\\nC \\gamma^{*}=Y-F \\beta^{*} \\\\\nu=F^{T} C^{-1} r-f(x) \\\\\n\\sigma^{2}=\\frac{1}{m}\\left(Y-F \\beta^{*}\\right)^{T} C^{-1}\\left(Y-F \\beta^{*}\\right)\n\\end{array}\\right.\n$$\n**形式一是形式二在基函数为0次函数(即f(x)=1)时的特例**。\n\n对于形式一，给定数据集为$\\boldsymbol{X}=\\{\\boldsymbol{x}^{1}, \\boldsymbol{x}^{2}, \\ldots, \\boldsymbol{x}^{n}\\}^{T}$​​​​​，对应的目标函数为$\\boldsymbol{y}=\\{y^{1}, y^{2}, \\ldots, y^{n}\\}^{T}$​​​​​克里金法假设所有数据之间都服从n维的正态分布。所以目标函数$\\boldsymbol{y}$​​​​​​是一个随机过程，里面的每一个变量$y_i$​​​都是一个随机变量。我们把这个随机过程记做：\n$$\n\\left(\\begin{array}{c}\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\n\\vdots \\\\\nY\\left(\\boldsymbol{x}^{n}\\right)\n\\end{array}\\right) \\sim N(\\boldsymbol{\\mu}, C)\n$$\n我们把均值取为常数$\\boldsymbol{1}$​ 是n*1的矩阵。协方差取为\n$$\n\\begin{equation}\n\\begin{aligned}\n&\\operatorname{cor}\\left[Y\\left(\\boldsymbol{x}^{i}\\right), Y\\left(\\boldsymbol{x}^{l}\\right)\\right]=\\exp \\left(-\\sum_{j=1}^{k} \\theta_{j}\\left|x_{j}^{i}-x_{j}^{l}\\right|^{2}\\right) \\\\\n&C=\\left(\\begin{array}{ccc}\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right) \\\\\n\\vdots & \\ddots, & \\vdots \\\\\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right)\n\\end{array}\\right)\n\\end{aligned}\n\\end{equation}\n$$\n则Y的条件概率为\n$$\n\\begin{equation}\nL\\left(\\boldsymbol{Y}^{1}, \\boldsymbol{Y}^{2}, \\ldots, \\boldsymbol{Y}^{n} \\mid \\mu, \\sigma\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}} \\exp \\left(-\\frac{\\Sigma\\left(\\boldsymbol{Y}^{i}-\\boldsymbol{\\mu}\\right)^{2}}{2 \\sigma^{2}}\\right)\n\\end{equation}\n$$\n这个条件概率可以表示为\n$$\n\\begin{equation}\nL=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}|C|^{1 / 2}} \\exp \\left[-\\frac{(\\boldsymbol{y}-\\mathbf{1} \\mu)^{T} C^{-1}(\\boldsymbol{y}-\\mathbf{1} \\mu)}{2 \\sigma^{2}}\\right]\n\\end{equation}\n$$\n利用最大似然概率的方法可以得到先验参数$\\hat{\\mu}，\\hat{\\sigma}，\\theta_{i}$​​​​的值，最后通过代入已知和未知点，最大​化对数似然概率函数可得式(9.1)。证明过程详见参考文献[8]。\n\n##### 5.2 改进的EGO算法\n\n选择代理模型预测值的最优点作为校正点的方法称为响应最优策略。如图所示，当最初的样本点分布不均匀时，Kriging模型的预测值在样本点稀疏的地方与真实函数值相差很大，如果以预测值的最优点作为校正点只是使校正后的Kriging模型在样本点集中的区域预测精度不断提高，在样本点稀疏区域预测精度却没有太多变化，如果真实函数的最优值在样本点稀疏区域，则采用最优策略选择校正点就使得优化过程陷入了局部极值点，可见为了避免采用响应最优策略确定校正点所带来的局部收敛问题，有必要在选择校正点时综合考虑Kriging模型的预测值与预测标准差。\n\n<img src=\"/images/2021-11-03-代理模型/Kriging模型.png\" alt=\"Kriging模型拟合函数示意图\" style=\"zoom: 20%;\" />\n\nJones 和 Schonlau提出的EGO算法是一种贝叶斯全局优化算法，针对式(10)表示的一般形式的优化问题，其基本流程为:\n\n1. 在设计空间中，利用试验设计方法(DOE)生成初始样本库。\n2. 采用Kriging模型分别构建设计变量与目标函数、约束函数间的近似映射关系。\n3. EI (expected improvement)函数的值为目标函数，选择使其最大的点作为校正点。\n4. 对校正点采用高精度初始模型评估得到校正点的响应值，把校正点及其响应值加入样本库中。\n5. 重复步骤(2),(3),(4)直至收敛。\n\n其中EI函数(加点准则)定义为:\n$$\n\\begin{equation}\nEI(\\boldsymbol{x})=\\left(y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})\\right) \\Phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)+s_{\\hat{y}}(\\boldsymbol{x}) \\phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)\n\\end{equation}\n$$\n其中$y_{\\min } $​​为当前试验点上的目标函数的最小值，$\\mu_{\\hat{y}}(\\boldsymbol{x})$​​和$s_{\\hat{y}}$​​分别是$\\boldsymbol{x}$​​处的Kriging模型的预测值和标准差，$\\phi( )$​​和$\\Phi( )$​​分别是标准正态分布的密度函数和分布函数。\n\nEGO算法将EI准则的最大值点作为新增试验点，故EGO算法倾向于在Kriging模型预测值优（小）和预测不确定性大（预测标准差大）的地方添加新试验点，兼具了开发局部最优区域和探索潜在最优区域的功能。\n\nEI加点准则巧妙利用了Kriging模型的预测不确定性度量能力，倾向于在Kriging模型预测值优和不确定性大的地方添加新试验点，保证了EGO算法的收敛效率和全局收敛性。此后的代理优化算法，大多沿袭了EGO算法的自适应优化思想，并致力于设计出合理的兼具局部开发和全局探索功能的加点准则。\n\n#### 6. 多精度代理模型\n\n代理模型的预测精度取决于其训练集的精度，可以想象训练集的精度越高、数量越多，训练得到的代理模型精度也会越高。但是在实际应用过程中，如果要获取大量高精度训练集需要耗费过多的时间和计算资源，因此为了解决这一问题，我们可以考虑使用多精度代理模型（multi-fidelity surrogate model）。多精度代理模型的出发点是希望能够用**大量低精度**的数据和**少量高精度**的数据构建高精度代理模型，这样就可以大大江都获取高精度代理模型的难度。\n\n\n\n\n\n#### Reference\n\n[1]王红涛,竺晓程,杜朝辉.基于Kriging代理模型的改进EGO算法研究[J].工程设计学报,2009,16(04):266-270+302.\n\n[2]张建侠. 基于Kriging模型的全局代理优化算法研究[D].南京理工大学,2018.\n\n[3]乐春宇,马义中,张建侠.结合Kriging和物理规划的多目标代理优化算法[J].计算机工程与应用,2019,55(21):240-246.\n\n[4]乐春宇. 基于Kriging模型的代理优化理论研究和应用[D].南京理工大学,2020.\n\n[5] 偷天换日，斗转星移——代理优化算法 https://zhuanlan.zhihu.com/p/99609634\n\n[6] Zhan, D., et al. (2017). \"Expected Improvement Matrix-Based Infill Criteria for Expensive Multiobjective Optimization.\" IEEE Transactions on Evolutionary Computation 21(6): 956-975.\n\n[7] Sacks, Jerome, et al. \"Design and analysis of computer experiments.\"*Statistical science*(1989): 409-423.\n\n[8] [克里金(Kriging)模型详细推导 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/377620800)\n\n[9] [Multi-fidelity optimization via surrogate modelling](https://link.jianshu.com?t=http%3A%2F%2Fwww.southampton.ac.uk%2F~aijf197%2F07PA0124.pdf) by Alexander I. J. Forrester, Andras Sobester and Andy J. Keane\n\n\n\n\n\n","slug":"代理模型","published":1,"updated":"2021-12-29T12:53:07.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9v000ly8uxc6q8g4x3","content":"<h3 id=\"代理模型简介\"><a href=\"#代理模型简介\" class=\"headerlink\" title=\"代理模型简介\"></a>代理模型简介</h3><p>代理模型是复杂工程优化设计问题的关键技术之一。许多复杂问题的优化方法，如遗传算法、模拟退火算法、粒子群算法和蚁群算法等等。与传统的基于梯度的优化方法比，上述这些算法具有很好的鲁棒性、全局性和高度并行性等特点，在多峰值的非线性函数优化问题中得到了成功的应用。但是这些算法的最大缺点是收敛速度慢，需要对目标函数进行大量的评估，如果目标函数评估方法比较耗时(如工程优化中的CFD和FEM分析)，则计算量很大，严重制约了其在工程中的应用。为了克服全局优化算法的这个缺点，人们采用了一种称为代理模型(surrogate model)的方法来代替耗时的精确模型评估。代理模型的计算量比精确模型小得多，同时精度也可以得到保证，采用代理模型可以大大减少优化过程的计算量，提高工程优化设计的效率。常用的代理模型主要包括<strong>插值法</strong>、<strong>响应面模型</strong>、<strong>人工神经元网络模型</strong>、<strong>径向基函数模型</strong>及<strong>Kriging模型</strong>等。其中Kriging模型具有训练样本点处无偏估计、良好的高度非线性近似能力，非常适合作为代理模型使用。目前Kriging模型在工程优化设计领域得到了广泛应用。[1]</p>\n<p>这其中，多项式响应面、多项式插值接近于回归拟合领域，比较简单。支持向量机回归（相对于分类支持向量机）其应用较少，在此不做讨论。神经网络作为一套独立的体系，应该说其对原模型的近似程度最高，随着节点和隐含层的增多，实现模型的完美逼近。不过其运算速度也不会很快，且可解释性差，很多网络本身就是一个黑箱。克里金插值和径向基函数插值是目前应用较多的两种方法。</p>\n<h4 id=\"1-插值法\"><a href=\"#1-插值法\" class=\"headerlink\" title=\"1. 插值法\"></a>1. 插值法</h4><p>利用函数f (x)在某区间中插入若干点的函数值，作出适当的特定函数，在这些点上取已知值，在区间的其他点上用这特定函数的值作为函数f (x)的近似值。</p>\n<h4 id=\"2-响应面模型\"><a href=\"#2-响应面模型\" class=\"headerlink\" title=\"2. 响应面模型\"></a>2. 响应面模型</h4><p>也称作响应曲面设计方法(Response Surface Methodology，RSM)，是通过一系列多变量试验，通过多项式回归方程来模拟真实状态曲面的方法。一般情况下，二次回归方程可以给出较为满意的答案，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny=\\beta_{0}+\\sum_{i=1}^{m} \\beta_{i} x_{i}+\\sum_{i=1}^{m} \\beta_{i i} x_{i} x_{i}+\\sum \\sum_{i<j} \\beta_{i j} x_{i} x_{j}+\\varepsilon\n\\end{equation}</script><p>写成更紧凑的形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny_{i}=\\beta_{0}+\\sum_{j=1}^{k} \\beta_{j} x_{i j}+\\varepsilon_{i} \\quad i=1,2, \\ldots, n\n\\end{equation}</script><p>多次观测后写成矩阵形式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\mathbf{y}=\\mathbf{X} \\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon}\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{split}\n& \\mathbf{y}=\\left[\\begin{array}{c}\ny_{1} \\\\\ny_{2} \\\\\n\\vdots \\\\\ny_{n}\n\\end{array}\\right], \\mathbf{X}=\\left[\\begin{array}{ccccc}\n1 & x_{11} & x_{12} & \\ldots & x_{1 k} \\\\\n1 & x_{21} & x_{22} & \\ldots & x_{2 k} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & x_{n 1} & x_{n 2} & \\ldots & x_{n k}\n\\end{array}\\right], \\\\\n& \\boldsymbol{\\beta}=\\left[\\begin{array}{c}\n\\beta_{0} \\\\\n\\beta_{1} \\\\\n\\vdots \\\\\n\\beta_{k}\n\\end{array}\\right],\\boldsymbol{\\varepsilon}=\\left[\\begin{array}{c}\n\\varepsilon_{0} \\\\\n\\varepsilon_{1} \\\\\n\\vdots \\\\\n\\varepsilon_{k}\n\\end{array}\\right]\n\\end{split}\n\\end{equation}</script><p>观测误差方差为</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{L}=\\sum_{i=1}^{n} \\varepsilon_{i}^{2}=\\boldsymbol{\\varepsilon}^{\\prime} \\boldsymbol{\\varepsilon}=(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})^{\\prime}(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})</script><p>当方差最小时，显然拟合曲面和实际值最接近，此时</p>\n<script type=\"math/tex; mode=display\">\n\\left.\\frac{\\partial \\mathbf{L}}{\\partial \\boldsymbol{\\beta}}\\right|_{\\hat{\\beta}}=-2 \\mathbf{X}^{\\prime} \\mathbf{y}+2 \\mathbf{X}^{\\prime} \\mathbf{X} \\hat{\\boldsymbol{\\beta}}=0</script><p>则</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^{\\prime} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\prime} \\mathbf{y}</script><p>可得响应面为</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\mathbf{y}}=\\mathbf{X} \\hat{\\boldsymbol{\\beta}}</script><h4 id=\"3-神经网络模型\"><a href=\"#3-神经网络模型\" class=\"headerlink\" title=\"3. 神经网络模型\"></a>3. 神经网络模型</h4><p>一种万能逼近模型。当代人工智能、深度学习的核心。</p>\n<h4 id=\"4-径向基函数模型\"><a href=\"#4-径向基函数模型\" class=\"headerlink\" title=\"4. 径向基函数模型\"></a>4. 径向基函数模型</h4><p>1985年，Powell提出了多变量插值的径向基函数（RBF）方法。1988年Moody和Darken提出了一种神经网络结构，即RBF神经网络，属于前向神经网络类型，它能够以任意精度逼近任意连续函数，特别适合于解决分类问题。</p>\n<p>RBF网络的结构与多层前向网络类似，它是一种三层前向网络。输入层由信号源结点组成，第二层为隐含层，隐单元数视所描述问题的需要而定，隐单元的变换函数是RBF，它是对中心点径向对称且衰减的非负非线性函数，第三层为输出层，它对输入模式的作用作出相应。从输入空间到隐含层空间的变换是非线性的，而从隐含层空间到输出层空间变换是线性的。</p>\n<p>RBF网络的基本思想是：用RBF作为隐单元的“基”构成隐含层空间，这样就可以将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和，此处的权即为网络可调参数。从总体上看，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p>\n<p><img src=\"/images/2021-11-03-代理模型/RBF.jpg\" alt=\"RBF网络结构\" style=\"zoom:70%;\" /></p>\n<h4 id=\"5-克里金模型\"><a href=\"#5-克里金模型\" class=\"headerlink\" title=\"5. 克里金模型\"></a>5. 克里金模型</h4><p>克里金（Kriging）模型实际上就是<strong>高斯随机过程模型</strong>，只是实现上稍有不同。</p>\n<p>代理模型在<strong>优化过程</strong>中的使用方式非常重要，最常用的也是最简单的方式是以代理模型的预测值为目标函数对其寻优得到校正点，然后把校正点用精确模型评估并把结果用以更新代理模型，依此往复迭代直至收敛。这种选择校正点的方法极易使优化过程陷入局部极值点。Kriging模型与多项式响应面模型及人工神经网络模型最大的不同之处在于，Kriging模型不仅提供了1) 未知点处的<strong>预测值</strong>，还提供了2) 未知点处的<strong>预测标准差</strong>，可以方便地衡量预测的精度。针对简单地对代理模型预测值寻优确定校正点的方法所带来的局部收敛问题。Schonlau提出了以 Kriging 模型为代理模型的 EGO(efficient global optimization)算法， 该算法在 选取校正点时综合考虑了 Kriging 模型的预测值和 预测精度 ，避免了优化过程局部收敛的风险。</p>\n<h5 id=\"5-1-克里金模型的基本理论\"><a href=\"#5-1-克里金模型的基本理论\" class=\"headerlink\" title=\"5.1 克里金模型的基本理论\"></a>5.1 克里金模型的基本理论</h5><h6 id=\"形式一-6\"><a href=\"#形式一-6\" class=\"headerlink\" title=\"形式一 [6]\"></a>形式一 [6]</h6><script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{y}_{1}(x)=\\hat{\\mu}+r^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu}) \\\\\ns_{1}^{2}(x)=\\hat{\\sigma}\\left[1-r^{T} C^{-1} r+\\frac{\\left(1-\\mathbf{1}^{T} C^{-1} r\\right)^{2}}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}}\\right]\n\\end{array}\\right.</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{\\mu}=\\frac{\\mathbf{1}^{T} C^{-1} y}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}} \\\\\n\\hat{\\sigma}^{2}=\\frac{(y-\\mathbf{1} \\hat{\\mu})^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu})}{n}\n\\end{array}\\right.</script><p>假设有n个数据点，1个预测点。r是数据点X和预测点x之间的协方差矩阵。C是数据点X之间的协方差矩阵。y是数据点的目标值。<strong>1</strong>是n*1的矩阵。</p>\n<h6 id=\"形式二-7\"><a href=\"#形式二-7\" class=\"headerlink\" title=\"形式二 [7]\"></a>形式二 [7]</h6><script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{y}_{2}(x)=f(x)^{T} \\beta^{*}+r^{T}(x) \\gamma^{*} \\\\\ns_{2}^{2}(x)=\\sigma^{2}\\left(1+u^{T}\\left(F^{T} C^{-1} F\\right)^{-1} u-r^{T} R^{-1} r\\right)\n\\end{array}\\right.</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\beta^{*}=\\left(F^{T} R^{-1} F\\right)^{-1} F^{T} C^{-1} Y \\\\\nC \\gamma^{*}=Y-F \\beta^{*} \\\\\nu=F^{T} C^{-1} r-f(x) \\\\\n\\sigma^{2}=\\frac{1}{m}\\left(Y-F \\beta^{*}\\right)^{T} C^{-1}\\left(Y-F \\beta^{*}\\right)\n\\end{array}\\right.</script><p><strong>形式一是形式二在基函数为0次函数(即f(x)=1)时的特例</strong>。</p>\n<p>对于形式一，给定数据集为$\\boldsymbol{X}=\\{\\boldsymbol{x}^{1}, \\boldsymbol{x}^{2}, \\ldots, \\boldsymbol{x}^{n}\\}^{T}$​​​​​，对应的目标函数为$\\boldsymbol{y}=\\{y^{1}, y^{2}, \\ldots, y^{n}\\}^{T}$​​​​​克里金法假设所有数据之间都服从n维的正态分布。所以目标函数$\\boldsymbol{y}$​​​​​​是一个随机过程，里面的每一个变量$y_i$​​​都是一个随机变量。我们把这个随机过程记做：</p>\n<script type=\"math/tex; mode=display\">\n\\left(\\begin{array}{c}\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\n\\vdots \\\\\nY\\left(\\boldsymbol{x}^{n}\\right)\n\\end{array}\\right) \\sim N(\\boldsymbol{\\mu}, C)</script><p>我们把均值取为常数$\\boldsymbol{1}$​ 是n*1的矩阵。协方差取为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{aligned}\n&\\operatorname{cor}\\left[Y\\left(\\boldsymbol{x}^{i}\\right), Y\\left(\\boldsymbol{x}^{l}\\right)\\right]=\\exp \\left(-\\sum_{j=1}^{k} \\theta_{j}\\left|x_{j}^{i}-x_{j}^{l}\\right|^{2}\\right) \\\\\n&C=\\left(\\begin{array}{ccc}\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right) \\\\\n\\vdots & \\ddots, & \\vdots \\\\\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right)\n\\end{array}\\right)\n\\end{aligned}\n\\end{equation}</script><p>则Y的条件概率为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nL\\left(\\boldsymbol{Y}^{1}, \\boldsymbol{Y}^{2}, \\ldots, \\boldsymbol{Y}^{n} \\mid \\mu, \\sigma\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}} \\exp \\left(-\\frac{\\Sigma\\left(\\boldsymbol{Y}^{i}-\\boldsymbol{\\mu}\\right)^{2}}{2 \\sigma^{2}}\\right)\n\\end{equation}</script><p>这个条件概率可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nL=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}|C|^{1 / 2}} \\exp \\left[-\\frac{(\\boldsymbol{y}-\\mathbf{1} \\mu)^{T} C^{-1}(\\boldsymbol{y}-\\mathbf{1} \\mu)}{2 \\sigma^{2}}\\right]\n\\end{equation}</script><p>利用最大似然概率的方法可以得到先验参数$\\hat{\\mu}，\\hat{\\sigma}，\\theta_{i}$​​​​的值，最后通过代入已知和未知点，最大​化对数似然概率函数可得式(9.1)。证明过程详见参考文献[8]。</p>\n<h5 id=\"5-2-改进的EGO算法\"><a href=\"#5-2-改进的EGO算法\" class=\"headerlink\" title=\"5.2 改进的EGO算法\"></a>5.2 改进的EGO算法</h5><p>选择代理模型预测值的最优点作为校正点的方法称为响应最优策略。如图所示，当最初的样本点分布不均匀时，Kriging模型的预测值在样本点稀疏的地方与真实函数值相差很大，如果以预测值的最优点作为校正点只是使校正后的Kriging模型在样本点集中的区域预测精度不断提高，在样本点稀疏区域预测精度却没有太多变化，如果真实函数的最优值在样本点稀疏区域，则采用最优策略选择校正点就使得优化过程陷入了局部极值点，可见为了避免采用响应最优策略确定校正点所带来的局部收敛问题，有必要在选择校正点时综合考虑Kriging模型的预测值与预测标准差。</p>\n<p><img src=\"/images/2021-11-03-代理模型/Kriging模型.png\" alt=\"Kriging模型拟合函数示意图\" style=\"zoom: 20%;\" /></p>\n<p>Jones 和 Schonlau提出的EGO算法是一种贝叶斯全局优化算法，针对式(10)表示的一般形式的优化问题，其基本流程为:</p>\n<ol>\n<li>在设计空间中，利用试验设计方法(DOE)生成初始样本库。</li>\n<li>采用Kriging模型分别构建设计变量与目标函数、约束函数间的近似映射关系。</li>\n<li>EI (expected improvement)函数的值为目标函数，选择使其最大的点作为校正点。</li>\n<li>对校正点采用高精度初始模型评估得到校正点的响应值，把校正点及其响应值加入样本库中。</li>\n<li>重复步骤(2),(3),(4)直至收敛。</li>\n</ol>\n<p>其中EI函数(加点准则)定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nEI(\\boldsymbol{x})=\\left(y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})\\right) \\Phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)+s_{\\hat{y}}(\\boldsymbol{x}) \\phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)\n\\end{equation}</script><p>其中$y_{\\min } $​​为当前试验点上的目标函数的最小值，$\\mu_{\\hat{y}}(\\boldsymbol{x})$​​和$s_{\\hat{y}}$​​分别是$\\boldsymbol{x}$​​处的Kriging模型的预测值和标准差，$\\phi( )$​​和$\\Phi( )$​​分别是标准正态分布的密度函数和分布函数。</p>\n<p>EGO算法将EI准则的最大值点作为新增试验点，故EGO算法倾向于在Kriging模型预测值优（小）和预测不确定性大（预测标准差大）的地方添加新试验点，兼具了开发局部最优区域和探索潜在最优区域的功能。</p>\n<p>EI加点准则巧妙利用了Kriging模型的预测不确定性度量能力，倾向于在Kriging模型预测值优和不确定性大的地方添加新试验点，保证了EGO算法的收敛效率和全局收敛性。此后的代理优化算法，大多沿袭了EGO算法的自适应优化思想，并致力于设计出合理的兼具局部开发和全局探索功能的加点准则。</p>\n<h4 id=\"6-多精度代理模型\"><a href=\"#6-多精度代理模型\" class=\"headerlink\" title=\"6. 多精度代理模型\"></a>6. 多精度代理模型</h4><p>代理模型的预测精度取决于其训练集的精度，可以想象训练集的精度越高、数量越多，训练得到的代理模型精度也会越高。但是在实际应用过程中，如果要获取大量高精度训练集需要耗费过多的时间和计算资源，因此为了解决这一问题，我们可以考虑使用多精度代理模型（multi-fidelity surrogate model）。多精度代理模型的出发点是希望能够用<strong>大量低精度</strong>的数据和<strong>少量高精度</strong>的数据构建高精度代理模型，这样就可以大大江都获取高精度代理模型的难度。</p>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p>[1]王红涛,竺晓程,杜朝辉.基于Kriging代理模型的改进EGO算法研究[J].工程设计学报,2009,16(04):266-270+302.</p>\n<p>[2]张建侠. 基于Kriging模型的全局代理优化算法研究[D].南京理工大学,2018.</p>\n<p>[3]乐春宇,马义中,张建侠.结合Kriging和物理规划的多目标代理优化算法[J].计算机工程与应用,2019,55(21):240-246.</p>\n<p>[4]乐春宇. 基于Kriging模型的代理优化理论研究和应用[D].南京理工大学,2020.</p>\n<p>[5] 偷天换日，斗转星移——代理优化算法 <a href=\"https://zhuanlan.zhihu.com/p/99609634\">https://zhuanlan.zhihu.com/p/99609634</a></p>\n<p>[6] Zhan, D., et al. (2017). “Expected Improvement Matrix-Based Infill Criteria for Expensive Multiobjective Optimization.” IEEE Transactions on Evolutionary Computation 21(6): 956-975.</p>\n<p>[7] Sacks, Jerome, et al. “Design and analysis of computer experiments.”<em>Statistical science</em>(1989): 409-423.</p>\n<p>[8] <a href=\"https://zhuanlan.zhihu.com/p/377620800\">克里金(Kriging)模型详细推导 - 知乎 (zhihu.com)</a></p>\n<p>[9] <a href=\"https://link.jianshu.com?t=http%3A%2F%2Fwww.southampton.ac.uk%2F~aijf197%2F07PA0124.pdf\">Multi-fidelity optimization via surrogate modelling</a> by Alexander I. J. Forrester, Andras Sobester and Andy J. Keane</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"代理模型简介\"><a href=\"#代理模型简介\" class=\"headerlink\" title=\"代理模型简介\"></a>代理模型简介</h3><p>代理模型是复杂工程优化设计问题的关键技术之一。许多复杂问题的优化方法，如遗传算法、模拟退火算法、粒子群算法和蚁群算法等等。与传统的基于梯度的优化方法比，上述这些算法具有很好的鲁棒性、全局性和高度并行性等特点，在多峰值的非线性函数优化问题中得到了成功的应用。但是这些算法的最大缺点是收敛速度慢，需要对目标函数进行大量的评估，如果目标函数评估方法比较耗时(如工程优化中的CFD和FEM分析)，则计算量很大，严重制约了其在工程中的应用。为了克服全局优化算法的这个缺点，人们采用了一种称为代理模型(surrogate model)的方法来代替耗时的精确模型评估。代理模型的计算量比精确模型小得多，同时精度也可以得到保证，采用代理模型可以大大减少优化过程的计算量，提高工程优化设计的效率。常用的代理模型主要包括<strong>插值法</strong>、<strong>响应面模型</strong>、<strong>人工神经元网络模型</strong>、<strong>径向基函数模型</strong>及<strong>Kriging模型</strong>等。其中Kriging模型具有训练样本点处无偏估计、良好的高度非线性近似能力，非常适合作为代理模型使用。目前Kriging模型在工程优化设计领域得到了广泛应用。[1]</p>\n<p>这其中，多项式响应面、多项式插值接近于回归拟合领域，比较简单。支持向量机回归（相对于分类支持向量机）其应用较少，在此不做讨论。神经网络作为一套独立的体系，应该说其对原模型的近似程度最高，随着节点和隐含层的增多，实现模型的完美逼近。不过其运算速度也不会很快，且可解释性差，很多网络本身就是一个黑箱。克里金插值和径向基函数插值是目前应用较多的两种方法。</p>\n<h4 id=\"1-插值法\"><a href=\"#1-插值法\" class=\"headerlink\" title=\"1. 插值法\"></a>1. 插值法</h4><p>利用函数f (x)在某区间中插入若干点的函数值，作出适当的特定函数，在这些点上取已知值，在区间的其他点上用这特定函数的值作为函数f (x)的近似值。</p>\n<h4 id=\"2-响应面模型\"><a href=\"#2-响应面模型\" class=\"headerlink\" title=\"2. 响应面模型\"></a>2. 响应面模型</h4><p>也称作响应曲面设计方法(Response Surface Methodology，RSM)，是通过一系列多变量试验，通过多项式回归方程来模拟真实状态曲面的方法。一般情况下，二次回归方程可以给出较为满意的答案，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny=\\beta_{0}+\\sum_{i=1}^{m} \\beta_{i} x_{i}+\\sum_{i=1}^{m} \\beta_{i i} x_{i} x_{i}+\\sum \\sum_{i<j} \\beta_{i j} x_{i} x_{j}+\\varepsilon\n\\end{equation}</script><p>写成更紧凑的形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny_{i}=\\beta_{0}+\\sum_{j=1}^{k} \\beta_{j} x_{i j}+\\varepsilon_{i} \\quad i=1,2, \\ldots, n\n\\end{equation}</script><p>多次观测后写成矩阵形式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\mathbf{y}=\\mathbf{X} \\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon}\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{split}\n& \\mathbf{y}=\\left[\\begin{array}{c}\ny_{1} \\\\\ny_{2} \\\\\n\\vdots \\\\\ny_{n}\n\\end{array}\\right], \\mathbf{X}=\\left[\\begin{array}{ccccc}\n1 & x_{11} & x_{12} & \\ldots & x_{1 k} \\\\\n1 & x_{21} & x_{22} & \\ldots & x_{2 k} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & x_{n 1} & x_{n 2} & \\ldots & x_{n k}\n\\end{array}\\right], \\\\\n& \\boldsymbol{\\beta}=\\left[\\begin{array}{c}\n\\beta_{0} \\\\\n\\beta_{1} \\\\\n\\vdots \\\\\n\\beta_{k}\n\\end{array}\\right],\\boldsymbol{\\varepsilon}=\\left[\\begin{array}{c}\n\\varepsilon_{0} \\\\\n\\varepsilon_{1} \\\\\n\\vdots \\\\\n\\varepsilon_{k}\n\\end{array}\\right]\n\\end{split}\n\\end{equation}</script><p>观测误差方差为</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{L}=\\sum_{i=1}^{n} \\varepsilon_{i}^{2}=\\boldsymbol{\\varepsilon}^{\\prime} \\boldsymbol{\\varepsilon}=(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})^{\\prime}(\\mathbf{y}-\\mathbf{X} \\boldsymbol{\\beta})</script><p>当方差最小时，显然拟合曲面和实际值最接近，此时</p>\n<script type=\"math/tex; mode=display\">\n\\left.\\frac{\\partial \\mathbf{L}}{\\partial \\boldsymbol{\\beta}}\\right|_{\\hat{\\beta}}=-2 \\mathbf{X}^{\\prime} \\mathbf{y}+2 \\mathbf{X}^{\\prime} \\mathbf{X} \\hat{\\boldsymbol{\\beta}}=0</script><p>则</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^{\\prime} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\prime} \\mathbf{y}</script><p>可得响应面为</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\mathbf{y}}=\\mathbf{X} \\hat{\\boldsymbol{\\beta}}</script><h4 id=\"3-神经网络模型\"><a href=\"#3-神经网络模型\" class=\"headerlink\" title=\"3. 神经网络模型\"></a>3. 神经网络模型</h4><p>一种万能逼近模型。当代人工智能、深度学习的核心。</p>\n<h4 id=\"4-径向基函数模型\"><a href=\"#4-径向基函数模型\" class=\"headerlink\" title=\"4. 径向基函数模型\"></a>4. 径向基函数模型</h4><p>1985年，Powell提出了多变量插值的径向基函数（RBF）方法。1988年Moody和Darken提出了一种神经网络结构，即RBF神经网络，属于前向神经网络类型，它能够以任意精度逼近任意连续函数，特别适合于解决分类问题。</p>\n<p>RBF网络的结构与多层前向网络类似，它是一种三层前向网络。输入层由信号源结点组成，第二层为隐含层，隐单元数视所描述问题的需要而定，隐单元的变换函数是RBF，它是对中心点径向对称且衰减的非负非线性函数，第三层为输出层，它对输入模式的作用作出相应。从输入空间到隐含层空间的变换是非线性的，而从隐含层空间到输出层空间变换是线性的。</p>\n<p>RBF网络的基本思想是：用RBF作为隐单元的“基”构成隐含层空间，这样就可以将输入矢量直接映射到隐空间，而不需要通过权连接。当RBF的中心点确定以后，这种映射关系也就确定了。而隐含层空间到输出空间的映射是线性的，即网络的输出是隐单元输出的线性加权和，此处的权即为网络可调参数。从总体上看，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。这样网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p>\n<p><img src=\"/images/2021-11-03-代理模型/RBF.jpg\" alt=\"RBF网络结构\" style=\"zoom:70%;\" /></p>\n<h4 id=\"5-克里金模型\"><a href=\"#5-克里金模型\" class=\"headerlink\" title=\"5. 克里金模型\"></a>5. 克里金模型</h4><p>克里金（Kriging）模型实际上就是<strong>高斯随机过程模型</strong>，只是实现上稍有不同。</p>\n<p>代理模型在<strong>优化过程</strong>中的使用方式非常重要，最常用的也是最简单的方式是以代理模型的预测值为目标函数对其寻优得到校正点，然后把校正点用精确模型评估并把结果用以更新代理模型，依此往复迭代直至收敛。这种选择校正点的方法极易使优化过程陷入局部极值点。Kriging模型与多项式响应面模型及人工神经网络模型最大的不同之处在于，Kriging模型不仅提供了1) 未知点处的<strong>预测值</strong>，还提供了2) 未知点处的<strong>预测标准差</strong>，可以方便地衡量预测的精度。针对简单地对代理模型预测值寻优确定校正点的方法所带来的局部收敛问题。Schonlau提出了以 Kriging 模型为代理模型的 EGO(efficient global optimization)算法， 该算法在 选取校正点时综合考虑了 Kriging 模型的预测值和 预测精度 ，避免了优化过程局部收敛的风险。</p>\n<h5 id=\"5-1-克里金模型的基本理论\"><a href=\"#5-1-克里金模型的基本理论\" class=\"headerlink\" title=\"5.1 克里金模型的基本理论\"></a>5.1 克里金模型的基本理论</h5><h6 id=\"形式一-6\"><a href=\"#形式一-6\" class=\"headerlink\" title=\"形式一 [6]\"></a>形式一 [6]</h6><script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{y}_{1}(x)=\\hat{\\mu}+r^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu}) \\\\\ns_{1}^{2}(x)=\\hat{\\sigma}\\left[1-r^{T} C^{-1} r+\\frac{\\left(1-\\mathbf{1}^{T} C^{-1} r\\right)^{2}}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}}\\right]\n\\end{array}\\right.</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{\\mu}=\\frac{\\mathbf{1}^{T} C^{-1} y}{\\mathbf{1}^{T} C^{-1} \\mathbf{1}} \\\\\n\\hat{\\sigma}^{2}=\\frac{(y-\\mathbf{1} \\hat{\\mu})^{T} C^{-1}(y-\\mathbf{1} \\hat{\\mu})}{n}\n\\end{array}\\right.</script><p>假设有n个数据点，1个预测点。r是数据点X和预测点x之间的协方差矩阵。C是数据点X之间的协方差矩阵。y是数据点的目标值。<strong>1</strong>是n*1的矩阵。</p>\n<h6 id=\"形式二-7\"><a href=\"#形式二-7\" class=\"headerlink\" title=\"形式二 [7]\"></a>形式二 [7]</h6><script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\hat{y}_{2}(x)=f(x)^{T} \\beta^{*}+r^{T}(x) \\gamma^{*} \\\\\ns_{2}^{2}(x)=\\sigma^{2}\\left(1+u^{T}\\left(F^{T} C^{-1} F\\right)^{-1} u-r^{T} R^{-1} r\\right)\n\\end{array}\\right.</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{array}{l}\n\\beta^{*}=\\left(F^{T} R^{-1} F\\right)^{-1} F^{T} C^{-1} Y \\\\\nC \\gamma^{*}=Y-F \\beta^{*} \\\\\nu=F^{T} C^{-1} r-f(x) \\\\\n\\sigma^{2}=\\frac{1}{m}\\left(Y-F \\beta^{*}\\right)^{T} C^{-1}\\left(Y-F \\beta^{*}\\right)\n\\end{array}\\right.</script><p><strong>形式一是形式二在基函数为0次函数(即f(x)=1)时的特例</strong>。</p>\n<p>对于形式一，给定数据集为$\\boldsymbol{X}=\\{\\boldsymbol{x}^{1}, \\boldsymbol{x}^{2}, \\ldots, \\boldsymbol{x}^{n}\\}^{T}$​​​​​，对应的目标函数为$\\boldsymbol{y}=\\{y^{1}, y^{2}, \\ldots, y^{n}\\}^{T}$​​​​​克里金法假设所有数据之间都服从n维的正态分布。所以目标函数$\\boldsymbol{y}$​​​​​​是一个随机过程，里面的每一个变量$y_i$​​​都是一个随机变量。我们把这个随机过程记做：</p>\n<script type=\"math/tex; mode=display\">\n\\left(\\begin{array}{c}\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\nY\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right) \\\\\n\\vdots \\\\\nY\\left(\\boldsymbol{x}^{n}\\right)\n\\end{array}\\right) \\sim N(\\boldsymbol{\\mu}, C)</script><p>我们把均值取为常数$\\boldsymbol{1}$​ 是n*1的矩阵。协方差取为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{aligned}\n&\\operatorname{cor}\\left[Y\\left(\\boldsymbol{x}^{i}\\right), Y\\left(\\boldsymbol{x}^{l}\\right)\\right]=\\exp \\left(-\\sum_{j=1}^{k} \\theta_{j}\\left|x_{j}^{i}-x_{j}^{l}\\right|^{2}\\right) \\\\\n&C=\\left(\\begin{array}{ccc}\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right) \\\\\n\\vdots & \\ddots, & \\vdots \\\\\n\\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{1}}\\right)\\right), & \\ldots, & \\operatorname{cor}\\left(Y\\left(\\boldsymbol{x}^{n}\\right), Y\\left(\\boldsymbol{x}^{\\mathbf{n}}\\right)\\right)\n\\end{array}\\right)\n\\end{aligned}\n\\end{equation}</script><p>则Y的条件概率为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nL\\left(\\boldsymbol{Y}^{1}, \\boldsymbol{Y}^{2}, \\ldots, \\boldsymbol{Y}^{n} \\mid \\mu, \\sigma\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}} \\exp \\left(-\\frac{\\Sigma\\left(\\boldsymbol{Y}^{i}-\\boldsymbol{\\mu}\\right)^{2}}{2 \\sigma^{2}}\\right)\n\\end{equation}</script><p>这个条件概率可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nL=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{n / 2}|C|^{1 / 2}} \\exp \\left[-\\frac{(\\boldsymbol{y}-\\mathbf{1} \\mu)^{T} C^{-1}(\\boldsymbol{y}-\\mathbf{1} \\mu)}{2 \\sigma^{2}}\\right]\n\\end{equation}</script><p>利用最大似然概率的方法可以得到先验参数$\\hat{\\mu}，\\hat{\\sigma}，\\theta_{i}$​​​​的值，最后通过代入已知和未知点，最大​化对数似然概率函数可得式(9.1)。证明过程详见参考文献[8]。</p>\n<h5 id=\"5-2-改进的EGO算法\"><a href=\"#5-2-改进的EGO算法\" class=\"headerlink\" title=\"5.2 改进的EGO算法\"></a>5.2 改进的EGO算法</h5><p>选择代理模型预测值的最优点作为校正点的方法称为响应最优策略。如图所示，当最初的样本点分布不均匀时，Kriging模型的预测值在样本点稀疏的地方与真实函数值相差很大，如果以预测值的最优点作为校正点只是使校正后的Kriging模型在样本点集中的区域预测精度不断提高，在样本点稀疏区域预测精度却没有太多变化，如果真实函数的最优值在样本点稀疏区域，则采用最优策略选择校正点就使得优化过程陷入了局部极值点，可见为了避免采用响应最优策略确定校正点所带来的局部收敛问题，有必要在选择校正点时综合考虑Kriging模型的预测值与预测标准差。</p>\n<p><img src=\"/images/2021-11-03-代理模型/Kriging模型.png\" alt=\"Kriging模型拟合函数示意图\" style=\"zoom: 20%;\" /></p>\n<p>Jones 和 Schonlau提出的EGO算法是一种贝叶斯全局优化算法，针对式(10)表示的一般形式的优化问题，其基本流程为:</p>\n<ol>\n<li>在设计空间中，利用试验设计方法(DOE)生成初始样本库。</li>\n<li>采用Kriging模型分别构建设计变量与目标函数、约束函数间的近似映射关系。</li>\n<li>EI (expected improvement)函数的值为目标函数，选择使其最大的点作为校正点。</li>\n<li>对校正点采用高精度初始模型评估得到校正点的响应值，把校正点及其响应值加入样本库中。</li>\n<li>重复步骤(2),(3),(4)直至收敛。</li>\n</ol>\n<p>其中EI函数(加点准则)定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nEI(\\boldsymbol{x})=\\left(y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})\\right) \\Phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)+s_{\\hat{y}}(\\boldsymbol{x}) \\phi\\left(\\frac{y_{\\min }-\\mu_{\\hat{y}}(\\boldsymbol{x})}{s_{\\hat{y}}(\\boldsymbol{x})}\\right)\n\\end{equation}</script><p>其中$y_{\\min } $​​为当前试验点上的目标函数的最小值，$\\mu_{\\hat{y}}(\\boldsymbol{x})$​​和$s_{\\hat{y}}$​​分别是$\\boldsymbol{x}$​​处的Kriging模型的预测值和标准差，$\\phi( )$​​和$\\Phi( )$​​分别是标准正态分布的密度函数和分布函数。</p>\n<p>EGO算法将EI准则的最大值点作为新增试验点，故EGO算法倾向于在Kriging模型预测值优（小）和预测不确定性大（预测标准差大）的地方添加新试验点，兼具了开发局部最优区域和探索潜在最优区域的功能。</p>\n<p>EI加点准则巧妙利用了Kriging模型的预测不确定性度量能力，倾向于在Kriging模型预测值优和不确定性大的地方添加新试验点，保证了EGO算法的收敛效率和全局收敛性。此后的代理优化算法，大多沿袭了EGO算法的自适应优化思想，并致力于设计出合理的兼具局部开发和全局探索功能的加点准则。</p>\n<h4 id=\"6-多精度代理模型\"><a href=\"#6-多精度代理模型\" class=\"headerlink\" title=\"6. 多精度代理模型\"></a>6. 多精度代理模型</h4><p>代理模型的预测精度取决于其训练集的精度，可以想象训练集的精度越高、数量越多，训练得到的代理模型精度也会越高。但是在实际应用过程中，如果要获取大量高精度训练集需要耗费过多的时间和计算资源，因此为了解决这一问题，我们可以考虑使用多精度代理模型（multi-fidelity surrogate model）。多精度代理模型的出发点是希望能够用<strong>大量低精度</strong>的数据和<strong>少量高精度</strong>的数据构建高精度代理模型，这样就可以大大江都获取高精度代理模型的难度。</p>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><p>[1]王红涛,竺晓程,杜朝辉.基于Kriging代理模型的改进EGO算法研究[J].工程设计学报,2009,16(04):266-270+302.</p>\n<p>[2]张建侠. 基于Kriging模型的全局代理优化算法研究[D].南京理工大学,2018.</p>\n<p>[3]乐春宇,马义中,张建侠.结合Kriging和物理规划的多目标代理优化算法[J].计算机工程与应用,2019,55(21):240-246.</p>\n<p>[4]乐春宇. 基于Kriging模型的代理优化理论研究和应用[D].南京理工大学,2020.</p>\n<p>[5] 偷天换日，斗转星移——代理优化算法 <a href=\"https://zhuanlan.zhihu.com/p/99609634\">https://zhuanlan.zhihu.com/p/99609634</a></p>\n<p>[6] Zhan, D., et al. (2017). “Expected Improvement Matrix-Based Infill Criteria for Expensive Multiobjective Optimization.” IEEE Transactions on Evolutionary Computation 21(6): 956-975.</p>\n<p>[7] Sacks, Jerome, et al. “Design and analysis of computer experiments.”<em>Statistical science</em>(1989): 409-423.</p>\n<p>[8] <a href=\"https://zhuanlan.zhihu.com/p/377620800\">克里金(Kriging)模型详细推导 - 知乎 (zhihu.com)</a></p>\n<p>[9] <a href=\"https://link.jianshu.com?t=http%3A%2F%2Fwww.southampton.ac.uk%2F~aijf197%2F07PA0124.pdf\">Multi-fidelity optimization via surrogate modelling</a> by Alexander I. J. Forrester, Andras Sobester and Andy J. Keane</p>\n"},{"title":"数据融合","date":"2021-11-08T11:52:32.000Z","_content":"\n","source":"_posts/2021-11-08-数据融合.md","raw":"---\ntitle: 数据融合\ndate: 2021-11-08 19:52:32\ntags:\n---\n\n","slug":"数据融合","published":1,"updated":"2021-11-09T01:30:12.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9w000my8ux4pfn9bz6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"薄板结构的模态分析","date":"2021-11-29T02:38:02.000Z","math":true,"typora-root-url":"..","_content":"\n## 薄板结构的模态分析\n\n### 1. 薄板的小挠度弯曲\n\n#### 1.1 薄板的基本概念和基本假设\n\n薄板是工程结构中的一种常用构件，它是由两个平行面和垂直于它们的柱面所围成的物体，几何特征是其高度远小于底面尺寸，简称板。薄板的弯曲变形属于弹性力学空间问题，由于数学求解的复杂性，因此，需要首先建立应力和变形分布的基本假设。\n\n![图1 薄板的基本概念](/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp)\n\n薄板的上下两个平行面称为板面，垂直于平行面的柱面称为板边，如图所示。两个平行面之间的距离称为板厚，用$\\delta$ 表示。平分板厚的平面称为板的中面。假设板的厚度为$\\delta$，平分厚度$\\delta$的平面成为板的中间平面，简称为中面。如果板的厚度$\\delta$远小于中面的最小特征尺寸$b$，例如$1/5≤\\delta/b≤1/80$，则成为薄板。如果外载荷为垂直于板的中面作用的横向载荷，则板主要变形为弯曲变形。中面在薄板弯曲时变形成为曲面，中面沿垂直方向，即横向位移称为挠度。对于薄板，仍然有相当的弯曲刚度，如果挠度小于厚度的五分之一，属于小挠度问题。\n\n根据薄板的外载荷和几何特征，外力为横向载荷，厚度远小于薄板的平面宽度，可以忽略一些次要因素。薄板的小挠度弯曲理论是由三个基本假设作为基础，因为这些基本假设是由基尔霍夫首先提出的，因此又称为**基尔霍夫假设**。\n\n(1) 变形前垂直于中面的直线变形后仍然保持直线，而且长度不变。这相当于梁的弯曲变形平面假设。根据这一假设， $ε_z＝γ_{zx}＝γ_{zy}＝0$。因此，在板内所有的点，位移分量$w$只是$x$和$y$的函数而与$z$无关。也就是说，在中面的任意一根法线上，薄板沿厚度方向的所有个点都具有挠度$w$。\n\n(2) 垂直于中面方向的应力分量$σ_z，τ_{zx}，τ_{zy}$ 远小于其他应力分量，其引起的变形可以不计，但是对于维持平衡是必要的，这相当于梁的弯曲无挤压应力假设。\n\n(3) 薄板弯曲时，中面各点只有垂直中面的位移w，没有平行中面的位移，即\n$$\n\\begin{equation}\nu_{z=0}=0, \\quad v_{z=0}=0\n\\end{equation}\n$$\n根据这一假设，板的中面将没有变形发生。板的中面位移函数$w(x, y)$称为挠度函数。\n\n#### 1.2 板的小挠度弯曲的基本方程\n\n根据基尔霍夫假设和几何方程可以得到挠度函数表达的应变分量\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\varepsilon_{x}=\\frac{\\partial u}{\\partial x}=-\\frac{\\partial^{2} w}{\\partial x^{2}} z \\\\\n\\varepsilon_{y}=\\frac{\\partial v}{\\partial y}=-\\frac{\\partial^{2} w}{\\partial y^{2}} z \\\\\ny_{x y}=\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}=-2 \\frac{\\partial^{2} w}{\\partial x \\partial y} z\n\\end{array}\n\\end{equation}\n$$\n和应力分量\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\sigma_{x}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right) \\\\\n\\sigma_{y}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial y^{2}}+v \\frac{\\partial^{2} w}{\\partial x^{2}}\\right) \\\\\n\\tau_{x y}=\\frac{-E z}{1-v^{2}} \\frac{\\partial^{2} w}{\\partial x \\partial y}\n\\end{array}\n\\end{equation}\n$$\n薄板的小挠度弯曲问题，将挠度$w(x,y)$取为基本未知函数，所谓的弹性曲面微分方程可由内力与载荷平衡条件或微元的应力平衡条件得到，如下所示\n$$\n\\begin{equation}\nD\\nabla^{2} \\nabla^{2} w=q\n\\end{equation}\n$$\n其中$D$称为薄板的弯曲刚度\n$$\n\\begin{equation}\nD=\\frac{-E \\delta^{3}}{12\\left(1-v^{2}\\right)}\n\\end{equation}\n$$\n该方程已经考虑并完全满足了弹性力学空间问题的平衡微分方程、集合方程和物理方程，以及薄板上、下板面的应力边界条件，得到了求解挠度$w$的基本微分方程。这样，在求解时，只需按照薄板侧面上的边界条件，求出挠度$w$，从而求出应力分量。\n\n#### 1.3 边界条件和挠度函数形式\n\n进行薄板结构的模态分析时，关键在于薄板的边界条件。以下给出几种常见的边界条件\n\n##### 1.3.1 固定边OA($x=0$)\n\n显然有边界挠度和转角均为零的几何条件。因此，在$x=0$边界，有\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial w}{\\partial x}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}\n$$\n\n##### 1.3.2 简支边OA($x=0$)\n\n薄板在简支边界，不能有挠度，但是可以有微小的转动。因此边界条件为挠度为零和弯矩为零，属于混合边界条件。在$x=0$ 边界，有\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial^{2} w}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}\n$$\n\n##### 1.3.3 自由边OA($x=a$)\n\n沿自由边OA，薄板的弯矩和扭矩以及横向剪力都等于零，因而有三个边界条件\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.M_{x}\\right|_{x=a}=0, \\quad\n\\left.M_{x y}\\right|_{x=a}=0, \\quad\n\\left.F_{S x}\\right|_{x=a}=0\n\\end{array}\n\\end{equation}\n$$\n但是，薄板的挠曲微分方程式四阶的椭圆形偏微分方程，根据偏微分方程理论，在每个边界上，只需要两个边界条件。为此，基尔霍夫指出，薄板任一边界上的扭矩都可以变换为等效的横向剪力，和原来的剪力合并，因而后两个边界条件并不独立。自由边的边界条件用$w$表示为\n$$\n\\begin{equation}\n\\begin{array}{l}\n{\\left[\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right]_{x=a}=0}, \\quad\n{\\left[\\frac{\\partial^{3} w}{\\partial x^{3}}+(2-v) \\frac{\\partial^{3} w}{\\partial x \\partial y^{2}}\\right]_{x=a}=0}\n\\end{array}\n\\end{equation}\n$$\n应该指出，如果相邻的两个边界都是自由边界，则扭矩用上述剪力等效替代时，在两个边界的角点将会出现没有抵消的集中剪力$F_{SR}$，如果边界角点没有受到支承，则应该还有角点条件\n$$\n\\begin{equation}\n\\left.\\frac{\\partial^{2} w}{\\partial x \\partial y}\\right|_{x=a \\atop y=b}=0\n\\end{equation}\n$$\n\n##### 1.3.4 振型函数的近似表示\n\n对于四边简支的矩形薄板，能够通过理论推导求出其精确解，然而实际中往往边界条件复杂。因此实际中利用近似法对薄板结构物体进行模态分析是较为方便的。能量法能够近似分析出薄板在不同边界条件下的模态。任意边界条件下的薄板的振型函数$ w(x,y)$都可以利用分离变量法写成下式所示的形式[1] \n$$\n\\begin{equation}\nw(x, y)=\\sum_{m=1}^{p} \\sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\n\\end{equation}\n$$\n式中$ w(x,y)$表示薄板中Q点处的挠度，  $x , y$ 是归一化的坐标，$p, q$ 分别代表了 $x, y$ 方向上的多项式总数。 $X_{m}(x), Y_{n}(y)$为满足不同边界条件的多项式。$A_{mn}$表示这些多项式的权重参数。对于不同的边界条件 $X_{m}(x), Y_{n}(y)$的选择也不同。选取适当的多项式后，就可以求取该边界条件下薄板振动时的能量分布，从而求得各种边界条件下的振动模态。\n\n### 2.  梁的弯曲振动\n\n在使用上述模态振型函数的近似形式时，实际上参考了梁的振动方程。\n\n如图1所示是一弯曲振动的梁，假设梁的长度和截面高度之比大于10，因而满足材料力学中的欧拉伯努利梁的假设，即（1）变形前垂直梁中心线的平剖面，变形后仍然为平面（刚性横截面假定）；（2）变形后横截面的平面仍与变形后的轴线相垂直。其中忽略了梁的转动动能和剪切变形势能。\n\n#### 2.1 梁的边界条件\n\n\n\n![图2 梁的典型边界条件](/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png)\n\n梁的典型边界条件有如下几种：\n\n(1) 固支端的边界条件是位移与转角为零 ，即\n$$\n\\begin{equation}\ny(0, t)=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\partial y(x, t)}{\\partial x}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n(2) 简支端的边界条件是位移与弯矩为零，即\n$$\n\\begin{equation}\ny(0, t)=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n(3) 自由端的边界条件是弯矩与剪力为零，即\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=0\n\\end{equation}\n$$\n\n(4) 自由端带有弹簧$k$的边界条件是位移与剪力存在如下关系，且弯矩为零，即\n$$\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=k y(L, t)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n(5) 简支端带有卷簧$k$的边界条件是转角与弯矩之间存在如下关系，且位移为零，即\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=-k \\frac{\\partial y(x, t)}{\\partial x}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\ny(L)=0\n\\end{equation}\n$$\n\n(6) 自由端带有集中质量$M$的边界条件是剪力与加速度之间存在如下关系，且弯矩为零，即\n$$\n\\begin{equation}\n\\left.\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]\\right|_{x=L}=M \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n#### 2.2 梁的自由振动与模态\n\n自由振动情况下$f(x,t)=0$，考虑到梁的弯矩和弯矩变形之间的关系式\n$$\n\\begin{equation}\nE I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}=M(x, t)\n\\end{equation}\n$$\n通过对梁微元分析并略去高阶小量，梁的自由振动的运动方程可以表示为：\n$$\n\\begin{equation}\n\\frac{\\partial^{2}}{\\partial x^{2}}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]+m(x) \\frac{\\partial^{2} y(x, t)}{\\partial t^{2}}=0\n\\end{equation}\n$$\n设同步运动为\n$$\n\\begin{equation}\ny(x, t)=Y(x) \\eta(t)\n\\end{equation}\n$$\n带入上式并假定为均匀梁，可得\n$$\n\\begin{equation}\n\\frac{\\mathrm{d}^{4} Y(x)}{\\mathrm{d} x^{4}}-\\beta^{4} Y(x)=0\n\\end{equation}\n$$\n式中$\\begin{equation}\\beta^{4}=\\frac{\\omega^{2} m}{EI}\\end{equation}$，方程的通解为\n$$\n\\begin{equation}\nY(x)=C_{1} \\sin \\beta x+C_{2} \\cos \\beta x+C_{3} \\operatorname{sh} \\beta x+C_{4} \\operatorname{ch} \\beta x\n\\end{equation}\n$$\n##### 2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态\n\n![图3 悬臂梁自然模态](/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png)\n\n悬臂梁的边界条件可以表示为\n$$\n\\begin{equation}\nY(0)=0,\\left.\\quad \\frac{\\mathrm{d} Y(x)}{\\mathrm{d} x}\\right|_{=-0}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n特征函数$Y(x)$可表示为\n$$\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=1,2 ...\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=-\\frac{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}\n\\end{equation}\n$$\n$\\beta_{r}$可由边界条件以数值方法得出，$C_{1}$为待定常数，前三阶振型及相应的自然频率在图2中给出，在图中可以看到，$Y_{r}(x)$有$r-1$个节点。\n\n##### 2.2.2 两端自由的梁的自然模态\n\n此处需要注意的是，由于两端自由梁的约束不足，因此前两阶为刚体模态，分别为平动和转动。刚体模态跟刚体运动定义相似，结构内部不发生变形的模态振型即为刚体模态，即刚体运动对应刚体模态。该边界条件下前两节模态如下。\n$$\n\\begin{equation}\n{\\begin{array}{l}\nY_1(x) = C_{1,1}\\\\\nY_2(x) = C_{1,2}(2x-L)\n\\end{array}}\n\\end{equation}\n$$\n悬臂梁的边界条件可以表示为\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=0}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n可知式18中的系数满足如下关系\n$$\n\\begin{equation}\n\\left\\{\n{\\begin{array}{l}\n-C_{1}+C_{3}=0 \\\\\n-C_{2}+C_{4}=0\n\\end{array}}\n\\right.\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\begin{aligned}\n(-\\sin \\beta L+\\operatorname{sh} \\beta L) C_{1}+(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{2} &=0 \\\\\n(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{1}+(\\sin \\beta L+\\operatorname{sh} \\beta L) C_{2} &=0\n\\end{aligned}\n\\end{equation}\n$$\n\n为得到上式的非零解，系数行列式必为零，即\n$$\n\\begin{equation}\n\\left|\\begin{array}{rr}\n-\\sin \\beta L+\\operatorname{sh} \\beta L & -\\cos \\beta L+\\operatorname{ch} \\beta L \\\\\n-\\cos \\beta L+\\operatorname{ch} \\beta L & \\sin \\beta L+\\operatorname{ch} \\beta L\n\\end{array}\\right|=0\n\\end{equation}\n$$\n展开上式化简得特征方程为\n$$\n\\begin{equation}\n\\cos \\beta L \\operatorname{ch} \\beta L=1\n\\end{equation}\n$$\n可由数值方法求得一系列的$\\beta_r L$的值。\n\n同上一小节一样，特征函数$Y(x)$可表示为\n$$\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=3,4 ...\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=\\frac{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}{-\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L-\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}\n\\end{equation}\n$$\n$C_{1}$为待定常数。\n\n##### 2.2.3 Gram-Schmidt正交多项式方法\n\n另一种简单的方法是利用Gram-Schmidt正交多项式方法进行表征。在区间$[a,b]$上的正交多项式可以通过如下过程\n$$\n\\begin{equation}\n\\phi_{1}(x)=\\left(x-B_{1}\\right) \\phi_{0}(x), \\quad \\phi_{k}(x)=\\left(x-B_{k}\\right) \\phi_{k-1}(x)-C_{k} \\phi_{k-2}(x)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\begin{array}{c}\nB_{k}=\\frac{(xg_{k},g_{k})}{(g_{k},g_{k})}\n\\\\C_{k}=\\frac{(g_{k},g_{k})}{(g_{k-1},g_{k-1})}\n\\end{array}\n\\end{equation}\n$$\n\n其中$w(x)$是权重系数。\n\n在本例中，权重选为1，区间为$[0,1]$，同时使之成为标准正交多项式，系数满足以下关系\n$$\n\\begin{equation}\n\\int_{0}^{1} w(x) \\phi_{j}(x) \\phi_{k}(x) \\mathrm{d} x=\\left\\{\\begin{array}{ll}\n0 & \\text { if } j \\neq k \\\\\n1 & \\text { if } j=k\n\\end{array}\\right\\}\n\\end{equation}\n$$\n该正多项式序列的首项的选取需要满足伴随板问题的梁问题的边界条件。即使首项$\\phi_{0}(x)$满足所有的几何和力边界条件，其他的多项式一般也只满足集合边界条件，这一点可以通过构造过程得出。\n\n满足边界条件的多项式首项$\\phi_{0}(x)$的构造方式如\n\n###### **一边固定一边自由的梁**\n\n挠度函数假设如下\n$$\n\\begin{equation}\nY(x)=a_{0}+a_{1} x+a_{2} x^{2}+a_{3} x^{3}+a_{4} x^{4}\n\\end{equation}\n$$\n且满足边界条件\n$$\n\\begin{equation}\nY(0)=Y^{\\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}\n$$\n则挠曲形状为（略去任意常数）\n$$\n\\begin{equation}\nY(x)=6 x^{2}-4 x^{3}+x^{4}\n\\end{equation}\n$$\n将该多项式标准化得\n$$\n\\begin{equation}\n\\phi_{0}(x)=\\left(6 x^{2}-4 x^{3}+x^{4}\\right) /\\left(\\int_{0}^{1} Y^{2}(x) \\mathrm{d} x\\right)^{1 / 2}\n\\end{equation}\n$$\n\n###### **两端自由的梁**\n\n满足边界条件\n$$\n\\begin{equation}\nY^{\\prime \\prime}(0)=Y^{\\prime \\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}\n$$\n标准化后的前两项为\n$$\n\\begin{equation}\n\\phi_{0}(x)=1\\\\\n\\phi_{1}(x)=2 \\sqrt{3}\\left(x-\\frac{1}{2}\\right)\n\\end{equation}\n$$\n\n\n\n\n\n\n\n\n\n###### Reference\n\n[1] Bhat R B. Natural frequencies of rectangular plates using characteristic orthogonal polynomials in Rayleigh-Ritz method[J]. Journal of Sound and Vibration, 1985, 102(4): 493-499.\n\n","source":"_posts/2021-11-29-薄板结构的模态分析.md","raw":"---\ntitle: 薄板结构的模态分析\ndate: 2021-11-29 10:38:02\ntags:\nmath: true\ntypora-root-url: ..\n---\n\n## 薄板结构的模态分析\n\n### 1. 薄板的小挠度弯曲\n\n#### 1.1 薄板的基本概念和基本假设\n\n薄板是工程结构中的一种常用构件，它是由两个平行面和垂直于它们的柱面所围成的物体，几何特征是其高度远小于底面尺寸，简称板。薄板的弯曲变形属于弹性力学空间问题，由于数学求解的复杂性，因此，需要首先建立应力和变形分布的基本假设。\n\n![图1 薄板的基本概念](/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp)\n\n薄板的上下两个平行面称为板面，垂直于平行面的柱面称为板边，如图所示。两个平行面之间的距离称为板厚，用$\\delta$ 表示。平分板厚的平面称为板的中面。假设板的厚度为$\\delta$，平分厚度$\\delta$的平面成为板的中间平面，简称为中面。如果板的厚度$\\delta$远小于中面的最小特征尺寸$b$，例如$1/5≤\\delta/b≤1/80$，则成为薄板。如果外载荷为垂直于板的中面作用的横向载荷，则板主要变形为弯曲变形。中面在薄板弯曲时变形成为曲面，中面沿垂直方向，即横向位移称为挠度。对于薄板，仍然有相当的弯曲刚度，如果挠度小于厚度的五分之一，属于小挠度问题。\n\n根据薄板的外载荷和几何特征，外力为横向载荷，厚度远小于薄板的平面宽度，可以忽略一些次要因素。薄板的小挠度弯曲理论是由三个基本假设作为基础，因为这些基本假设是由基尔霍夫首先提出的，因此又称为**基尔霍夫假设**。\n\n(1) 变形前垂直于中面的直线变形后仍然保持直线，而且长度不变。这相当于梁的弯曲变形平面假设。根据这一假设， $ε_z＝γ_{zx}＝γ_{zy}＝0$。因此，在板内所有的点，位移分量$w$只是$x$和$y$的函数而与$z$无关。也就是说，在中面的任意一根法线上，薄板沿厚度方向的所有个点都具有挠度$w$。\n\n(2) 垂直于中面方向的应力分量$σ_z，τ_{zx}，τ_{zy}$ 远小于其他应力分量，其引起的变形可以不计，但是对于维持平衡是必要的，这相当于梁的弯曲无挤压应力假设。\n\n(3) 薄板弯曲时，中面各点只有垂直中面的位移w，没有平行中面的位移，即\n$$\n\\begin{equation}\nu_{z=0}=0, \\quad v_{z=0}=0\n\\end{equation}\n$$\n根据这一假设，板的中面将没有变形发生。板的中面位移函数$w(x, y)$称为挠度函数。\n\n#### 1.2 板的小挠度弯曲的基本方程\n\n根据基尔霍夫假设和几何方程可以得到挠度函数表达的应变分量\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\varepsilon_{x}=\\frac{\\partial u}{\\partial x}=-\\frac{\\partial^{2} w}{\\partial x^{2}} z \\\\\n\\varepsilon_{y}=\\frac{\\partial v}{\\partial y}=-\\frac{\\partial^{2} w}{\\partial y^{2}} z \\\\\ny_{x y}=\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}=-2 \\frac{\\partial^{2} w}{\\partial x \\partial y} z\n\\end{array}\n\\end{equation}\n$$\n和应力分量\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\sigma_{x}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right) \\\\\n\\sigma_{y}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial y^{2}}+v \\frac{\\partial^{2} w}{\\partial x^{2}}\\right) \\\\\n\\tau_{x y}=\\frac{-E z}{1-v^{2}} \\frac{\\partial^{2} w}{\\partial x \\partial y}\n\\end{array}\n\\end{equation}\n$$\n薄板的小挠度弯曲问题，将挠度$w(x,y)$取为基本未知函数，所谓的弹性曲面微分方程可由内力与载荷平衡条件或微元的应力平衡条件得到，如下所示\n$$\n\\begin{equation}\nD\\nabla^{2} \\nabla^{2} w=q\n\\end{equation}\n$$\n其中$D$称为薄板的弯曲刚度\n$$\n\\begin{equation}\nD=\\frac{-E \\delta^{3}}{12\\left(1-v^{2}\\right)}\n\\end{equation}\n$$\n该方程已经考虑并完全满足了弹性力学空间问题的平衡微分方程、集合方程和物理方程，以及薄板上、下板面的应力边界条件，得到了求解挠度$w$的基本微分方程。这样，在求解时，只需按照薄板侧面上的边界条件，求出挠度$w$，从而求出应力分量。\n\n#### 1.3 边界条件和挠度函数形式\n\n进行薄板结构的模态分析时，关键在于薄板的边界条件。以下给出几种常见的边界条件\n\n##### 1.3.1 固定边OA($x=0$)\n\n显然有边界挠度和转角均为零的几何条件。因此，在$x=0$边界，有\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial w}{\\partial x}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}\n$$\n\n##### 1.3.2 简支边OA($x=0$)\n\n薄板在简支边界，不能有挠度，但是可以有微小的转动。因此边界条件为挠度为零和弯矩为零，属于混合边界条件。在$x=0$ 边界，有\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial^{2} w}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}\n$$\n\n##### 1.3.3 自由边OA($x=a$)\n\n沿自由边OA，薄板的弯矩和扭矩以及横向剪力都等于零，因而有三个边界条件\n$$\n\\begin{equation}\n\\begin{array}{l}\n\\left.M_{x}\\right|_{x=a}=0, \\quad\n\\left.M_{x y}\\right|_{x=a}=0, \\quad\n\\left.F_{S x}\\right|_{x=a}=0\n\\end{array}\n\\end{equation}\n$$\n但是，薄板的挠曲微分方程式四阶的椭圆形偏微分方程，根据偏微分方程理论，在每个边界上，只需要两个边界条件。为此，基尔霍夫指出，薄板任一边界上的扭矩都可以变换为等效的横向剪力，和原来的剪力合并，因而后两个边界条件并不独立。自由边的边界条件用$w$表示为\n$$\n\\begin{equation}\n\\begin{array}{l}\n{\\left[\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right]_{x=a}=0}, \\quad\n{\\left[\\frac{\\partial^{3} w}{\\partial x^{3}}+(2-v) \\frac{\\partial^{3} w}{\\partial x \\partial y^{2}}\\right]_{x=a}=0}\n\\end{array}\n\\end{equation}\n$$\n应该指出，如果相邻的两个边界都是自由边界，则扭矩用上述剪力等效替代时，在两个边界的角点将会出现没有抵消的集中剪力$F_{SR}$，如果边界角点没有受到支承，则应该还有角点条件\n$$\n\\begin{equation}\n\\left.\\frac{\\partial^{2} w}{\\partial x \\partial y}\\right|_{x=a \\atop y=b}=0\n\\end{equation}\n$$\n\n##### 1.3.4 振型函数的近似表示\n\n对于四边简支的矩形薄板，能够通过理论推导求出其精确解，然而实际中往往边界条件复杂。因此实际中利用近似法对薄板结构物体进行模态分析是较为方便的。能量法能够近似分析出薄板在不同边界条件下的模态。任意边界条件下的薄板的振型函数$ w(x,y)$都可以利用分离变量法写成下式所示的形式[1] \n$$\n\\begin{equation}\nw(x, y)=\\sum_{m=1}^{p} \\sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\n\\end{equation}\n$$\n式中$ w(x,y)$表示薄板中Q点处的挠度，  $x , y$ 是归一化的坐标，$p, q$ 分别代表了 $x, y$ 方向上的多项式总数。 $X_{m}(x), Y_{n}(y)$为满足不同边界条件的多项式。$A_{mn}$表示这些多项式的权重参数。对于不同的边界条件 $X_{m}(x), Y_{n}(y)$的选择也不同。选取适当的多项式后，就可以求取该边界条件下薄板振动时的能量分布，从而求得各种边界条件下的振动模态。\n\n### 2.  梁的弯曲振动\n\n在使用上述模态振型函数的近似形式时，实际上参考了梁的振动方程。\n\n如图1所示是一弯曲振动的梁，假设梁的长度和截面高度之比大于10，因而满足材料力学中的欧拉伯努利梁的假设，即（1）变形前垂直梁中心线的平剖面，变形后仍然为平面（刚性横截面假定）；（2）变形后横截面的平面仍与变形后的轴线相垂直。其中忽略了梁的转动动能和剪切变形势能。\n\n#### 2.1 梁的边界条件\n\n\n\n![图2 梁的典型边界条件](/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png)\n\n梁的典型边界条件有如下几种：\n\n(1) 固支端的边界条件是位移与转角为零 ，即\n$$\n\\begin{equation}\ny(0, t)=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\partial y(x, t)}{\\partial x}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n(2) 简支端的边界条件是位移与弯矩为零，即\n$$\n\\begin{equation}\ny(0, t)=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n(3) 自由端的边界条件是弯矩与剪力为零，即\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=0\n\\end{equation}\n$$\n\n(4) 自由端带有弹簧$k$的边界条件是位移与剪力存在如下关系，且弯矩为零，即\n$$\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=k y(L, t)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n(5) 简支端带有卷簧$k$的边界条件是转角与弯矩之间存在如下关系，且位移为零，即\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=-k \\frac{\\partial y(x, t)}{\\partial x}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\ny(L)=0\n\\end{equation}\n$$\n\n(6) 自由端带有集中质量$M$的边界条件是剪力与加速度之间存在如下关系，且弯矩为零，即\n$$\n\\begin{equation}\n\\left.\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]\\right|_{x=L}=M \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n#### 2.2 梁的自由振动与模态\n\n自由振动情况下$f(x,t)=0$，考虑到梁的弯矩和弯矩变形之间的关系式\n$$\n\\begin{equation}\nE I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}=M(x, t)\n\\end{equation}\n$$\n通过对梁微元分析并略去高阶小量，梁的自由振动的运动方程可以表示为：\n$$\n\\begin{equation}\n\\frac{\\partial^{2}}{\\partial x^{2}}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]+m(x) \\frac{\\partial^{2} y(x, t)}{\\partial t^{2}}=0\n\\end{equation}\n$$\n设同步运动为\n$$\n\\begin{equation}\ny(x, t)=Y(x) \\eta(t)\n\\end{equation}\n$$\n带入上式并假定为均匀梁，可得\n$$\n\\begin{equation}\n\\frac{\\mathrm{d}^{4} Y(x)}{\\mathrm{d} x^{4}}-\\beta^{4} Y(x)=0\n\\end{equation}\n$$\n式中$\\begin{equation}\\beta^{4}=\\frac{\\omega^{2} m}{EI}\\end{equation}$，方程的通解为\n$$\n\\begin{equation}\nY(x)=C_{1} \\sin \\beta x+C_{2} \\cos \\beta x+C_{3} \\operatorname{sh} \\beta x+C_{4} \\operatorname{ch} \\beta x\n\\end{equation}\n$$\n##### 2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态\n\n![图3 悬臂梁自然模态](/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png)\n\n悬臂梁的边界条件可以表示为\n$$\n\\begin{equation}\nY(0)=0,\\left.\\quad \\frac{\\mathrm{d} Y(x)}{\\mathrm{d} x}\\right|_{=-0}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n特征函数$Y(x)$可表示为\n$$\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=1,2 ...\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=-\\frac{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}\n\\end{equation}\n$$\n$\\beta_{r}$可由边界条件以数值方法得出，$C_{1}$为待定常数，前三阶振型及相应的自然频率在图2中给出，在图中可以看到，$Y_{r}(x)$有$r-1$个节点。\n\n##### 2.2.2 两端自由的梁的自然模态\n\n此处需要注意的是，由于两端自由梁的约束不足，因此前两阶为刚体模态，分别为平动和转动。刚体模态跟刚体运动定义相似，结构内部不发生变形的模态振型即为刚体模态，即刚体运动对应刚体模态。该边界条件下前两节模态如下。\n$$\n\\begin{equation}\n{\\begin{array}{l}\nY_1(x) = C_{1,1}\\\\\nY_2(x) = C_{1,2}(2x-L)\n\\end{array}}\n\\end{equation}\n$$\n悬臂梁的边界条件可以表示为\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=0}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=0}=0\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}\n$$\n\n可知式18中的系数满足如下关系\n$$\n\\begin{equation}\n\\left\\{\n{\\begin{array}{l}\n-C_{1}+C_{3}=0 \\\\\n-C_{2}+C_{4}=0\n\\end{array}}\n\\right.\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\begin{aligned}\n(-\\sin \\beta L+\\operatorname{sh} \\beta L) C_{1}+(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{2} &=0 \\\\\n(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{1}+(\\sin \\beta L+\\operatorname{sh} \\beta L) C_{2} &=0\n\\end{aligned}\n\\end{equation}\n$$\n\n为得到上式的非零解，系数行列式必为零，即\n$$\n\\begin{equation}\n\\left|\\begin{array}{rr}\n-\\sin \\beta L+\\operatorname{sh} \\beta L & -\\cos \\beta L+\\operatorname{ch} \\beta L \\\\\n-\\cos \\beta L+\\operatorname{ch} \\beta L & \\sin \\beta L+\\operatorname{ch} \\beta L\n\\end{array}\\right|=0\n\\end{equation}\n$$\n展开上式化简得特征方程为\n$$\n\\begin{equation}\n\\cos \\beta L \\operatorname{ch} \\beta L=1\n\\end{equation}\n$$\n可由数值方法求得一系列的$\\beta_r L$的值。\n\n同上一小节一样，特征函数$Y(x)$可表示为\n$$\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=3,4 ...\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=\\frac{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}{-\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L-\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}\n\\end{equation}\n$$\n$C_{1}$为待定常数。\n\n##### 2.2.3 Gram-Schmidt正交多项式方法\n\n另一种简单的方法是利用Gram-Schmidt正交多项式方法进行表征。在区间$[a,b]$上的正交多项式可以通过如下过程\n$$\n\\begin{equation}\n\\phi_{1}(x)=\\left(x-B_{1}\\right) \\phi_{0}(x), \\quad \\phi_{k}(x)=\\left(x-B_{k}\\right) \\phi_{k-1}(x)-C_{k} \\phi_{k-2}(x)\n\\end{equation}\n$$\n\n$$\n\\begin{equation}\n\\begin{array}{c}\nB_{k}=\\frac{(xg_{k},g_{k})}{(g_{k},g_{k})}\n\\\\C_{k}=\\frac{(g_{k},g_{k})}{(g_{k-1},g_{k-1})}\n\\end{array}\n\\end{equation}\n$$\n\n其中$w(x)$是权重系数。\n\n在本例中，权重选为1，区间为$[0,1]$，同时使之成为标准正交多项式，系数满足以下关系\n$$\n\\begin{equation}\n\\int_{0}^{1} w(x) \\phi_{j}(x) \\phi_{k}(x) \\mathrm{d} x=\\left\\{\\begin{array}{ll}\n0 & \\text { if } j \\neq k \\\\\n1 & \\text { if } j=k\n\\end{array}\\right\\}\n\\end{equation}\n$$\n该正多项式序列的首项的选取需要满足伴随板问题的梁问题的边界条件。即使首项$\\phi_{0}(x)$满足所有的几何和力边界条件，其他的多项式一般也只满足集合边界条件，这一点可以通过构造过程得出。\n\n满足边界条件的多项式首项$\\phi_{0}(x)$的构造方式如\n\n###### **一边固定一边自由的梁**\n\n挠度函数假设如下\n$$\n\\begin{equation}\nY(x)=a_{0}+a_{1} x+a_{2} x^{2}+a_{3} x^{3}+a_{4} x^{4}\n\\end{equation}\n$$\n且满足边界条件\n$$\n\\begin{equation}\nY(0)=Y^{\\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}\n$$\n则挠曲形状为（略去任意常数）\n$$\n\\begin{equation}\nY(x)=6 x^{2}-4 x^{3}+x^{4}\n\\end{equation}\n$$\n将该多项式标准化得\n$$\n\\begin{equation}\n\\phi_{0}(x)=\\left(6 x^{2}-4 x^{3}+x^{4}\\right) /\\left(\\int_{0}^{1} Y^{2}(x) \\mathrm{d} x\\right)^{1 / 2}\n\\end{equation}\n$$\n\n###### **两端自由的梁**\n\n满足边界条件\n$$\n\\begin{equation}\nY^{\\prime \\prime}(0)=Y^{\\prime \\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}\n$$\n标准化后的前两项为\n$$\n\\begin{equation}\n\\phi_{0}(x)=1\\\\\n\\phi_{1}(x)=2 \\sqrt{3}\\left(x-\\frac{1}{2}\\right)\n\\end{equation}\n$$\n\n\n\n\n\n\n\n\n\n###### Reference\n\n[1] Bhat R B. Natural frequencies of rectangular plates using characteristic orthogonal polynomials in Rayleigh-Ritz method[J]. Journal of Sound and Vibration, 1985, 102(4): 493-499.\n\n","slug":"薄板结构的模态分析","published":1,"updated":"2022-02-23T13:01:52.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9y000qy8ux7cawcmhc","content":"<h2 id=\"薄板结构的模态分析\"><a href=\"#薄板结构的模态分析\" class=\"headerlink\" title=\"薄板结构的模态分析\"></a>薄板结构的模态分析</h2><h3 id=\"1-薄板的小挠度弯曲\"><a href=\"#1-薄板的小挠度弯曲\" class=\"headerlink\" title=\"1. 薄板的小挠度弯曲\"></a>1. 薄板的小挠度弯曲</h3><h4 id=\"1-1-薄板的基本概念和基本假设\"><a href=\"#1-1-薄板的基本概念和基本假设\" class=\"headerlink\" title=\"1.1 薄板的基本概念和基本假设\"></a>1.1 薄板的基本概念和基本假设</h4><p>薄板是工程结构中的一种常用构件，它是由两个平行面和垂直于它们的柱面所围成的物体，几何特征是其高度远小于底面尺寸，简称板。薄板的弯曲变形属于弹性力学空间问题，由于数学求解的复杂性，因此，需要首先建立应力和变形分布的基本假设。</p>\n<p><img src=\"/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp\" alt=\"图1 薄板的基本概念\"></p>\n<p>薄板的上下两个平行面称为板面，垂直于平行面的柱面称为板边，如图所示。两个平行面之间的距离称为板厚，用$\\delta$ 表示。平分板厚的平面称为板的中面。假设板的厚度为$\\delta$，平分厚度$\\delta$的平面成为板的中间平面，简称为中面。如果板的厚度$\\delta$远小于中面的最小特征尺寸$b$，例如$1/5≤\\delta/b≤1/80$，则成为薄板。如果外载荷为垂直于板的中面作用的横向载荷，则板主要变形为弯曲变形。中面在薄板弯曲时变形成为曲面，中面沿垂直方向，即横向位移称为挠度。对于薄板，仍然有相当的弯曲刚度，如果挠度小于厚度的五分之一，属于小挠度问题。</p>\n<p>根据薄板的外载荷和几何特征，外力为横向载荷，厚度远小于薄板的平面宽度，可以忽略一些次要因素。薄板的小挠度弯曲理论是由三个基本假设作为基础，因为这些基本假设是由基尔霍夫首先提出的，因此又称为<strong>基尔霍夫假设</strong>。</p>\n<p>(1) 变形前垂直于中面的直线变形后仍然保持直线，而且长度不变。这相当于梁的弯曲变形平面假设。根据这一假设， $ε_z＝γ_{zx}＝γ_{zy}＝0$。因此，在板内所有的点，位移分量$w$只是$x$和$y$的函数而与$z$无关。也就是说，在中面的任意一根法线上，薄板沿厚度方向的所有个点都具有挠度$w$。</p>\n<p>(2) 垂直于中面方向的应力分量$σ_z，τ_{zx}，τ_{zy}$ 远小于其他应力分量，其引起的变形可以不计，但是对于维持平衡是必要的，这相当于梁的弯曲无挤压应力假设。</p>\n<p>(3) 薄板弯曲时，中面各点只有垂直中面的位移w，没有平行中面的位移，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nu_{z=0}=0, \\quad v_{z=0}=0\n\\end{equation}</script><p>根据这一假设，板的中面将没有变形发生。板的中面位移函数$w(x, y)$称为挠度函数。</p>\n<h4 id=\"1-2-板的小挠度弯曲的基本方程\"><a href=\"#1-2-板的小挠度弯曲的基本方程\" class=\"headerlink\" title=\"1.2 板的小挠度弯曲的基本方程\"></a>1.2 板的小挠度弯曲的基本方程</h4><p>根据基尔霍夫假设和几何方程可以得到挠度函数表达的应变分量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\varepsilon_{x}=\\frac{\\partial u}{\\partial x}=-\\frac{\\partial^{2} w}{\\partial x^{2}} z \\\\\n\\varepsilon_{y}=\\frac{\\partial v}{\\partial y}=-\\frac{\\partial^{2} w}{\\partial y^{2}} z \\\\\ny_{x y}=\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}=-2 \\frac{\\partial^{2} w}{\\partial x \\partial y} z\n\\end{array}\n\\end{equation}</script><p>和应力分量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\sigma_{x}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right) \\\\\n\\sigma_{y}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial y^{2}}+v \\frac{\\partial^{2} w}{\\partial x^{2}}\\right) \\\\\n\\tau_{x y}=\\frac{-E z}{1-v^{2}} \\frac{\\partial^{2} w}{\\partial x \\partial y}\n\\end{array}\n\\end{equation}</script><p>薄板的小挠度弯曲问题，将挠度$w(x,y)$取为基本未知函数，所谓的弹性曲面微分方程可由内力与载荷平衡条件或微元的应力平衡条件得到，如下所示</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nD\\nabla^{2} \\nabla^{2} w=q\n\\end{equation}</script><p>其中$D$称为薄板的弯曲刚度</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nD=\\frac{-E \\delta^{3}}{12\\left(1-v^{2}\\right)}\n\\end{equation}</script><p>该方程已经考虑并完全满足了弹性力学空间问题的平衡微分方程、集合方程和物理方程，以及薄板上、下板面的应力边界条件，得到了求解挠度$w$的基本微分方程。这样，在求解时，只需按照薄板侧面上的边界条件，求出挠度$w$，从而求出应力分量。</p>\n<h4 id=\"1-3-边界条件和挠度函数形式\"><a href=\"#1-3-边界条件和挠度函数形式\" class=\"headerlink\" title=\"1.3 边界条件和挠度函数形式\"></a>1.3 边界条件和挠度函数形式</h4><p>进行薄板结构的模态分析时，关键在于薄板的边界条件。以下给出几种常见的边界条件</p>\n<h5 id=\"1-3-1-固定边OA-x-0\"><a href=\"#1-3-1-固定边OA-x-0\" class=\"headerlink\" title=\"1.3.1 固定边OA($x=0$)\"></a>1.3.1 固定边OA($x=0$)</h5><p>显然有边界挠度和转角均为零的几何条件。因此，在$x=0$边界，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial w}{\\partial x}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}</script><h5 id=\"1-3-2-简支边OA-x-0\"><a href=\"#1-3-2-简支边OA-x-0\" class=\"headerlink\" title=\"1.3.2 简支边OA($x=0$)\"></a>1.3.2 简支边OA($x=0$)</h5><p>薄板在简支边界，不能有挠度，但是可以有微小的转动。因此边界条件为挠度为零和弯矩为零，属于混合边界条件。在$x=0$ 边界，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial^{2} w}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}</script><h5 id=\"1-3-3-自由边OA-x-a\"><a href=\"#1-3-3-自由边OA-x-a\" class=\"headerlink\" title=\"1.3.3 自由边OA($x=a$)\"></a>1.3.3 自由边OA($x=a$)</h5><p>沿自由边OA，薄板的弯矩和扭矩以及横向剪力都等于零，因而有三个边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.M_{x}\\right|_{x=a}=0, \\quad\n\\left.M_{x y}\\right|_{x=a}=0, \\quad\n\\left.F_{S x}\\right|_{x=a}=0\n\\end{array}\n\\end{equation}</script><p>但是，薄板的挠曲微分方程式四阶的椭圆形偏微分方程，根据偏微分方程理论，在每个边界上，只需要两个边界条件。为此，基尔霍夫指出，薄板任一边界上的扭矩都可以变换为等效的横向剪力，和原来的剪力合并，因而后两个边界条件并不独立。自由边的边界条件用$w$表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n{\\left[\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right]_{x=a}=0}, \\quad\n{\\left[\\frac{\\partial^{3} w}{\\partial x^{3}}+(2-v) \\frac{\\partial^{3} w}{\\partial x \\partial y^{2}}\\right]_{x=a}=0}\n\\end{array}\n\\end{equation}</script><p>应该指出，如果相邻的两个边界都是自由边界，则扭矩用上述剪力等效替代时，在两个边界的角点将会出现没有抵消的集中剪力$F_{SR}$，如果边界角点没有受到支承，则应该还有角点条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial^{2} w}{\\partial x \\partial y}\\right|_{x=a \\atop y=b}=0\n\\end{equation}</script><h5 id=\"1-3-4-振型函数的近似表示\"><a href=\"#1-3-4-振型函数的近似表示\" class=\"headerlink\" title=\"1.3.4 振型函数的近似表示\"></a>1.3.4 振型函数的近似表示</h5><p>对于四边简支的矩形薄板，能够通过理论推导求出其精确解，然而实际中往往边界条件复杂。因此实际中利用近似法对薄板结构物体进行模态分析是较为方便的。能量法能够近似分析出薄板在不同边界条件下的模态。任意边界条件下的薄板的振型函数$ w(x,y)$都可以利用分离变量法写成下式所示的形式[1] </p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nw(x, y)=\\sum_{m=1}^{p} \\sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\n\\end{equation}</script><p>式中$ w(x,y)$表示薄板中Q点处的挠度，  $x , y$ 是归一化的坐标，$p, q$ 分别代表了 $x, y$ 方向上的多项式总数。 $X_{m}(x), Y_{n}(y)$为满足不同边界条件的多项式。$A_{mn}$表示这些多项式的权重参数。对于不同的边界条件 $X_{m}(x), Y_{n}(y)$的选择也不同。选取适当的多项式后，就可以求取该边界条件下薄板振动时的能量分布，从而求得各种边界条件下的振动模态。</p>\n<h3 id=\"2-梁的弯曲振动\"><a href=\"#2-梁的弯曲振动\" class=\"headerlink\" title=\"2.  梁的弯曲振动\"></a>2.  梁的弯曲振动</h3><p>在使用上述模态振型函数的近似形式时，实际上参考了梁的振动方程。</p>\n<p>如图1所示是一弯曲振动的梁，假设梁的长度和截面高度之比大于10，因而满足材料力学中的欧拉伯努利梁的假设，即（1）变形前垂直梁中心线的平剖面，变形后仍然为平面（刚性横截面假定）；（2）变形后横截面的平面仍与变形后的轴线相垂直。其中忽略了梁的转动动能和剪切变形势能。</p>\n<h4 id=\"2-1-梁的边界条件\"><a href=\"#2-1-梁的边界条件\" class=\"headerlink\" title=\"2.1 梁的边界条件\"></a>2.1 梁的边界条件</h4><p><img src=\"/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png\" alt=\"图2 梁的典型边界条件\"></p>\n<p>梁的典型边界条件有如下几种：</p>\n<p>(1) 固支端的边界条件是位移与转角为零 ，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(0, t)=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial y(x, t)}{\\partial x}\\right|_{x=0}=0\n\\end{equation}</script><p>(2) 简支端的边界条件是位移与弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(0, t)=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{equation}</script><p>(3) 自由端的边界条件是弯矩与剪力为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=0\n\\end{equation}</script><p>(4) 自由端带有弹簧$k$的边界条件是位移与剪力存在如下关系，且弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=k y(L, t)\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><p>(5) 简支端带有卷簧$k$的边界条件是转角与弯矩之间存在如下关系，且位移为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=-k \\frac{\\partial y(x, t)}{\\partial x}\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(L)=0\n\\end{equation}</script><p>(6) 自由端带有集中质量$M$的边界条件是剪力与加速度之间存在如下关系，且弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]\\right|_{x=L}=M \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><h4 id=\"2-2-梁的自由振动与模态\"><a href=\"#2-2-梁的自由振动与模态\" class=\"headerlink\" title=\"2.2 梁的自由振动与模态\"></a>2.2 梁的自由振动与模态</h4><p>自由振动情况下$f(x,t)=0$，考虑到梁的弯矩和弯矩变形之间的关系式</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nE I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}=M(x, t)\n\\end{equation}</script><p>通过对梁微元分析并略去高阶小量，梁的自由振动的运动方程可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial^{2}}{\\partial x^{2}}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]+m(x) \\frac{\\partial^{2} y(x, t)}{\\partial t^{2}}=0\n\\end{equation}</script><p>设同步运动为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(x, t)=Y(x) \\eta(t)\n\\end{equation}</script><p>带入上式并假定为均匀梁，可得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\mathrm{d}^{4} Y(x)}{\\mathrm{d} x^{4}}-\\beta^{4} Y(x)=0\n\\end{equation}</script><p>式中$\\begin{equation}\\beta^{4}=\\frac{\\omega^{2} m}{EI}\\end{equation}$，方程的通解为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=C_{1} \\sin \\beta x+C_{2} \\cos \\beta x+C_{3} \\operatorname{sh} \\beta x+C_{4} \\operatorname{ch} \\beta x\n\\end{equation}</script><h5 id=\"2-2-1-一端固支，一端自由的梁（悬臂梁）的自然模态\"><a href=\"#2-2-1-一端固支，一端自由的梁（悬臂梁）的自然模态\" class=\"headerlink\" title=\"2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态\"></a>2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态</h5><p><img src=\"/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png\" alt=\"图3 悬臂梁自然模态\"></p>\n<p>悬臂梁的边界条件可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(0)=0,\\left.\\quad \\frac{\\mathrm{d} Y(x)}{\\mathrm{d} x}\\right|_{=-0}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}</script><p>特征函数$Y(x)$可表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=1,2 ...\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=-\\frac{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}\n\\end{equation}</script><p>$\\beta_{r}$可由边界条件以数值方法得出，$C_{1}$为待定常数，前三阶振型及相应的自然频率在图2中给出，在图中可以看到，$Y_{r}(x)$有$r-1$个节点。</p>\n<h5 id=\"2-2-2-两端自由的梁的自然模态\"><a href=\"#2-2-2-两端自由的梁的自然模态\" class=\"headerlink\" title=\"2.2.2 两端自由的梁的自然模态\"></a>2.2.2 两端自由的梁的自然模态</h5><p>此处需要注意的是，由于两端自由梁的约束不足，因此前两阶为刚体模态，分别为平动和转动。刚体模态跟刚体运动定义相似，结构内部不发生变形的模态振型即为刚体模态，即刚体运动对应刚体模态。该边界条件下前两节模态如下。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n{\\begin{array}{l}\nY_1(x) = C_{1,1}\\\\\nY_2(x) = C_{1,2}(2x-L)\n\\end{array}}\n\\end{equation}</script><p>悬臂梁的边界条件可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=0}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=0}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}</script><p>可知式18中的系数满足如下关系</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left\\{\n{\\begin{array}{l}\n-C_{1}+C_{3}=0 \\\\\n-C_{2}+C_{4}=0\n\\end{array}}\n\\right.\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{aligned}\n(-\\sin \\beta L+\\operatorname{sh} \\beta L) C_{1}+(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{2} &=0 \\\\\n(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{1}+(\\sin \\beta L+\\operatorname{sh} \\beta L) C_{2} &=0\n\\end{aligned}\n\\end{equation}</script><p>为得到上式的非零解，系数行列式必为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left|\\begin{array}{rr}\n-\\sin \\beta L+\\operatorname{sh} \\beta L & -\\cos \\beta L+\\operatorname{ch} \\beta L \\\\\n-\\cos \\beta L+\\operatorname{ch} \\beta L & \\sin \\beta L+\\operatorname{ch} \\beta L\n\\end{array}\\right|=0\n\\end{equation}</script><p>展开上式化简得特征方程为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\cos \\beta L \\operatorname{ch} \\beta L=1\n\\end{equation}</script><p>可由数值方法求得一系列的$\\beta_r L$的值。</p>\n<p>同上一小节一样，特征函数$Y(x)$可表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=3,4 ...\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=\\frac{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}{-\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L-\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}\n\\end{equation}</script><p>$C_{1}$为待定常数。</p>\n<h5 id=\"2-2-3-Gram-Schmidt正交多项式方法\"><a href=\"#2-2-3-Gram-Schmidt正交多项式方法\" class=\"headerlink\" title=\"2.2.3 Gram-Schmidt正交多项式方法\"></a>2.2.3 Gram-Schmidt正交多项式方法</h5><p>另一种简单的方法是利用Gram-Schmidt正交多项式方法进行表征。在区间$[a,b]$上的正交多项式可以通过如下过程</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{1}(x)=\\left(x-B_{1}\\right) \\phi_{0}(x), \\quad \\phi_{k}(x)=\\left(x-B_{k}\\right) \\phi_{k-1}(x)-C_{k} \\phi_{k-2}(x)\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{c}\nB_{k}=\\frac{(xg_{k},g_{k})}{(g_{k},g_{k})}\n\\\\C_{k}=\\frac{(g_{k},g_{k})}{(g_{k-1},g_{k-1})}\n\\end{array}\n\\end{equation}</script><p>其中$w(x)$是权重系数。</p>\n<p>在本例中，权重选为1，区间为$[0,1]$，同时使之成为标准正交多项式，系数满足以下关系</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\int_{0}^{1} w(x) \\phi_{j}(x) \\phi_{k}(x) \\mathrm{d} x=\\left\\{\\begin{array}{ll}\n0 & \\text { if } j \\neq k \\\\\n1 & \\text { if } j=k\n\\end{array}\\right\\}\n\\end{equation}</script><p>该正多项式序列的首项的选取需要满足伴随板问题的梁问题的边界条件。即使首项$\\phi_{0}(x)$满足所有的几何和力边界条件，其他的多项式一般也只满足集合边界条件，这一点可以通过构造过程得出。</p>\n<p>满足边界条件的多项式首项$\\phi_{0}(x)$的构造方式如</p>\n<h6 id=\"一边固定一边自由的梁\"><a href=\"#一边固定一边自由的梁\" class=\"headerlink\" title=\"一边固定一边自由的梁\"></a><strong>一边固定一边自由的梁</strong></h6><p>挠度函数假设如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=a_{0}+a_{1} x+a_{2} x^{2}+a_{3} x^{3}+a_{4} x^{4}\n\\end{equation}</script><p>且满足边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(0)=Y^{\\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}</script><p>则挠曲形状为（略去任意常数）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=6 x^{2}-4 x^{3}+x^{4}\n\\end{equation}</script><p>将该多项式标准化得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{0}(x)=\\left(6 x^{2}-4 x^{3}+x^{4}\\right) /\\left(\\int_{0}^{1} Y^{2}(x) \\mathrm{d} x\\right)^{1 / 2}\n\\end{equation}</script><h6 id=\"两端自由的梁\"><a href=\"#两端自由的梁\" class=\"headerlink\" title=\"两端自由的梁\"></a><strong>两端自由的梁</strong></h6><p>满足边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY^{\\prime \\prime}(0)=Y^{\\prime \\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}</script><p>标准化后的前两项为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{0}(x)=1\\\\\n\\phi_{1}(x)=2 \\sqrt{3}\\left(x-\\frac{1}{2}\\right)\n\\end{equation}</script><h6 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h6><p>[1] Bhat R B. Natural frequencies of rectangular plates using characteristic orthogonal polynomials in Rayleigh-Ritz method[J]. Journal of Sound and Vibration, 1985, 102(4): 493-499.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"薄板结构的模态分析\"><a href=\"#薄板结构的模态分析\" class=\"headerlink\" title=\"薄板结构的模态分析\"></a>薄板结构的模态分析</h2><h3 id=\"1-薄板的小挠度弯曲\"><a href=\"#1-薄板的小挠度弯曲\" class=\"headerlink\" title=\"1. 薄板的小挠度弯曲\"></a>1. 薄板的小挠度弯曲</h3><h4 id=\"1-1-薄板的基本概念和基本假设\"><a href=\"#1-1-薄板的基本概念和基本假设\" class=\"headerlink\" title=\"1.1 薄板的基本概念和基本假设\"></a>1.1 薄板的基本概念和基本假设</h4><p>薄板是工程结构中的一种常用构件，它是由两个平行面和垂直于它们的柱面所围成的物体，几何特征是其高度远小于底面尺寸，简称板。薄板的弯曲变形属于弹性力学空间问题，由于数学求解的复杂性，因此，需要首先建立应力和变形分布的基本假设。</p>\n<p><img src=\"/images/2021-11-29-薄板结构的模态分析/薄板的基本概念.bmp\" alt=\"图1 薄板的基本概念\"></p>\n<p>薄板的上下两个平行面称为板面，垂直于平行面的柱面称为板边，如图所示。两个平行面之间的距离称为板厚，用$\\delta$ 表示。平分板厚的平面称为板的中面。假设板的厚度为$\\delta$，平分厚度$\\delta$的平面成为板的中间平面，简称为中面。如果板的厚度$\\delta$远小于中面的最小特征尺寸$b$，例如$1/5≤\\delta/b≤1/80$，则成为薄板。如果外载荷为垂直于板的中面作用的横向载荷，则板主要变形为弯曲变形。中面在薄板弯曲时变形成为曲面，中面沿垂直方向，即横向位移称为挠度。对于薄板，仍然有相当的弯曲刚度，如果挠度小于厚度的五分之一，属于小挠度问题。</p>\n<p>根据薄板的外载荷和几何特征，外力为横向载荷，厚度远小于薄板的平面宽度，可以忽略一些次要因素。薄板的小挠度弯曲理论是由三个基本假设作为基础，因为这些基本假设是由基尔霍夫首先提出的，因此又称为<strong>基尔霍夫假设</strong>。</p>\n<p>(1) 变形前垂直于中面的直线变形后仍然保持直线，而且长度不变。这相当于梁的弯曲变形平面假设。根据这一假设， $ε_z＝γ_{zx}＝γ_{zy}＝0$。因此，在板内所有的点，位移分量$w$只是$x$和$y$的函数而与$z$无关。也就是说，在中面的任意一根法线上，薄板沿厚度方向的所有个点都具有挠度$w$。</p>\n<p>(2) 垂直于中面方向的应力分量$σ_z，τ_{zx}，τ_{zy}$ 远小于其他应力分量，其引起的变形可以不计，但是对于维持平衡是必要的，这相当于梁的弯曲无挤压应力假设。</p>\n<p>(3) 薄板弯曲时，中面各点只有垂直中面的位移w，没有平行中面的位移，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nu_{z=0}=0, \\quad v_{z=0}=0\n\\end{equation}</script><p>根据这一假设，板的中面将没有变形发生。板的中面位移函数$w(x, y)$称为挠度函数。</p>\n<h4 id=\"1-2-板的小挠度弯曲的基本方程\"><a href=\"#1-2-板的小挠度弯曲的基本方程\" class=\"headerlink\" title=\"1.2 板的小挠度弯曲的基本方程\"></a>1.2 板的小挠度弯曲的基本方程</h4><p>根据基尔霍夫假设和几何方程可以得到挠度函数表达的应变分量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\varepsilon_{x}=\\frac{\\partial u}{\\partial x}=-\\frac{\\partial^{2} w}{\\partial x^{2}} z \\\\\n\\varepsilon_{y}=\\frac{\\partial v}{\\partial y}=-\\frac{\\partial^{2} w}{\\partial y^{2}} z \\\\\ny_{x y}=\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}=-2 \\frac{\\partial^{2} w}{\\partial x \\partial y} z\n\\end{array}\n\\end{equation}</script><p>和应力分量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\sigma_{x}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right) \\\\\n\\sigma_{y}=\\frac{-E z}{1-v^{2}}\\left(\\frac{\\partial^{2} w}{\\partial y^{2}}+v \\frac{\\partial^{2} w}{\\partial x^{2}}\\right) \\\\\n\\tau_{x y}=\\frac{-E z}{1-v^{2}} \\frac{\\partial^{2} w}{\\partial x \\partial y}\n\\end{array}\n\\end{equation}</script><p>薄板的小挠度弯曲问题，将挠度$w(x,y)$取为基本未知函数，所谓的弹性曲面微分方程可由内力与载荷平衡条件或微元的应力平衡条件得到，如下所示</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nD\\nabla^{2} \\nabla^{2} w=q\n\\end{equation}</script><p>其中$D$称为薄板的弯曲刚度</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nD=\\frac{-E \\delta^{3}}{12\\left(1-v^{2}\\right)}\n\\end{equation}</script><p>该方程已经考虑并完全满足了弹性力学空间问题的平衡微分方程、集合方程和物理方程，以及薄板上、下板面的应力边界条件，得到了求解挠度$w$的基本微分方程。这样，在求解时，只需按照薄板侧面上的边界条件，求出挠度$w$，从而求出应力分量。</p>\n<h4 id=\"1-3-边界条件和挠度函数形式\"><a href=\"#1-3-边界条件和挠度函数形式\" class=\"headerlink\" title=\"1.3 边界条件和挠度函数形式\"></a>1.3 边界条件和挠度函数形式</h4><p>进行薄板结构的模态分析时，关键在于薄板的边界条件。以下给出几种常见的边界条件</p>\n<h5 id=\"1-3-1-固定边OA-x-0\"><a href=\"#1-3-1-固定边OA-x-0\" class=\"headerlink\" title=\"1.3.1 固定边OA($x=0$)\"></a>1.3.1 固定边OA($x=0$)</h5><p>显然有边界挠度和转角均为零的几何条件。因此，在$x=0$边界，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial w}{\\partial x}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}</script><h5 id=\"1-3-2-简支边OA-x-0\"><a href=\"#1-3-2-简支边OA-x-0\" class=\"headerlink\" title=\"1.3.2 简支边OA($x=0$)\"></a>1.3.2 简支边OA($x=0$)</h5><p>薄板在简支边界，不能有挠度，但是可以有微小的转动。因此边界条件为挠度为零和弯矩为零，属于混合边界条件。在$x=0$ 边界，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.w\\right|_{x=0}=0 , \\quad\n\\left.\\frac{\\partial^{2} w}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{array}\n\\end{equation}</script><h5 id=\"1-3-3-自由边OA-x-a\"><a href=\"#1-3-3-自由边OA-x-a\" class=\"headerlink\" title=\"1.3.3 自由边OA($x=a$)\"></a>1.3.3 自由边OA($x=a$)</h5><p>沿自由边OA，薄板的弯矩和扭矩以及横向剪力都等于零，因而有三个边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n\\left.M_{x}\\right|_{x=a}=0, \\quad\n\\left.M_{x y}\\right|_{x=a}=0, \\quad\n\\left.F_{S x}\\right|_{x=a}=0\n\\end{array}\n\\end{equation}</script><p>但是，薄板的挠曲微分方程式四阶的椭圆形偏微分方程，根据偏微分方程理论，在每个边界上，只需要两个边界条件。为此，基尔霍夫指出，薄板任一边界上的扭矩都可以变换为等效的横向剪力，和原来的剪力合并，因而后两个边界条件并不独立。自由边的边界条件用$w$表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{l}\n{\\left[\\frac{\\partial^{2} w}{\\partial x^{2}}+v \\frac{\\partial^{2} w}{\\partial y^{2}}\\right]_{x=a}=0}, \\quad\n{\\left[\\frac{\\partial^{3} w}{\\partial x^{3}}+(2-v) \\frac{\\partial^{3} w}{\\partial x \\partial y^{2}}\\right]_{x=a}=0}\n\\end{array}\n\\end{equation}</script><p>应该指出，如果相邻的两个边界都是自由边界，则扭矩用上述剪力等效替代时，在两个边界的角点将会出现没有抵消的集中剪力$F_{SR}$，如果边界角点没有受到支承，则应该还有角点条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial^{2} w}{\\partial x \\partial y}\\right|_{x=a \\atop y=b}=0\n\\end{equation}</script><h5 id=\"1-3-4-振型函数的近似表示\"><a href=\"#1-3-4-振型函数的近似表示\" class=\"headerlink\" title=\"1.3.4 振型函数的近似表示\"></a>1.3.4 振型函数的近似表示</h5><p>对于四边简支的矩形薄板，能够通过理论推导求出其精确解，然而实际中往往边界条件复杂。因此实际中利用近似法对薄板结构物体进行模态分析是较为方便的。能量法能够近似分析出薄板在不同边界条件下的模态。任意边界条件下的薄板的振型函数$ w(x,y)$都可以利用分离变量法写成下式所示的形式[1] </p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nw(x, y)=\\sum_{m=1}^{p} \\sum_{n=1}^{q} A_{m n} X_{m}(x) Y_{n}(y)\n\\end{equation}</script><p>式中$ w(x,y)$表示薄板中Q点处的挠度，  $x , y$ 是归一化的坐标，$p, q$ 分别代表了 $x, y$ 方向上的多项式总数。 $X_{m}(x), Y_{n}(y)$为满足不同边界条件的多项式。$A_{mn}$表示这些多项式的权重参数。对于不同的边界条件 $X_{m}(x), Y_{n}(y)$的选择也不同。选取适当的多项式后，就可以求取该边界条件下薄板振动时的能量分布，从而求得各种边界条件下的振动模态。</p>\n<h3 id=\"2-梁的弯曲振动\"><a href=\"#2-梁的弯曲振动\" class=\"headerlink\" title=\"2.  梁的弯曲振动\"></a>2.  梁的弯曲振动</h3><p>在使用上述模态振型函数的近似形式时，实际上参考了梁的振动方程。</p>\n<p>如图1所示是一弯曲振动的梁，假设梁的长度和截面高度之比大于10，因而满足材料力学中的欧拉伯努利梁的假设，即（1）变形前垂直梁中心线的平剖面，变形后仍然为平面（刚性横截面假定）；（2）变形后横截面的平面仍与变形后的轴线相垂直。其中忽略了梁的转动动能和剪切变形势能。</p>\n<h4 id=\"2-1-梁的边界条件\"><a href=\"#2-1-梁的边界条件\" class=\"headerlink\" title=\"2.1 梁的边界条件\"></a>2.1 梁的边界条件</h4><p><img src=\"/images/2021-11-29-薄板结构的模态分析/梁的典型边界条件.png\" alt=\"图2 梁的典型边界条件\"></p>\n<p>梁的典型边界条件有如下几种：</p>\n<p>(1) 固支端的边界条件是位移与转角为零 ，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(0, t)=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial y(x, t)}{\\partial x}\\right|_{x=0}=0\n\\end{equation}</script><p>(2) 简支端的边界条件是位移与弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(0, t)=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=0}=0\n\\end{equation}</script><p>(3) 自由端的边界条件是弯矩与剪力为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=0\n\\end{equation}</script><p>(4) 自由端带有弹簧$k$的边界条件是位移与剪力存在如下关系，且弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]_{x=L}=k y(L, t)\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><p>(5) 简支端带有卷簧$k$的边界条件是转角与弯矩之间存在如下关系，且位移为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=-k \\frac{\\partial y(x, t)}{\\partial x}\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(L)=0\n\\end{equation}</script><p>(6) 自由端带有集中质量$M$的边界条件是剪力与加速度之间存在如下关系，且弯矩为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\partial}{\\partial x}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]\\right|_{x=L}=M \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right|_{x=L}=0\n\\end{equation}</script><h4 id=\"2-2-梁的自由振动与模态\"><a href=\"#2-2-梁的自由振动与模态\" class=\"headerlink\" title=\"2.2 梁的自由振动与模态\"></a>2.2 梁的自由振动与模态</h4><p>自由振动情况下$f(x,t)=0$，考虑到梁的弯矩和弯矩变形之间的关系式</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nE I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}=M(x, t)\n\\end{equation}</script><p>通过对梁微元分析并略去高阶小量，梁的自由振动的运动方程可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\partial^{2}}{\\partial x^{2}}\\left[E I(x) \\frac{\\partial^{2} y(x, t)}{\\partial x^{2}}\\right]+m(x) \\frac{\\partial^{2} y(x, t)}{\\partial t^{2}}=0\n\\end{equation}</script><p>设同步运动为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\ny(x, t)=Y(x) \\eta(t)\n\\end{equation}</script><p>带入上式并假定为均匀梁，可得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\frac{\\mathrm{d}^{4} Y(x)}{\\mathrm{d} x^{4}}-\\beta^{4} Y(x)=0\n\\end{equation}</script><p>式中$\\begin{equation}\\beta^{4}=\\frac{\\omega^{2} m}{EI}\\end{equation}$，方程的通解为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=C_{1} \\sin \\beta x+C_{2} \\cos \\beta x+C_{3} \\operatorname{sh} \\beta x+C_{4} \\operatorname{ch} \\beta x\n\\end{equation}</script><h5 id=\"2-2-1-一端固支，一端自由的梁（悬臂梁）的自然模态\"><a href=\"#2-2-1-一端固支，一端自由的梁（悬臂梁）的自然模态\" class=\"headerlink\" title=\"2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态\"></a>2.2.1 一端固支，一端自由的梁（悬臂梁）的自然模态</h5><p><img src=\"/images/2021-11-29-薄板结构的模态分析/悬臂梁自然模态.png\" alt=\"图3 悬臂梁自然模态\"></p>\n<p>悬臂梁的边界条件可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(0)=0,\\left.\\quad \\frac{\\mathrm{d} Y(x)}{\\mathrm{d} x}\\right|_{=-0}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}</script><p>特征函数$Y(x)$可表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=1,2 ...\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=-\\frac{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}\n\\end{equation}</script><p>$\\beta_{r}$可由边界条件以数值方法得出，$C_{1}$为待定常数，前三阶振型及相应的自然频率在图2中给出，在图中可以看到，$Y_{r}(x)$有$r-1$个节点。</p>\n<h5 id=\"2-2-2-两端自由的梁的自然模态\"><a href=\"#2-2-2-两端自由的梁的自然模态\" class=\"headerlink\" title=\"2.2.2 两端自由的梁的自然模态\"></a>2.2.2 两端自由的梁的自然模态</h5><p>此处需要注意的是，由于两端自由梁的约束不足，因此前两阶为刚体模态，分别为平动和转动。刚体模态跟刚体运动定义相似，结构内部不发生变形的模态振型即为刚体模态，即刚体运动对应刚体模态。该边界条件下前两节模态如下。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n{\\begin{array}{l}\nY_1(x) = C_{1,1}\\\\\nY_2(x) = C_{1,2}(2x-L)\n\\end{array}}\n\\end{equation}</script><p>悬臂梁的边界条件可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=0}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=0}=0\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left.\\frac{\\mathrm{d}^{2} Y(x)}{\\mathrm{d} x^{2}}\\right|_{x=L}=0, \\left.\\quad \\frac{\\mathrm{d}^{3} Y(x)}{\\mathrm{d} x^{8}}\\right|_{x=L}=0\n\\end{equation}</script><p>可知式18中的系数满足如下关系</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left\\{\n{\\begin{array}{l}\n-C_{1}+C_{3}=0 \\\\\n-C_{2}+C_{4}=0\n\\end{array}}\n\\right.\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{aligned}\n(-\\sin \\beta L+\\operatorname{sh} \\beta L) C_{1}+(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{2} &=0 \\\\\n(-\\cos \\beta L+\\operatorname{ch} \\beta L) C_{1}+(\\sin \\beta L+\\operatorname{sh} \\beta L) C_{2} &=0\n\\end{aligned}\n\\end{equation}</script><p>为得到上式的非零解，系数行列式必为零，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left|\\begin{array}{rr}\n-\\sin \\beta L+\\operatorname{sh} \\beta L & -\\cos \\beta L+\\operatorname{ch} \\beta L \\\\\n-\\cos \\beta L+\\operatorname{ch} \\beta L & \\sin \\beta L+\\operatorname{ch} \\beta L\n\\end{array}\\right|=0\n\\end{equation}</script><p>展开上式化简得特征方程为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\cos \\beta L \\operatorname{ch} \\beta L=1\n\\end{equation}</script><p>可由数值方法求得一系列的$\\beta_r L$的值。</p>\n<p>同上一小节一样，特征函数$Y(x)$可表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY_{r}(x)=C_{1}\\left[\\left(\\sin \\beta_{r} x-\\operatorname{sh} \\beta_{r} x\\right)+\\xi_{r}\\left(\\cos \\beta_{r} x-\\operatorname{ch} \\beta_{r} x\\right)\\right],\\quad r=3,4 ...\n\\end{equation}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\xi_{r}=\\left(\\frac{C_{2}}{C_{1}}\\right)_{r}=\\frac{\\sin \\beta_{r} L-\\operatorname{sh} \\beta_{r} L}{-\\cos \\beta_{r} L+\\operatorname{ch} \\beta_{r} L}=\\frac{\\cos \\beta_{r} L-\\operatorname{ch} \\beta_{r} L}{\\sin \\beta_{r} L+\\operatorname{sh} \\beta_{r} L}\n\\end{equation}</script><p>$C_{1}$为待定常数。</p>\n<h5 id=\"2-2-3-Gram-Schmidt正交多项式方法\"><a href=\"#2-2-3-Gram-Schmidt正交多项式方法\" class=\"headerlink\" title=\"2.2.3 Gram-Schmidt正交多项式方法\"></a>2.2.3 Gram-Schmidt正交多项式方法</h5><p>另一种简单的方法是利用Gram-Schmidt正交多项式方法进行表征。在区间$[a,b]$上的正交多项式可以通过如下过程</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{1}(x)=\\left(x-B_{1}\\right) \\phi_{0}(x), \\quad \\phi_{k}(x)=\\left(x-B_{k}\\right) \\phi_{k-1}(x)-C_{k} \\phi_{k-2}(x)\n\\end{equation}</script><script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\begin{array}{c}\nB_{k}=\\frac{(xg_{k},g_{k})}{(g_{k},g_{k})}\n\\\\C_{k}=\\frac{(g_{k},g_{k})}{(g_{k-1},g_{k-1})}\n\\end{array}\n\\end{equation}</script><p>其中$w(x)$是权重系数。</p>\n<p>在本例中，权重选为1，区间为$[0,1]$，同时使之成为标准正交多项式，系数满足以下关系</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\int_{0}^{1} w(x) \\phi_{j}(x) \\phi_{k}(x) \\mathrm{d} x=\\left\\{\\begin{array}{ll}\n0 & \\text { if } j \\neq k \\\\\n1 & \\text { if } j=k\n\\end{array}\\right\\}\n\\end{equation}</script><p>该正多项式序列的首项的选取需要满足伴随板问题的梁问题的边界条件。即使首项$\\phi_{0}(x)$满足所有的几何和力边界条件，其他的多项式一般也只满足集合边界条件，这一点可以通过构造过程得出。</p>\n<p>满足边界条件的多项式首项$\\phi_{0}(x)$的构造方式如</p>\n<h6 id=\"一边固定一边自由的梁\"><a href=\"#一边固定一边自由的梁\" class=\"headerlink\" title=\"一边固定一边自由的梁\"></a><strong>一边固定一边自由的梁</strong></h6><p>挠度函数假设如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=a_{0}+a_{1} x+a_{2} x^{2}+a_{3} x^{3}+a_{4} x^{4}\n\\end{equation}</script><p>且满足边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(0)=Y^{\\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}</script><p>则挠曲形状为（略去任意常数）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY(x)=6 x^{2}-4 x^{3}+x^{4}\n\\end{equation}</script><p>将该多项式标准化得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{0}(x)=\\left(6 x^{2}-4 x^{3}+x^{4}\\right) /\\left(\\int_{0}^{1} Y^{2}(x) \\mathrm{d} x\\right)^{1 / 2}\n\\end{equation}</script><h6 id=\"两端自由的梁\"><a href=\"#两端自由的梁\" class=\"headerlink\" title=\"两端自由的梁\"></a><strong>两端自由的梁</strong></h6><p>满足边界条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\nY^{\\prime \\prime}(0)=Y^{\\prime \\prime \\prime}(0)=Y^{\\prime \\prime}(1)=Y^{\\prime \\prime \\prime}(1)=0\n\\end{equation}</script><p>标准化后的前两项为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\phi_{0}(x)=1\\\\\n\\phi_{1}(x)=2 \\sqrt{3}\\left(x-\\frac{1}{2}\\right)\n\\end{equation}</script><h6 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h6><p>[1] Bhat R B. Natural frequencies of rectangular plates using characteristic orthogonal polynomials in Rayleigh-Ritz method[J]. Journal of Sound and Vibration, 1985, 102(4): 493-499.</p>\n"},{"title":"周总结","date":"2021-07-01T03:03:58.000Z","hide":true,"typora-root-url":"..","_content":"\n### 2021\\06\\22\n\n1.准备ppt并参加会议\n18th CIRP Conference on Modelling of Machining Operations\n\t\t2.复习了一下傅里叶变换及频域信号分解相关知识，详见博客（Latex公式有bug，待修复）https://forsetisss.github.io/\n\t\t3.看论文（下周写review）\n\t\t4.准备ppt，25号开会\n首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛\n\t\t5.看文献，transfer learning 和 fault diagnosis 相关\n\t\t6.健身房锻炼\\*2 \n\t\t\t\t\t\t羽毛球\\*1\n\n### 2021\\06\\29\n\n#### 首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告\n\n王振强院士：关于超燃冲压发动机的报告\n此类发动机区别于一般的涡轮发动机，主要应用于高超声速飞行器。由于保密原因，主要介绍的是美国的超燃冲压发动机的研究历史。从上世纪六十年代以来，经历四起三落，现在仍在不断发展中。目前可公开的型号是X-51，仍然只是实验阶段。最新的研究进展都属于保密状态，因为装备此类发动机的飞行器具有极大的战略价值，具有不易拦截和飞行速度快的特点。该类发动机有两个设计难点，高速进气和燃油的混合，以及点火装置。\n\n另外，南航的曲宁松教授介绍了电解加工技术，该加工方法几乎没有热应力和残余应力，且具有较高的加工精度。已经应用于太行航空发动机高压压气机叶片，型面精度达到0.06mm。但一般只能用于导电材料的加工，加工速度较机械加工慢。在电解加工基础上研发精密电解加工技术时，研发人员一直围绕着两个核心问题：如何减少电解液流过的工件和刀具(阴极)的加工间隙；如何提高电解液的充分交换。德国一个公司最先研制出高频脉冲电解加工技术，采用脉冲电流代替直流进行电解加工，从而提高了对电解产物和反应热的排除能力。但曲老师主要介绍的还是电解微纳加工技术 ，通过掩膜形成所需的结构，没听太懂所以就不详细展开了233。\n\n#### 摆线铣\n\n一般在加工过程中都期望提高材料去除率，传统铣削方法通常采用增大刀具啮合角来满足材料去除率的要求；然而，这必然导致刀具和工件之间的接触时间长、切削温度升高，进而影响刀具使用寿命。\n\n摆线铣的轨迹形式通常采用的摆线刀具轨迹有两种模型：圆形模型和次摆线模型。\n\n##### 摆线铣的原理\n\n圆形模型轨迹由圆和直线段组成，刀具公转运行轨迹为圆形，旋转一周后沿圆弧一侧的直线移动一个步长再进行公转。这种加工轨迹的计算较为简单，但是会产生加速度的不连续。\n\n次摆线模型轨迹与圆形模型轨迹相比，主要差别在于刀具进给方向上的运动不单纯是直线运动。这种摆线轨迹在切向和曲率上都是连续的，更容易满足数控机床的运动学要求。一般常用的轨迹是次摆线模型轨迹的改进版，这种轨迹在次摆线轨迹的基础上缩短非切削部分的轨迹长度，采用直线进行连接，从而有助于提高加工效率。\n\n##### 摆线铣的优点\n\n摆线铣加工中，刀具沿摆线轨迹进行切削，可以适应各种加工余量的变化，从而降低加工余量突变对刀具的破坏；特别适合难加工材料的切削加工，如高温合金、钛合金、耐热不锈钢等材料；摆线铣加工技术可以采用较大的轴向切削深度，从而可以代替传统加工中需要进行多次分层的情况。\n\n摆线铣加工过程中刀具负载在每一个摆线循环中都经历了从小到大然后再变小的过程，不会出现刀具负载的突变，从而可以有效减少刀具的磨损，刀具寿命最高可延长5 倍以上；在每一次刀具公转走刀循环过程中，到包含了切削过程和非切削过程，切屑薄容易排出，使得切削区域冷却充分；由于切削时切削力较小，将摆线铣技术与高速加工技术结合则特别适合薄壁零件的高效加工。\n\n### 2021\\08\\24\n\n近场动力学peridynamics，是基于非局部作用思想建立的一整套力学理论体系，该理论通过求解空间积分方程描述物质力学行为，避免了基于连续性假设的传统模型在面临不连续问题时的奇异性和复杂性，成功应用于不同尺度各种不连续问题的模拟中，已成为当前国际计算力学及相关领域的研究热点。\n\n近场动力学是由美国Sandia国家实验室的杰出研究员Stewart Silling博士于2000年提出的。传统的连续介质力学在遇到位移场不连续的情况时（如含裂纹的材料）和遇到应变场不连续的情况时（如复合材料中的界面），在不连续处存在导数没有定义的情况，因此产生求解的困难。近场动力学通过建立积分方程，避免了这种奇异性，把连续和不连续的描述统一起来，并且带来了一个好处是可以模拟裂纹**自发**地萌生和扩展的过程。在以往模型的计算中，每一个计算步都需要判定裂纹继续扩展的条件并更新裂尖的扩展方向，随着裂纹的扩展还需要重新划分网格，或者在计算前需要选用特殊单元限定裂纹将要出现的位置（如cohesive单元）等，至于多裂纹扩展，裂纹分叉或合并等情况在以往数值模型的模拟过程中就更为复杂。而正如下面刚性球撞击脆性板的模拟动画的截图所示，在近场动力学模型的模拟过程中，裂纹的萌生、扩展、分叉等现象都是随着模拟过程自然而然产生的，除加入单一的键断裂条件，不需要过多的判定条件或特殊单元。\n\n![进场动力学模型模拟刚性球撞击脆性板的过程](/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg)\n\n","source":"_posts/2021总结.md","raw":"---\ntitle: 周总结\ndate: 2021-07-01 11:03:58\ntags: \nhide: true\ntypora-root-url: ..\n---\n\n### 2021\\06\\22\n\n1.准备ppt并参加会议\n18th CIRP Conference on Modelling of Machining Operations\n\t\t2.复习了一下傅里叶变换及频域信号分解相关知识，详见博客（Latex公式有bug，待修复）https://forsetisss.github.io/\n\t\t3.看论文（下周写review）\n\t\t4.准备ppt，25号开会\n首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛\n\t\t5.看文献，transfer learning 和 fault diagnosis 相关\n\t\t6.健身房锻炼\\*2 \n\t\t\t\t\t\t羽毛球\\*1\n\n### 2021\\06\\29\n\n#### 首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告\n\n王振强院士：关于超燃冲压发动机的报告\n此类发动机区别于一般的涡轮发动机，主要应用于高超声速飞行器。由于保密原因，主要介绍的是美国的超燃冲压发动机的研究历史。从上世纪六十年代以来，经历四起三落，现在仍在不断发展中。目前可公开的型号是X-51，仍然只是实验阶段。最新的研究进展都属于保密状态，因为装备此类发动机的飞行器具有极大的战略价值，具有不易拦截和飞行速度快的特点。该类发动机有两个设计难点，高速进气和燃油的混合，以及点火装置。\n\n另外，南航的曲宁松教授介绍了电解加工技术，该加工方法几乎没有热应力和残余应力，且具有较高的加工精度。已经应用于太行航空发动机高压压气机叶片，型面精度达到0.06mm。但一般只能用于导电材料的加工，加工速度较机械加工慢。在电解加工基础上研发精密电解加工技术时，研发人员一直围绕着两个核心问题：如何减少电解液流过的工件和刀具(阴极)的加工间隙；如何提高电解液的充分交换。德国一个公司最先研制出高频脉冲电解加工技术，采用脉冲电流代替直流进行电解加工，从而提高了对电解产物和反应热的排除能力。但曲老师主要介绍的还是电解微纳加工技术 ，通过掩膜形成所需的结构，没听太懂所以就不详细展开了233。\n\n#### 摆线铣\n\n一般在加工过程中都期望提高材料去除率，传统铣削方法通常采用增大刀具啮合角来满足材料去除率的要求；然而，这必然导致刀具和工件之间的接触时间长、切削温度升高，进而影响刀具使用寿命。\n\n摆线铣的轨迹形式通常采用的摆线刀具轨迹有两种模型：圆形模型和次摆线模型。\n\n##### 摆线铣的原理\n\n圆形模型轨迹由圆和直线段组成，刀具公转运行轨迹为圆形，旋转一周后沿圆弧一侧的直线移动一个步长再进行公转。这种加工轨迹的计算较为简单，但是会产生加速度的不连续。\n\n次摆线模型轨迹与圆形模型轨迹相比，主要差别在于刀具进给方向上的运动不单纯是直线运动。这种摆线轨迹在切向和曲率上都是连续的，更容易满足数控机床的运动学要求。一般常用的轨迹是次摆线模型轨迹的改进版，这种轨迹在次摆线轨迹的基础上缩短非切削部分的轨迹长度，采用直线进行连接，从而有助于提高加工效率。\n\n##### 摆线铣的优点\n\n摆线铣加工中，刀具沿摆线轨迹进行切削，可以适应各种加工余量的变化，从而降低加工余量突变对刀具的破坏；特别适合难加工材料的切削加工，如高温合金、钛合金、耐热不锈钢等材料；摆线铣加工技术可以采用较大的轴向切削深度，从而可以代替传统加工中需要进行多次分层的情况。\n\n摆线铣加工过程中刀具负载在每一个摆线循环中都经历了从小到大然后再变小的过程，不会出现刀具负载的突变，从而可以有效减少刀具的磨损，刀具寿命最高可延长5 倍以上；在每一次刀具公转走刀循环过程中，到包含了切削过程和非切削过程，切屑薄容易排出，使得切削区域冷却充分；由于切削时切削力较小，将摆线铣技术与高速加工技术结合则特别适合薄壁零件的高效加工。\n\n### 2021\\08\\24\n\n近场动力学peridynamics，是基于非局部作用思想建立的一整套力学理论体系，该理论通过求解空间积分方程描述物质力学行为，避免了基于连续性假设的传统模型在面临不连续问题时的奇异性和复杂性，成功应用于不同尺度各种不连续问题的模拟中，已成为当前国际计算力学及相关领域的研究热点。\n\n近场动力学是由美国Sandia国家实验室的杰出研究员Stewart Silling博士于2000年提出的。传统的连续介质力学在遇到位移场不连续的情况时（如含裂纹的材料）和遇到应变场不连续的情况时（如复合材料中的界面），在不连续处存在导数没有定义的情况，因此产生求解的困难。近场动力学通过建立积分方程，避免了这种奇异性，把连续和不连续的描述统一起来，并且带来了一个好处是可以模拟裂纹**自发**地萌生和扩展的过程。在以往模型的计算中，每一个计算步都需要判定裂纹继续扩展的条件并更新裂尖的扩展方向，随着裂纹的扩展还需要重新划分网格，或者在计算前需要选用特殊单元限定裂纹将要出现的位置（如cohesive单元）等，至于多裂纹扩展，裂纹分叉或合并等情况在以往数值模型的模拟过程中就更为复杂。而正如下面刚性球撞击脆性板的模拟动画的截图所示，在近场动力学模型的模拟过程中，裂纹的萌生、扩展、分叉等现象都是随着模拟过程自然而然产生的，除加入单一的键断裂条件，不需要过多的判定条件或特殊单元。\n\n![进场动力学模型模拟刚性球撞击脆性板的过程](/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg)\n\n","slug":"2021总结","published":1,"updated":"2021-09-07T02:52:51.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9i9z000sy8ux3ohqdkct","content":"<h3 id=\"2021-06-22\"><a href=\"#2021-06-22\" class=\"headerlink\" title=\"2021\\06\\22\"></a>2021\\06\\22</h3><p>1.准备ppt并参加会议<br>18th CIRP Conference on Modelling of Machining Operations<br>        2.复习了一下傅里叶变换及频域信号分解相关知识，详见博客（Latex公式有bug，待修复）<a href=\"https://forsetisss.github.io/\">https://forsetisss.github.io/</a><br>        3.看论文（下周写review）<br>        4.准备ppt，25号开会<br>首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛<br>        5.看文献，transfer learning 和 fault diagnosis 相关<br>        6.健身房锻炼*2<br>                        羽毛球*1</p>\n<h3 id=\"2021-06-29\"><a href=\"#2021-06-29\" class=\"headerlink\" title=\"2021\\06\\29\"></a>2021\\06\\29</h3><h4 id=\"首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛-特邀嘉宾报告\"><a href=\"#首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛-特邀嘉宾报告\" class=\"headerlink\" title=\"首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告\"></a>首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告</h4><p>王振强院士：关于超燃冲压发动机的报告<br>此类发动机区别于一般的涡轮发动机，主要应用于高超声速飞行器。由于保密原因，主要介绍的是美国的超燃冲压发动机的研究历史。从上世纪六十年代以来，经历四起三落，现在仍在不断发展中。目前可公开的型号是X-51，仍然只是实验阶段。最新的研究进展都属于保密状态，因为装备此类发动机的飞行器具有极大的战略价值，具有不易拦截和飞行速度快的特点。该类发动机有两个设计难点，高速进气和燃油的混合，以及点火装置。</p>\n<p>另外，南航的曲宁松教授介绍了电解加工技术，该加工方法几乎没有热应力和残余应力，且具有较高的加工精度。已经应用于太行航空发动机高压压气机叶片，型面精度达到0.06mm。但一般只能用于导电材料的加工，加工速度较机械加工慢。在电解加工基础上研发精密电解加工技术时，研发人员一直围绕着两个核心问题：如何减少电解液流过的工件和刀具(阴极)的加工间隙；如何提高电解液的充分交换。德国一个公司最先研制出高频脉冲电解加工技术，采用脉冲电流代替直流进行电解加工，从而提高了对电解产物和反应热的排除能力。但曲老师主要介绍的还是电解微纳加工技术 ，通过掩膜形成所需的结构，没听太懂所以就不详细展开了233。</p>\n<h4 id=\"摆线铣\"><a href=\"#摆线铣\" class=\"headerlink\" title=\"摆线铣\"></a>摆线铣</h4><p>一般在加工过程中都期望提高材料去除率，传统铣削方法通常采用增大刀具啮合角来满足材料去除率的要求；然而，这必然导致刀具和工件之间的接触时间长、切削温度升高，进而影响刀具使用寿命。</p>\n<p>摆线铣的轨迹形式通常采用的摆线刀具轨迹有两种模型：圆形模型和次摆线模型。</p>\n<h5 id=\"摆线铣的原理\"><a href=\"#摆线铣的原理\" class=\"headerlink\" title=\"摆线铣的原理\"></a>摆线铣的原理</h5><p>圆形模型轨迹由圆和直线段组成，刀具公转运行轨迹为圆形，旋转一周后沿圆弧一侧的直线移动一个步长再进行公转。这种加工轨迹的计算较为简单，但是会产生加速度的不连续。</p>\n<p>次摆线模型轨迹与圆形模型轨迹相比，主要差别在于刀具进给方向上的运动不单纯是直线运动。这种摆线轨迹在切向和曲率上都是连续的，更容易满足数控机床的运动学要求。一般常用的轨迹是次摆线模型轨迹的改进版，这种轨迹在次摆线轨迹的基础上缩短非切削部分的轨迹长度，采用直线进行连接，从而有助于提高加工效率。</p>\n<h5 id=\"摆线铣的优点\"><a href=\"#摆线铣的优点\" class=\"headerlink\" title=\"摆线铣的优点\"></a>摆线铣的优点</h5><p>摆线铣加工中，刀具沿摆线轨迹进行切削，可以适应各种加工余量的变化，从而降低加工余量突变对刀具的破坏；特别适合难加工材料的切削加工，如高温合金、钛合金、耐热不锈钢等材料；摆线铣加工技术可以采用较大的轴向切削深度，从而可以代替传统加工中需要进行多次分层的情况。</p>\n<p>摆线铣加工过程中刀具负载在每一个摆线循环中都经历了从小到大然后再变小的过程，不会出现刀具负载的突变，从而可以有效减少刀具的磨损，刀具寿命最高可延长5 倍以上；在每一次刀具公转走刀循环过程中，到包含了切削过程和非切削过程，切屑薄容易排出，使得切削区域冷却充分；由于切削时切削力较小，将摆线铣技术与高速加工技术结合则特别适合薄壁零件的高效加工。</p>\n<h3 id=\"2021-08-24\"><a href=\"#2021-08-24\" class=\"headerlink\" title=\"2021\\08\\24\"></a>2021\\08\\24</h3><p>近场动力学peridynamics，是基于非局部作用思想建立的一整套力学理论体系，该理论通过求解空间积分方程描述物质力学行为，避免了基于连续性假设的传统模型在面临不连续问题时的奇异性和复杂性，成功应用于不同尺度各种不连续问题的模拟中，已成为当前国际计算力学及相关领域的研究热点。</p>\n<p>近场动力学是由美国Sandia国家实验室的杰出研究员Stewart Silling博士于2000年提出的。传统的连续介质力学在遇到位移场不连续的情况时（如含裂纹的材料）和遇到应变场不连续的情况时（如复合材料中的界面），在不连续处存在导数没有定义的情况，因此产生求解的困难。近场动力学通过建立积分方程，避免了这种奇异性，把连续和不连续的描述统一起来，并且带来了一个好处是可以模拟裂纹<strong>自发</strong>地萌生和扩展的过程。在以往模型的计算中，每一个计算步都需要判定裂纹继续扩展的条件并更新裂尖的扩展方向，随着裂纹的扩展还需要重新划分网格，或者在计算前需要选用特殊单元限定裂纹将要出现的位置（如cohesive单元）等，至于多裂纹扩展，裂纹分叉或合并等情况在以往数值模型的模拟过程中就更为复杂。而正如下面刚性球撞击脆性板的模拟动画的截图所示，在近场动力学模型的模拟过程中，裂纹的萌生、扩展、分叉等现象都是随着模拟过程自然而然产生的，除加入单一的键断裂条件，不需要过多的判定条件或特殊单元。</p>\n<p><img src=\"/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg\" alt=\"进场动力学模型模拟刚性球撞击脆性板的过程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"2021-06-22\"><a href=\"#2021-06-22\" class=\"headerlink\" title=\"2021\\06\\22\"></a>2021\\06\\22</h3><p>1.准备ppt并参加会议<br>18th CIRP Conference on Modelling of Machining Operations<br>        2.复习了一下傅里叶变换及频域信号分解相关知识，详见博客（Latex公式有bug，待修复）<a href=\"https://forsetisss.github.io/\">https://forsetisss.github.io/</a><br>        3.看论文（下周写review）<br>        4.准备ppt，25号开会<br>首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛<br>        5.看文献，transfer learning 和 fault diagnosis 相关<br>        6.健身房锻炼*2<br>                        羽毛球*1</p>\n<h3 id=\"2021-06-29\"><a href=\"#2021-06-29\" class=\"headerlink\" title=\"2021\\06\\29\"></a>2021\\06\\29</h3><h4 id=\"首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛-特邀嘉宾报告\"><a href=\"#首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛-特邀嘉宾报告\" class=\"headerlink\" title=\"首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告\"></a>首届“智能航空器设计与制造”长江教育创新带博士生创新发展论坛 特邀嘉宾报告</h4><p>王振强院士：关于超燃冲压发动机的报告<br>此类发动机区别于一般的涡轮发动机，主要应用于高超声速飞行器。由于保密原因，主要介绍的是美国的超燃冲压发动机的研究历史。从上世纪六十年代以来，经历四起三落，现在仍在不断发展中。目前可公开的型号是X-51，仍然只是实验阶段。最新的研究进展都属于保密状态，因为装备此类发动机的飞行器具有极大的战略价值，具有不易拦截和飞行速度快的特点。该类发动机有两个设计难点，高速进气和燃油的混合，以及点火装置。</p>\n<p>另外，南航的曲宁松教授介绍了电解加工技术，该加工方法几乎没有热应力和残余应力，且具有较高的加工精度。已经应用于太行航空发动机高压压气机叶片，型面精度达到0.06mm。但一般只能用于导电材料的加工，加工速度较机械加工慢。在电解加工基础上研发精密电解加工技术时，研发人员一直围绕着两个核心问题：如何减少电解液流过的工件和刀具(阴极)的加工间隙；如何提高电解液的充分交换。德国一个公司最先研制出高频脉冲电解加工技术，采用脉冲电流代替直流进行电解加工，从而提高了对电解产物和反应热的排除能力。但曲老师主要介绍的还是电解微纳加工技术 ，通过掩膜形成所需的结构，没听太懂所以就不详细展开了233。</p>\n<h4 id=\"摆线铣\"><a href=\"#摆线铣\" class=\"headerlink\" title=\"摆线铣\"></a>摆线铣</h4><p>一般在加工过程中都期望提高材料去除率，传统铣削方法通常采用增大刀具啮合角来满足材料去除率的要求；然而，这必然导致刀具和工件之间的接触时间长、切削温度升高，进而影响刀具使用寿命。</p>\n<p>摆线铣的轨迹形式通常采用的摆线刀具轨迹有两种模型：圆形模型和次摆线模型。</p>\n<h5 id=\"摆线铣的原理\"><a href=\"#摆线铣的原理\" class=\"headerlink\" title=\"摆线铣的原理\"></a>摆线铣的原理</h5><p>圆形模型轨迹由圆和直线段组成，刀具公转运行轨迹为圆形，旋转一周后沿圆弧一侧的直线移动一个步长再进行公转。这种加工轨迹的计算较为简单，但是会产生加速度的不连续。</p>\n<p>次摆线模型轨迹与圆形模型轨迹相比，主要差别在于刀具进给方向上的运动不单纯是直线运动。这种摆线轨迹在切向和曲率上都是连续的，更容易满足数控机床的运动学要求。一般常用的轨迹是次摆线模型轨迹的改进版，这种轨迹在次摆线轨迹的基础上缩短非切削部分的轨迹长度，采用直线进行连接，从而有助于提高加工效率。</p>\n<h5 id=\"摆线铣的优点\"><a href=\"#摆线铣的优点\" class=\"headerlink\" title=\"摆线铣的优点\"></a>摆线铣的优点</h5><p>摆线铣加工中，刀具沿摆线轨迹进行切削，可以适应各种加工余量的变化，从而降低加工余量突变对刀具的破坏；特别适合难加工材料的切削加工，如高温合金、钛合金、耐热不锈钢等材料；摆线铣加工技术可以采用较大的轴向切削深度，从而可以代替传统加工中需要进行多次分层的情况。</p>\n<p>摆线铣加工过程中刀具负载在每一个摆线循环中都经历了从小到大然后再变小的过程，不会出现刀具负载的突变，从而可以有效减少刀具的磨损，刀具寿命最高可延长5 倍以上；在每一次刀具公转走刀循环过程中，到包含了切削过程和非切削过程，切屑薄容易排出，使得切削区域冷却充分；由于切削时切削力较小，将摆线铣技术与高速加工技术结合则特别适合薄壁零件的高效加工。</p>\n<h3 id=\"2021-08-24\"><a href=\"#2021-08-24\" class=\"headerlink\" title=\"2021\\08\\24\"></a>2021\\08\\24</h3><p>近场动力学peridynamics，是基于非局部作用思想建立的一整套力学理论体系，该理论通过求解空间积分方程描述物质力学行为，避免了基于连续性假设的传统模型在面临不连续问题时的奇异性和复杂性，成功应用于不同尺度各种不连续问题的模拟中，已成为当前国际计算力学及相关领域的研究热点。</p>\n<p>近场动力学是由美国Sandia国家实验室的杰出研究员Stewart Silling博士于2000年提出的。传统的连续介质力学在遇到位移场不连续的情况时（如含裂纹的材料）和遇到应变场不连续的情况时（如复合材料中的界面），在不连续处存在导数没有定义的情况，因此产生求解的困难。近场动力学通过建立积分方程，避免了这种奇异性，把连续和不连续的描述统一起来，并且带来了一个好处是可以模拟裂纹<strong>自发</strong>地萌生和扩展的过程。在以往模型的计算中，每一个计算步都需要判定裂纹继续扩展的条件并更新裂尖的扩展方向，随着裂纹的扩展还需要重新划分网格，或者在计算前需要选用特殊单元限定裂纹将要出现的位置（如cohesive单元）等，至于多裂纹扩展，裂纹分叉或合并等情况在以往数值模型的模拟过程中就更为复杂。而正如下面刚性球撞击脆性板的模拟动画的截图所示，在近场动力学模型的模拟过程中，裂纹的萌生、扩展、分叉等现象都是随着模拟过程自然而然产生的，除加入单一的键断裂条件，不需要过多的判定条件或特殊单元。</p>\n<p><img src=\"/images/2021周总结/进场动力学模型模拟刚性球撞击脆性板的过程.jpg\" alt=\"进场动力学模型模拟刚性球撞击脆性板的过程\"></p>\n"},{"title":"环境配置","date":"2022-02-11T09:15:49.000Z","_content":"\n### git clone出现 fatal: unable to access `https://github.com/`...的解决办法\n\n发生这种情况是因为代理是在git中配置的。既然它是https代理（而不是http）git config http.proxy和git config --global http.proxy也无济于事。\n\n在开启shadowsocks的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。\n\n```\ngit config --global http.proxy http://127.0.0.1:1080\ngit config --global https.proxy http://127.0.0.1:1080\n```\n\n`http://`也可以改成`sockets5://`，但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。\n\n取消代理\n\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n### hexo博客MathJax公式渲染问题\n\n用**MathJax语法**写的一些公式，在本地**Markdown编译器**上渲染是没问题的，可是部署到hexo博客中就出现问题了\n\nhexo默认使用**hexo-renderer-marked**引擎去渲染网页，它会把利用**Markdown语法**写的文本去转换为相应的**html标签**。在利用Markdown写**MathJax公式**的时候，经常会用到下划线`_`表示**下标**，但是下划线`_`会被hexo的默认引擎**hexo-renderer-marked**渲染成html中的`<em>`标签，表示**斜体**，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。\n\n问题或许出在hexo的**渲染引擎**上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的**hexo-renderer-kramed**引擎，这里是它的[Github页面](https://github.com/sun11/hexo-renderer-kramed)，所以我们只需要**卸载**默认引擎，并**安装**这个新的渲染引擎即可。\n\n```\nnpm uninstall hexo-renderer-marked --save\nnpm install hexo-renderer-kramed --save\n```\n\n渲染引擎更换之后，发现**大部分**公式都正确渲染了，但仍然存在错误，即是**行间公式**都没有问题，但是个别**行内公式**还会出现渲染出错。\n\n定位到你的**博客根目录**，找到**../node_modules/kramed/lib/rules/inline.js**文件，进行部分修改：\n\n```javascript\n//escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,      第11行，将其修改为\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n//em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,    第20行，将其修改为\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n\n\n### reference\n\n[1] [git clone出现 fatal: unable to access 'https://github.com/...'的解决办法(亲测有效)_Dashi_Lu的博客-CSDN博客](https://blog.csdn.net/Dashi_Lu/article/details/89641778?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant)","source":"_posts/2022-02-11-环境配置.md","raw":"---\ntitle: 环境配置\ndate: 2022-02-11 17:15:49\ntags:\n---\n\n### git clone出现 fatal: unable to access `https://github.com/`...的解决办法\n\n发生这种情况是因为代理是在git中配置的。既然它是https代理（而不是http）git config http.proxy和git config --global http.proxy也无济于事。\n\n在开启shadowsocks的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。\n\n```\ngit config --global http.proxy http://127.0.0.1:1080\ngit config --global https.proxy http://127.0.0.1:1080\n```\n\n`http://`也可以改成`sockets5://`，但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。\n\n取消代理\n\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n### hexo博客MathJax公式渲染问题\n\n用**MathJax语法**写的一些公式，在本地**Markdown编译器**上渲染是没问题的，可是部署到hexo博客中就出现问题了\n\nhexo默认使用**hexo-renderer-marked**引擎去渲染网页，它会把利用**Markdown语法**写的文本去转换为相应的**html标签**。在利用Markdown写**MathJax公式**的时候，经常会用到下划线`_`表示**下标**，但是下划线`_`会被hexo的默认引擎**hexo-renderer-marked**渲染成html中的`<em>`标签，表示**斜体**，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。\n\n问题或许出在hexo的**渲染引擎**上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的**hexo-renderer-kramed**引擎，这里是它的[Github页面](https://github.com/sun11/hexo-renderer-kramed)，所以我们只需要**卸载**默认引擎，并**安装**这个新的渲染引擎即可。\n\n```\nnpm uninstall hexo-renderer-marked --save\nnpm install hexo-renderer-kramed --save\n```\n\n渲染引擎更换之后，发现**大部分**公式都正确渲染了，但仍然存在错误，即是**行间公式**都没有问题，但是个别**行内公式**还会出现渲染出错。\n\n定位到你的**博客根目录**，找到**../node_modules/kramed/lib/rules/inline.js**文件，进行部分修改：\n\n```javascript\n//escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,      第11行，将其修改为\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n//em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,    第20行，将其修改为\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n\n\n### reference\n\n[1] [git clone出现 fatal: unable to access 'https://github.com/...'的解决办法(亲测有效)_Dashi_Lu的博客-CSDN博客](https://blog.csdn.net/Dashi_Lu/article/details/89641778?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant)","slug":"环境配置","published":1,"updated":"2022-02-27T04:05:31.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl04r9ia0000wy8ux64g1g3io","content":"<h3 id=\"git-clone出现-fatal-unable-to-access-https-github-com-…的解决办法\"><a href=\"#git-clone出现-fatal-unable-to-access-https-github-com-…的解决办法\" class=\"headerlink\" title=\"git clone出现 fatal: unable to access https://github.com/…的解决办法\"></a>git clone出现 fatal: unable to access <code>https://github.com/</code>…的解决办法</h3><p>发生这种情况是因为代理是在git中配置的。既然它是https代理（而不是http）git config http.proxy和git config —global http.proxy也无济于事。</p>\n<p>在开启shadowsocks的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\">git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">global</span> http<span class=\"hljs-variable\">.proxy</span> http:<span class=\"hljs-comment\">//127.0.0.1:1080</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">global</span> https<span class=\"hljs-variable\">.proxy</span> http:<span class=\"hljs-comment\">//127.0.0.1:1080</span><br></code></pre></td></tr></table></figure>\n<p><code>http://</code>也可以改成<code>sockets5://</code>，但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。</p>\n<p>取消代理</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tcl\">git config --<span class=\"hljs-keyword\">global</span> --<span class=\"hljs-keyword\">unset</span> <span class=\"hljs-keyword\">http</span>.proxy<br>git config --<span class=\"hljs-keyword\">global</span> --<span class=\"hljs-keyword\">unset</span> https.proxy<br></code></pre></td></tr></table></figure>\n<h3 id=\"hexo博客MathJax公式渲染问题\"><a href=\"#hexo博客MathJax公式渲染问题\" class=\"headerlink\" title=\"hexo博客MathJax公式渲染问题\"></a>hexo博客MathJax公式渲染问题</h3><p>用<strong>MathJax语法</strong>写的一些公式，在本地<strong>Markdown编译器</strong>上渲染是没问题的，可是部署到hexo博客中就出现问题了</p>\n<p>hexo默认使用<strong>hexo-renderer-marked</strong>引擎去渲染网页，它会把利用<strong>Markdown语法</strong>写的文本去转换为相应的<strong>html标签</strong>。在利用Markdown写<strong>MathJax公式</strong>的时候，经常会用到下划线<code>_</code>表示<strong>下标</strong>，但是下划线<code>_</code>会被hexo的默认引擎<strong>hexo-renderer-marked</strong>渲染成html中的<code>&lt;em&gt;</code>标签，表示<strong>斜体</strong>，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</p>\n<p>问题或许出在hexo的<strong>渲染引擎</strong>上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的<strong>hexo-renderer-kramed</strong>引擎，这里是它的<a href=\"https://github.com/sun11/hexo-renderer-kramed\">Github页面</a>，所以我们只需要<strong>卸载</strong>默认引擎，并<strong>安装</strong>这个新的渲染引擎即可。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">npm uninstall hexo-renderer-marked <span class=\"hljs-comment\">--save</span><br>npm install hexo-renderer-kramed <span class=\"hljs-comment\">--save</span><br></code></pre></td></tr></table></figure>\n<p>渲染引擎更换之后，发现<strong>大部分</strong>公式都正确渲染了，但仍然存在错误，即是<strong>行间公式</strong>都没有问题，但是个别<strong>行内公式</strong>还会出现渲染出错。</p>\n<p>定位到你的<strong>博客根目录</strong>，找到<strong>../node_modules/kramed/lib/rules/inline.js</strong>文件，进行部分修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,      第11行，将其修改为</span><br><span class=\"hljs-attr\">escape</span>: <span class=\"hljs-regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,<br><span class=\"hljs-comment\">//em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,    第20行，将其修改为</span><br>em: <span class=\"hljs-regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,<br></code></pre></td></tr></table></figure>\n<h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><p>[1] <a href=\"https://blog.csdn.net/Dashi_Lu/article/details/89641778?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant\">git clone出现 fatal: unable to access ‘https://github.com/…’的解决办法(亲测有效)_Dashi_Lu的博客-CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"git-clone出现-fatal-unable-to-access-https-github-com-…的解决办法\"><a href=\"#git-clone出现-fatal-unable-to-access-https-github-com-…的解决办法\" class=\"headerlink\" title=\"git clone出现 fatal: unable to access https://github.com/…的解决办法\"></a>git clone出现 fatal: unable to access <code>https://github.com/</code>…的解决办法</h3><p>发生这种情况是因为代理是在git中配置的。既然它是https代理（而不是http）git config http.proxy和git config —global http.proxy也无济于事。</p>\n<p>在开启shadowsocks的前提下，手动配置git的代理。git客户端输入如下两个命令就可以了。</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\">git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">global</span> http<span class=\"hljs-variable\">.proxy</span> http:<span class=\"hljs-comment\">//127.0.0.1:1080</span><br>git <span class=\"hljs-keyword\">config</span> --<span class=\"hljs-keyword\">global</span> https<span class=\"hljs-variable\">.proxy</span> http:<span class=\"hljs-comment\">//127.0.0.1:1080</span><br></code></pre></td></tr></table></figure>\n<p><code>http://</code>也可以改成<code>sockets5://</code>，但是区别在于：socks5不支持通过pubkey免密登录github，每次提交代码只能输入用户名和密码。http可以支持免密登录。</p>\n<p>取消代理</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tcl\">git config --<span class=\"hljs-keyword\">global</span> --<span class=\"hljs-keyword\">unset</span> <span class=\"hljs-keyword\">http</span>.proxy<br>git config --<span class=\"hljs-keyword\">global</span> --<span class=\"hljs-keyword\">unset</span> https.proxy<br></code></pre></td></tr></table></figure>\n<h3 id=\"hexo博客MathJax公式渲染问题\"><a href=\"#hexo博客MathJax公式渲染问题\" class=\"headerlink\" title=\"hexo博客MathJax公式渲染问题\"></a>hexo博客MathJax公式渲染问题</h3><p>用<strong>MathJax语法</strong>写的一些公式，在本地<strong>Markdown编译器</strong>上渲染是没问题的，可是部署到hexo博客中就出现问题了</p>\n<p>hexo默认使用<strong>hexo-renderer-marked</strong>引擎去渲染网页，它会把利用<strong>Markdown语法</strong>写的文本去转换为相应的<strong>html标签</strong>。在利用Markdown写<strong>MathJax公式</strong>的时候，经常会用到下划线<code>_</code>表示<strong>下标</strong>，但是下划线<code>_</code>会被hexo的默认引擎<strong>hexo-renderer-marked</strong>渲染成html中的<code>&lt;em&gt;</code>标签，表示<strong>斜体</strong>，这样一来，我们写的MathJax公式就被错误渲染了，也就没办法正确显示出来。</p>\n<p>问题或许出在hexo的<strong>渲染引擎</strong>上，如果渲染引擎不把公式中的一些特殊字符渲染成html标签，也就避免了这个问题。当然已经有人意识到了这个问题，并且对原先的渲染引擎进行了改进，生成了新的<strong>hexo-renderer-kramed</strong>引擎，这里是它的<a href=\"https://github.com/sun11/hexo-renderer-kramed\">Github页面</a>，所以我们只需要<strong>卸载</strong>默认引擎，并<strong>安装</strong>这个新的渲染引擎即可。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">npm uninstall hexo-renderer-marked <span class=\"hljs-comment\">--save</span><br>npm install hexo-renderer-kramed <span class=\"hljs-comment\">--save</span><br></code></pre></td></tr></table></figure>\n<p>渲染引擎更换之后，发现<strong>大部分</strong>公式都正确渲染了，但仍然存在错误，即是<strong>行间公式</strong>都没有问题，但是个别<strong>行内公式</strong>还会出现渲染出错。</p>\n<p>定位到你的<strong>博客根目录</strong>，找到<strong>../node_modules/kramed/lib/rules/inline.js</strong>文件，进行部分修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,      第11行，将其修改为</span><br><span class=\"hljs-attr\">escape</span>: <span class=\"hljs-regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,<br><span class=\"hljs-comment\">//em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,    第20行，将其修改为</span><br>em: <span class=\"hljs-regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,<br></code></pre></td></tr></table></figure>\n<h3 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h3><p>[1] <a href=\"https://blog.csdn.net/Dashi_Lu/article/details/89641778?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant\">git clone出现 fatal: unable to access ‘https://github.com/…’的解决办法(亲测有效)_Dashi_Lu的博客-CSDN博客</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl04r9i9e0001y8uxa6tf9bxf","category_id":"cl04r9i9j0003y8uxa8w88gl4","_id":"cl04r9i9r000dy8ux619paqvy"},{"post_id":"cl04r9i9h0002y8uxciro2pts","category_id":"cl04r9i9o0008y8ux5i9ofjkg","_id":"cl04r9i9u000iy8uxfzyu2z18"},{"post_id":"cl04r9i9l0005y8ux2iktfdzi","category_id":"cl04r9i9r000ey8ux04tjg04g","_id":"cl04r9i9x000oy8ux0xk903pw"},{"post_id":"cl04r9i9m0006y8uxhpd46e4v","category_id":"cl04r9i9r000ey8ux04tjg04g","_id":"cl04r9ia0000uy8uxarfddpmh"},{"post_id":"cl04r9i9o0007y8uxga8j47v0","category_id":"cl04r9i9o0008y8ux5i9ofjkg","_id":"cl04r9ia1000zy8ux13bb9mpw"},{"post_id":"cl04r9i9q000by8ux8hpa21bw","category_id":"cl04r9i9z000ty8ux5hed4923","_id":"cl04r9ia20012y8ux6ow06t63"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","category_id":"cl04r9i9z000ty8ux5hed4923","_id":"cl04r9ia20015y8ux957fhvy1"}],"PostTag":[{"post_id":"cl04r9i9e0001y8uxa6tf9bxf","tag_id":"cl04r9i9l0004y8ux10cb8uxv","_id":"cl04r9i9p000ay8ux7pm23o7w"},{"post_id":"cl04r9i9h0002y8uxciro2pts","tag_id":"cl04r9i9p0009y8uxhgxihtxd","_id":"cl04r9i9z000ry8uxf7or0bet"},{"post_id":"cl04r9i9h0002y8uxciro2pts","tag_id":"cl04r9i9s000fy8uxcgtx6zvi","_id":"cl04r9ia0000vy8uxhj0x5tk9"},{"post_id":"cl04r9i9h0002y8uxciro2pts","tag_id":"cl04r9i9u000ky8ux6649cdne","_id":"cl04r9ia1000yy8ux80xre0zx"},{"post_id":"cl04r9i9l0005y8ux2iktfdzi","tag_id":"cl04r9i9y000py8uxfbos7nz7","_id":"cl04r9ia20014y8ux7l7rgdd3"},{"post_id":"cl04r9i9l0005y8ux2iktfdzi","tag_id":"cl04r9ia0000xy8uxdyvrc3xr","_id":"cl04r9ia20016y8ux3f0x5qu8"},{"post_id":"cl04r9i9l0005y8ux2iktfdzi","tag_id":"cl04r9ia10011y8uxg96rci5v","_id":"cl04r9ia20018y8uxa8qk6vri"},{"post_id":"cl04r9i9m0006y8uxhpd46e4v","tag_id":"cl04r9i9y000py8uxfbos7nz7","_id":"cl04r9ia3001ay8ux8tthh8ea"},{"post_id":"cl04r9i9m0006y8uxhpd46e4v","tag_id":"cl04r9ia20017y8uxc5cgabrm","_id":"cl04r9ia3001by8uxbgia8hip"},{"post_id":"cl04r9i9o0007y8uxga8j47v0","tag_id":"cl04r9i9p0009y8uxhgxihtxd","_id":"cl04r9ia4001fy8uxgg8k0mep"},{"post_id":"cl04r9i9o0007y8uxga8j47v0","tag_id":"cl04r9ia3001cy8uxe4up4woe","_id":"cl04r9ia4001gy8ux21g837vy"},{"post_id":"cl04r9i9o0007y8uxga8j47v0","tag_id":"cl04r9ia3001dy8ux91ksekwh","_id":"cl04r9ia4001iy8uxgfwu441v"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia3001ey8ux8kqnggw3","_id":"cl04r9ia5001ny8ux4u2ugryg"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia4001hy8ux1i8gb8ml","_id":"cl04r9ia5001oy8ux0uz6b51w"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia4001jy8ux4xcy2zoe","_id":"cl04r9ia5001py8ux8bjq1a4u"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia4001ky8uxdj65crbn","_id":"cl04r9ia5001qy8uxfwq9eekb"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia5001ly8ux870mchgt","_id":"cl04r9ia5001ry8uxgi0vcbam"},{"post_id":"cl04r9i9r000cy8ux5zn06c7l","tag_id":"cl04r9ia5001my8uxgj8o1904","_id":"cl04r9ia5001sy8uxf4pq1e3e"}],"Tag":[{"name":"getting started","_id":"cl04r9i9l0004y8ux10cb8uxv"},{"name":"python","_id":"cl04r9i9p0009y8uxhgxihtxd"},{"name":"lambda","_id":"cl04r9i9s000fy8uxcgtx6zvi"},{"name":"map","_id":"cl04r9i9u000ky8ux6649cdne"},{"name":"Matlab","_id":"cl04r9i9y000py8uxfbos7nz7"},{"name":"surf","_id":"cl04r9ia0000xy8uxdyvrc3xr"},{"name":"color","_id":"cl04r9ia10011y8uxg96rci5v"},{"name":"transparency","_id":"cl04r9ia20017y8uxc5cgabrm"},{"name":"Keras","_id":"cl04r9ia3001cy8uxe4up4woe"},{"name":"LN","_id":"cl04r9ia3001dy8ux91ksekwh"},{"name":"FFT","_id":"cl04r9ia3001ey8ux8kqnggw3"},{"name":"STFT","_id":"cl04r9ia4001hy8ux1i8gb8ml"},{"name":"WT","_id":"cl04r9ia4001jy8ux4xcy2zoe"},{"name":"HT","_id":"cl04r9ia4001ky8uxdj65crbn"},{"name":"HHT","_id":"cl04r9ia5001ly8ux870mchgt"},{"name":"signal processing","_id":"cl04r9ia5001my8uxgj8o1904"}]}}